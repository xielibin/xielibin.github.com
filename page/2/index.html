<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>天晷</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="天晷">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="天晷">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天晷">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="天晷" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天晷</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">脑容量有限，清理出来装灵感吧！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Revel-Server-Run" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/31/Revel-Server-Run/" class="article-date">
  <time datetime="2016-03-31T14:39:53.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/Revel-Server-Run/">Revel-Server_Run</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在main执行的最后调用server.go Run func 开启HTTP服务。</p>
<ol>
<li>根据设置的地址和端口等，拼接出 localAddress</li>
<li>生成http.Server ，每个参数接收地址， 第二个是回调 handle, 最后设置Read Write 超时时长。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server = &amp;http.Server&#123;</span><br><span class="line">		Addr:         localAddress,</span><br><span class="line">		Handler:      http.HandlerFunc(handle),</span><br><span class="line">		ReadTimeout:  time.Minute,</span><br><span class="line">		WriteTimeout: time.Minute,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>runStartupHooks() 开启服务前运行在各个文件init里注册的hook 方法。</li>
<li>设置 MainTemplateLoader ，准备解析模板</li>
<li>根据watch情况，设置 MainWatcher 并在 Filter最开始加入 WatchFilter ， 并且监测 Template下文件变动</li>
<li>如果 HttpSsl 是 true , 调用 <code>Server.ListenAndServeTLS(HttpSslCert, HttpSslKey))</code> 开启Server服务。 Server.ListenAndServeTLS : ListenAndServeTLS listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</li>
<li>如果 HttpSsl 是 false , 调用 <code>listener, err := net.Listen(network, localAddress)</code> ： Listen announces on the local network address laddr. 然后 <code>Server.Serve(listener)</code> : Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</li>
</ol>
<h2 id="StartupHooks"><a href="#StartupHooks" class="headerlink" title="StartupHooks"></a>StartupHooks</h2><p>Startup Hook 定义如下 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var startupHooks []func()   //全局变量</span><br><span class="line"></span><br><span class="line">func OnAppStart(f func()) &#123;</span><br><span class="line">	startupHooks = append(startupHooks, f)</span><br><span class="line">&#125;   // 全局注册方法</span><br><span class="line"></span><br><span class="line">//      // from: yourapp/app/controllers/somefile.go</span><br><span class="line">//      func InitDB() &#123;</span><br><span class="line">//          // do DB connection stuff here</span><br><span class="line">//      &#125;</span><br><span class="line">//</span><br><span class="line">//      func FillCache() &#123;</span><br><span class="line">//          // fill a cache from DB</span><br><span class="line">//          // this depends on InitDB having been run</span><br><span class="line">//      &#125;</span><br><span class="line">//</span><br><span class="line">//      // from: yourapp/app/init.go</span><br><span class="line">//      func init() &#123;</span><br><span class="line">//          // set up filters...</span><br><span class="line">//</span><br><span class="line">//          // register startup functions</span><br><span class="line">//          revel.OnAppStart(InitDB)</span><br><span class="line">//          revel.OnAppStart(FillCache)</span><br><span class="line">//      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h2><p>回调方法，对数据处理后 调用 handleInternal ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">		req  = NewRequest(r)</span><br><span class="line">		resp = NewResponse(w)</span><br><span class="line">		c    = NewController(req, resp)</span><br><span class="line">	)   // 生成一个 Req , Res , controller</span><br></pre></td></tr></table></figure>
<p>Filter 看名字感觉是一个过滤机制，对于数据的处理全部都在这个流程  <code>Filters[0](c, Filters[1:])</code></p>
<p>最后根据数据处理的结果到不同的出口，关闭连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if c.Result != nil &#123;</span><br><span class="line">		c.Result.Apply(req, resp)</span><br><span class="line">	&#125; else if c.Response.Status != 0 &#123;</span><br><span class="line">		c.Response.Out.WriteHeader(c.Response.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	// Close the Writer if we can</span><br><span class="line">	if w, ok := resp.Out.(io.Closer); ok &#123;</span><br><span class="line">		w.Close()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/31/Revel-Server-Run/" data-id="cimszvj19000rqpzl5brvxxmt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bond-BindTo-实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/30/Bond-BindTo-实现/" class="article-date">
  <time datetime="2016-03-30T09:42:50.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/Bond-BindTo-实现/">Bond-BindTo 实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Bond 对 UIKit 进行了扩展，让我们能更快更方便的操作UI，来看下如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colorObservable = Observable&lt;UIColor&gt;(UIColor.blackColor())</span><br><span class="line">colorObservable.bindTo(textField.bnd_textColor)</span><br><span class="line"></span><br><span class="line">colorObservable.value = UIColor.redColor()</span><br></pre></td></tr></table></figure>
<p>以后只要根据业务逻辑改变 <code>colorObservable.value</code> 就能间接的设置 textField 的textColor 了，包括很常用 的 button.bnd_enabled 功能。</p>
<h2 id="Extension-NSObject"><a href="#Extension-NSObject" class="headerlink" title="Extension NSObject"></a>Extension NSObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public extension NSObject &#123;</span><br><span class="line">  </span><br><span class="line">  internal var bnd_associatedObservables: [String:AnyObject] &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">      return objc_getAssociatedObject(self, &amp;AssociatedKeys.AssociatedObservablesKey) as? [String:AnyObject] ?? [:]</span><br><span class="line">    &#125;</span><br><span class="line">    set(observable) &#123;</span><br><span class="line">      objc_setAssociatedObject(self, &amp;AssociatedKeys.AssociatedObservablesKey, observable, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public func bnd_associatedObservableForValueForKey&lt;T&gt;(key: String, initial: T? = nil, set: (T -&gt; Void)? = nil) -&gt; Observable&lt;T&gt; &#123;</span><br><span class="line">    if let observable: AnyObject = bnd_associatedObservables[key] &#123;</span><br><span class="line">      return observable as! Observable&lt;T&gt;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let observable = Observable&lt;T&gt;(initial ?? self.valueForKey(key) as! T)</span><br><span class="line">      bnd_associatedObservables[key] = observable</span><br><span class="line">      </span><br><span class="line">      observable</span><br><span class="line">        .observeNew &#123; [weak self] (value: T) in</span><br><span class="line">          if let set = set &#123;</span><br><span class="line">            set(value)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if let value = value as? AnyObject &#123;</span><br><span class="line">              self?.setValue(value, forKey: key)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              self?.setValue(nil, forKey: key)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      return observable</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>var bnd_associatedObservables</code>定义了一个 OC 运行时 存储 观察主题 的 Dictionary 。</p>
<p>其次 bnd_associatedObservableForValueForKey 根据 key 直接返回一个存在的观察主题对象 或者 实例化一个新的。</p>
<p>简单看下实例化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;T&gt;(initial ?? self.valueForKey(key) as! T)</span><br><span class="line">bnd_associatedObservables[key] = observable</span><br></pre></td></tr></table></figure>
<ol>
<li>如果有传入初始化的值 则使用初始化值，没有则通过 KVC 取出对应属性的当前值 ； 作为Observable 的初始值。</li>
<li>保存到 bnd_associatedObservables。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">observable</span><br><span class="line">  .observeNew &#123; [weak self] (value: T) in</span><br><span class="line">    if let set = set &#123;</span><br><span class="line">      set(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if let value = value as? AnyObject &#123;</span><br><span class="line">        self?.setValue(value, forKey: key)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        self?.setValue(nil, forKey: key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为刚才的主题对象增加一个Block观察对象（只接收注册后的值）</li>
<li>如果初始化时传入了自定义的set 闭包， 则调用 set。</li>
<li>如果没有传set 则 采用 KVC方式设置key 对应属性的值。</li>
</ol>
<p>所以继承至NSObject的类都能调用此方法，Bond内 扩展 UITextField textColor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var bnd_textColor: Observable&lt;UIColor?&gt; &#123;</span><br><span class="line">  return bnd_associatedObservableForValueForKey(&quot;textColor&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上就能完成开始时的调用。</p>
<p><strong>但是这样Oberservable并没有驱动性，如何才能有驱动性呢？</strong></p>
<h4 id="具有驱动性的"><a href="#具有驱动性的" class="headerlink" title="具有驱动性的"></a>具有驱动性的</h4><h5 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extension NSNotificationCenter &#123;</span><br><span class="line">  </span><br><span class="line">  public func bnd_notification(name: String, object: AnyObject?) -&gt; EventProducer&lt;NSNotification&gt; &#123;</span><br><span class="line">    return EventProducer &#123; sink in</span><br><span class="line">      let subscription = NSNotificationCenter.defaultCenter().addObserverForName(name, object: object, queue: nil, usingBlock: &#123; notification in</span><br><span class="line">        sink(notification)</span><br><span class="line">      &#125;)</span><br><span class="line">      return BlockDisposable &#123;</span><br><span class="line">        NSNotificationCenter.defaultCenter().removeObserver(subscription)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>利用注册 NotificationCenter 的 sink 驱动 EventProducer 分发事件。</li>
<li>dispose 自动移出 observer。</li>
</ol>
<h5 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@objc class UIControlBondHelper: NSObject</span><br><span class="line">&#123;</span><br><span class="line">  weak var control: UIControl?</span><br><span class="line">  let sink: UIControlEvents -&gt; Void</span><br><span class="line">  </span><br><span class="line">  init(control: UIControl, sink: UIControlEvents -&gt; Void) &#123;</span><br><span class="line">    self.control = control</span><br><span class="line">    self.sink = sink</span><br><span class="line">    super.init()</span><br><span class="line">    control.addTarget(self, action: Selector(&quot;eventHandlerTouchDown&quot;), forControlEvents: UIControlEvents.TouchDown)</span><br><span class="line">    ....... </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  func eventHandlerTouchDown() &#123;</span><br><span class="line">    sink(.TouchDown)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .......</span><br><span class="line">    </span><br><span class="line">  deinit &#123;</span><br><span class="line">    control?.removeTarget(self, action: nil, forControlEvents: UIControlEvents.AllEvents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIControl &#123;</span><br><span class="line">	......	</span><br><span class="line">	</span><br><span class="line">      var capturedSink: (UIControlEvents -&gt; Void)! = nil</span><br><span class="line">      </span><br><span class="line">      let bnd_controlEvent = EventProducer&lt;UIControlEvents&gt; &#123; sink in</span><br><span class="line">        capturedSink = sink</span><br><span class="line">        return nil</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      let controlHelper = UIControlBondHelper(control: self, sink: capturedSink)</span><br><span class="line">      </span><br><span class="line">      objc_setAssociatedObject(self, &amp;AssociatedKeys.ControlBondHelperKey, controlHelper, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">      objc_setAssociatedObject(self, &amp;AssociatedKeys.ControlEventKey, bnd_controlEvent, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">      </span><br><span class="line">      .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>产生bnd_controlEvent 观察主题对象，并将驱动 sink 赋值给 capturedSink。</li>
<li>实例化 controlHelper 并将 capturedSink 传递到 helper内的sink， 最后event产生 调用 sink 驱动事件分发。</li>
</ol>
<p>其中UITextField 的 bnd_text 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public var bnd_text: Observable&lt;String?&gt; &#123;</span><br><span class="line">  if let bnd_text: AnyObject = objc_getAssociatedObject(self, &amp;AssociatedKeys.TextKey) &#123;</span><br><span class="line">    return bnd_text as! Observable&lt;String?&gt;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let bnd_text = Observable&lt;String?&gt;(self.text)</span><br><span class="line">    objc_setAssociatedObject(self, &amp;AssociatedKeys.TextKey, bnd_text, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">    </span><br><span class="line">    var updatingFromSelf: Bool = false</span><br><span class="line">    </span><br><span class="line">    bnd_text.observeNew &#123; [weak self] (text: String?) in</span><br><span class="line">      if !updatingFromSelf &#123;</span><br><span class="line">        self?.text = text</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.bnd_controlEvent.filter &#123; $0 == UIControlEvents.EditingChanged &#125;.observe &#123; [weak self, weak bnd_text] event in</span><br><span class="line">      guard let unwrappedSelf = self, let bnd_text = bnd_text else &#123; return &#125;</span><br><span class="line">      updatingFromSelf = true</span><br><span class="line">      bnd_text.next(unwrappedSelf.text)</span><br><span class="line">      updatingFromSelf = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return bnd_text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BindableType"><a href="#BindableType" class="headerlink" title="BindableType"></a>BindableType</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol BindableType &#123;</span><br><span class="line">  typealias Element</span><br><span class="line">  </span><br><span class="line">  /// Returns a sink that can be used to dispatch events to the receiver.</span><br><span class="line">  /// Can accept a disposable that will be disposed on receiver&apos;s deinit.</span><br><span class="line">  func sink(disconnectDisposable: DisposableType?) -&gt; (Element -&gt; Void)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventProducer 实现了 协议 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension EventProducer: BindableType &#123;</span><br><span class="line">  </span><br><span class="line">  /// Creates a new sink that can be used to update the receiver.</span><br><span class="line">  /// Optionally accepts a disposable that will be disposed on receiver&apos;s deinit.</span><br><span class="line">  public func sink(disconnectDisposable: DisposableType?) -&gt; Event -&gt; Void &#123;</span><br><span class="line">    </span><br><span class="line">    if let disconnectDisposable = disconnectDisposable &#123;</span><br><span class="line">      deinitDisposable += disconnectDisposable</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123; [weak self] value in</span><br><span class="line">      self?.next(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释为：被绑定者自己的分发被封装成一个sink 驱动 传出作为返回</strong></p>
<p>再有绑定者的 BindTo 定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// Establishes a one-way binding between the source and the bindable&apos;s sink</span><br><span class="line">/// and returns a disposable that can cancel observing.</span><br><span class="line">public func bindTo&lt;B: BindableType where B.Element == EventType&gt;(bindable: B) -&gt; DisposableType &#123;</span><br><span class="line">  let disposable = SerialDisposable(otherDisposable: nil)</span><br><span class="line">  let sink = bindable.sink(disposable)</span><br><span class="line">  disposable.otherDisposable = observe &#123; value in</span><br><span class="line">    sink(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return disposable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>let sink = bindable.sink(disposable)</code>，接收被绑定都返回的sink。</li>
<li><code>observe { value in sink(value) }</code>，绑定者注册一个Block观察者， 被在事件响应内 调用sink 完成事件链。</li>
</ol>
<h2 id="bidirectionalBindTo"><a href="#bidirectionalBindTo" class="headerlink" title="bidirectionalBindTo"></a>bidirectionalBindTo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public extension EventProducerType where Self: BindableType &#123;</span><br><span class="line">  </span><br><span class="line">  /// Establishes a one-way binding between the source and the bindable&apos;s sink</span><br><span class="line">  /// and returns a disposable that can cancel observing.</span><br><span class="line">  public func bidirectionalBindTo&lt;B: BindableType where B: EventProducerType, B.EventType == Element, B.Element == EventType&gt;(bindable: B) -&gt; DisposableType &#123;</span><br><span class="line">    let d1 = bindTo(bindable)</span><br><span class="line">    let d2 = bindable.bindTo(self)</span><br><span class="line">    return CompositeDisposable([d1, d2])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将两个满足 BindableType 的Observable 进行相互绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obser1 = Observable&lt;String&gt;(&quot;&quot;)</span><br><span class="line">let obser2 = Observable&lt;String&gt;(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">obser1.bidirectionalBindTo(obser2)</span><br></pre></td></tr></table></figure>
<h4 id="Quertion"><a href="#Quertion" class="headerlink" title="?Quertion"></a>?Quertion</h4><p>相互绑定根据上面的定义不会产生无限相互调用吗？</p>
<p>直接从 bindTo 来看，无论如何都没有解决 这个潜在会存在的问题。</p>
<p>解决问题的代码在 EventProducer.swift 的 dispatchNext 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private func dispatchNext(event: Event) &#123;</span><br><span class="line">  guard !isDispatchInProgress else &#123; return &#125;</span><br><span class="line">  </span><br><span class="line">  lock.lock()</span><br><span class="line">  isDispatchInProgress = true</span><br><span class="line">  for (_, send) in observers &#123;</span><br><span class="line">    send(event)</span><br><span class="line">  &#125;</span><br><span class="line">  isDispatchInProgress = false</span><br><span class="line">  lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isDispatchInProgress 让正在分发事件的对象，不再分发其它事件。。。这里会不会漏掉一部分事件呢？对于这里的加锁，需要再仔细考虑一下</p>
<ol>
<li>obser1 内存地址 –0670， obser2 内存地址 –1ff0</li>
<li><code>obser1.value = &quot;123&quot;</code>, 驱动事件 </li>
<li>obser1 –0670 先进入 <code>dispatchNext(event: Event) // event &quot;123&quot;</code> 并进入for 分发</li>
<li>obser2 –1ff0 进入 <code>dispatchNext(event: Event) // event &quot;123&quot;</code>  并进入 for 分发</li>
<li>obser1 –0670 再次进入 <code>dispatchNext(event: Event) // event &quot;123&quot;</code> 直接 return 停止二次到来事件分发</li>
<li>obser2 –1ff0 先完成分发 并结束 dispatchNext。</li>
<li>obser1 –0670 完成颁发 并结束 dispatchNext。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/30/Bond-BindTo-实现/" data-id="cimszvj000000qpzl2rxkcmja" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-Server-Install" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/30/Linux-Server-Install/" class="article-date">
  <time datetime="2016-03-30T06:08:02.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/Linux-Server-Install/">Linux Server Install - USB 安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天测试环境服务器OS安装也让俺们扛枪上阵，此处，，，</p>
<p>云服务器也是摆弄过很久了，但说实话直接用台式机装单系统Linux还是第一次，顺便记下，下次操作的时候能快点</p>
<p>采用USB驱动安装的方式，典型的台式机（有点年龄了）</p>
<p>资源准备：<br>1.U盘 大小够用就行 2G以上</p>
<p>2.Ubuntu ISO镜像文件下载： <a href="http://www.ubuntu.com/download/server" target="_blank" rel="external">http://www.ubuntu.com/download/server</a></p>
<p>3.能运行的机子，  当然这个时候还是需要键盘 和 显示器</p>
<p>Ubuntu官网：<a href="http://www.ubuntu.com/" target="_blank" rel="external">http://www.ubuntu.com/</a> ， 当然这里面也能找到 桌面版的  。。。。</p>
<h2 id="Mac下ISO写入U盘"><a href="#Mac下ISO写入U盘" class="headerlink" title="Mac下ISO写入U盘"></a>Mac下ISO写入U盘</h2><p>记住 diskutil 、 dd 、iostat 命令</p>
<h5 id="查看磁盘信息"><a href="#查看磁盘信息" class="headerlink" title="查看磁盘信息"></a>查看磁盘信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**-Mac-:~ **$ diskutil list</span><br><span class="line">/dev/disk0 (internal):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                         121.3 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:          Apple_CoreStorage Macintosh HD            120.4 GB   disk0s2</span><br><span class="line">   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3</span><br><span class="line">/dev/disk1 (internal, virtual):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:                  Apple_HFS Macintosh HD           +120.0 GB   disk1</span><br><span class="line">                                 Logical Volume on disk0s2</span><br><span class="line">                                 2A870B27-0CF6-4C3E-8F78-DCAB3D741849</span><br><span class="line">                                 Unlocked Encrypted</span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:     FDisk_partition_scheme                        *8.0 GB     disk2</span><br><span class="line">   1:                 DOS_FAT_32 KINGSTON                8.0 GB     disk2s1</span><br></pre></td></tr></table></figure>
<p>看到我们的U盘挂载为 /dev/disk2</p>
<p>df 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**-Mac-:~ **$ df -h</span><br><span class="line">Filesystem      Size   Used  Avail Capacity  iused   ifree %iused  Mounted on</span><br><span class="line">/dev/disk1     112Gi   82Gi   29Gi    74% 21668000 7634782   74%   /</span><br><span class="line">devfs          183Ki  183Ki    0Bi   100%      636       0  100%   /dev</span><br><span class="line">map -hosts       0Bi    0Bi    0Bi   100%        0       0  100%   /net</span><br><span class="line">map auto_home    0Bi    0Bi    0Bi   100%        0       0  100%   /home</span><br></pre></td></tr></table></figure>
<h5 id="Unmount-U盘"><a href="#Unmount-U盘" class="headerlink" title="Unmount U盘"></a>Unmount U盘</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**-Mac-:~ **$ diskutil unmountDisk /dev/disk2</span><br><span class="line">Unmount of all volumes on disk2 was successful</span><br></pre></td></tr></table></figure>
<h5 id="dd命令将ISO写入U盘"><a href="#dd命令将ISO写入U盘" class="headerlink" title="dd命令将ISO写入U盘"></a>dd命令将ISO写入U盘</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**-Mac-:~ **$ sudo dd if=~/Downloads/ubuntu-14.04.4-server-amd64.iso of=/dev/disk2</span><br><span class="line">1185792+0 records in</span><br><span class="line">1185792+0 records out</span><br><span class="line">607125504 bytes transferred in 513.156579 secs (1183119 bytes/sec)</span><br></pre></td></tr></table></figure>
<p>这个执行的过程有点长，可以查看进度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**-Mac-:~ **$ iostat -w 2</span><br><span class="line"></span><br><span class="line">     disk0           disk2           disk3       cpu     load average</span><br><span class="line">    KB/t tps  MB/s     KB/t tps  MB/s     KB/t tps  MB/s  us sy id   1m   5m   15m</span><br><span class="line">    37.69   5  0.18     4.36   1  0.01   336.10   0  0.02   6  3 91  1.04 1.86 1.81</span><br><span class="line">    0.00   0  0.00     4.00 583  2.28     0.00   0  0.00  10  7 83  1.04 1.85 1.81</span><br><span class="line">    0.00   0  0.00     4.00 340  1.33   512.00   3  1.50  12  6 81  1.04 1.85 1.81</span><br></pre></td></tr></table></figure>
<h5 id="eject-U盘"><a href="#eject-U盘" class="headerlink" title="eject U盘"></a>eject U盘</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**-Mac-:~ **$ diskutil eject /dev/disk2</span><br><span class="line">Disk /dev/disk2 ejected</span><br></pre></td></tr></table></figure>
<h2 id="设置-USB-启动"><a href="#设置-USB-启动" class="headerlink" title="设置 USB 启动"></a>设置 USB 启动</h2><p>常规方式进入 BIOS 设置（什么 F8、F9 。。。。 Del 等方式）， 设置 USB 为首选启动 ， F10 保存</p>
<p>U盘在插入的状态下，将会自动进入 Ubuntu 安装 。。。。。。</p>
<h2 id="自动安装过程"><a href="#自动安装过程" class="headerlink" title="自动安装过程"></a>自动安装过程</h2><p>在这个过程里面基本上都是自动的，也要注意以下几个点：</p>
<ol>
<li><p>磁盘选择情况 </p>
</li>
<li><p>登录用户 一定要记住密码</p>
</li>
<li><p>其它部分根据提示设置即可，当然也要根据实际的需要改变一些设置，毕竟Linux自己可定制性很强嘛 。。。。</p>
</li>
</ol>
<h2 id="完成安装"><a href="#完成安装" class="headerlink" title="完成安装"></a>完成安装</h2><p>这次安装完成了，还是遇到点小麻烦</p>
<p>居然启动不起来，来了一个 reboot and select proper boot device</p>
<p>想想肯定是引导有问题，所以重新选择到Disk （此处被忽悠了一下，这个选项变成灰白色，还以为不能操作。。。。且Driver 下面也是灰白 ，没有选择到正确选项 ，卡住了我）</p>
<p>正常选择Disk 后，再重新启动 就进入到Ubuntu 启动流程， 输入用户名 和 密码  。。。。。</p>
<p>最后拔掉除了网线 和 电源线 以外的其它线缆  。。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/30/Linux-Server-Install/" data-id="cimszvj11000kqpzlsf2nvmki" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mustache-模板解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/29/Mustache-模板解析/" class="article-date">
  <time datetime="2016-03-29T13:35:54.000Z" itemprop="datePublished">2016-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/Mustache-模板解析/">Mustache-模板解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于 revel 生成 main.go 和 routes.go 两个文件，用了模板进行解析，这里用的到的模板规则叫做 mustache。</p>
<p>看了mustache定义后，可以想象一下运用场景。。。。</p>
<p>各种语言解析库集合参考地址：<a href="http://mustache.github.io/" target="_blank" rel="external">http://mustache.github.io/</a><br>mustache 手册参考地址：<a href="http://mustache.github.io/mustache.5.html" target="_blank" rel="external">http://mustache.github.io/mustache.5.html</a></p>
<p>引用一下手册里的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">mustache - Logic-less templates.</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">A typical Mustache template:</span><br><span class="line"></span><br><span class="line">Hello &#123;&#123;name&#125;&#125;</span><br><span class="line">You have just won &#123;&#123;value&#125;&#125; dollars!</span><br><span class="line">&#123;&#123;#in_ca&#125;&#125;</span><br><span class="line">Well, &#123;&#123;taxed_value&#125;&#125; dollars, after taxes.</span><br><span class="line">&#123;&#123;/in_ca&#125;&#125;</span><br><span class="line">Given the following hash:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Chris&quot;,</span><br><span class="line">  &quot;value&quot;: 10000,</span><br><span class="line">  &quot;taxed_value&quot;: 10000 - (10000 * 0.4),</span><br><span class="line">  &quot;in_ca&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">Will produce the following:</span><br><span class="line"></span><br><span class="line">Hello Chris</span><br><span class="line">You have just won 10000 dollars!</span><br><span class="line">Well, 6000.0 dollars, after taxes.</span><br><span class="line">DESCRIPTION</span><br><span class="line">Mustache can be used for HTML, config files, source code - anything. It works by expanding tags in a template using values provided in a hash or object.</span><br><span class="line"></span><br><span class="line">We call it &quot;logic-less&quot; because there are no if statements, else clauses, or for loops. Instead there are only tags. Some tags are replaced with a value, some nothing, and others a series of values. This document explains the different types of Mustache tags.</span><br></pre></td></tr></table></figure>
<p>更多说明和用法参考手册。</p>
<hr>
<h4 id="区别说明"><a href="#区别说明" class="headerlink" title="区别说明"></a>区别说明</h4><p>golang里面的模板解析格式和上面提到的略有差别，下面列出在main.go中一个数组解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;range $k, $v := $.ImportPaths&#125;&#125;</span><br><span class="line">	&#123;&#123;$v&#125;&#125; &quot;&#123;&#123;$k&#125;&#125;&quot;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这是对导入包路径的引入</p>
<p>相比于官方对数组模板解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Template:</span><br><span class="line"></span><br><span class="line">&#123;&#123;#repo&#125;&#125;</span><br><span class="line">  &lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt;</span><br><span class="line">&#123;&#123;/repo&#125;&#125;</span><br><span class="line">Hash:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;repo&quot;: [</span><br><span class="line">    &#123; &quot;name&quot;: &quot;resque&quot; &#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;hub&quot; &#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;rip&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">&lt;b&gt;resque&lt;/b&gt;</span><br><span class="line">&lt;b&gt;hub&lt;/b&gt;</span><br><span class="line">&lt;b&gt;rip&lt;/b&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Server启动入口"><a href="#Server启动入口" class="headerlink" title="Server启动入口"></a>Server启动入口</h4><p>在生成main.go的最后 <code>revel.Run(*port)</code>, 这个方法传入一个端口启动Server 。。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/29/Mustache-模板解析/" data-id="cimszvj0t000hqpzl7v2d0hm7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bond-Chain调用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/29/Bond-Chain调用/" class="article-date">
  <time datetime="2016-03-29T08:04:30.000Z" itemprop="datePublished">2016-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/Bond-Chain调用/">Bond-Chain调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在说明几个链式调用方法之前必须得明白链式调用的定义，如何实现链式调用。在Swift中Array里map、flatMap是满足链式调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3]</span><br><span class="line">let res = arr.map &#123; (i) -&gt; String in</span><br><span class="line">    return &quot;\(i)&quot;</span><br><span class="line">    &#125; .map &#123; (index) -&gt; String in</span><br><span class="line">        return &quot;index:&quot; + index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(res)  //&quot;[&quot;index:1&quot;, &quot;index:2&quot;, &quot;index:3&quot;]\n&quot;</span><br></pre></td></tr></table></figure>
<p>大家请观摩 @唐巧 的烧脑体操（五）(<a href="http://www.infoq.com/cn/articles/swift-brain-gym-monad)里对链式调用实现的讲解。" target="_blank" rel="external">http://www.infoq.com/cn/articles/swift-brain-gym-monad)里对链式调用实现的讲解。</a></p>
<p>在Wiki上关于Monad的解释：</p>
<p>In functional programming, a monad is a structure that represents computations defined as sequences of steps: a type with a monad structure defines what it means to chain operations, or nest functions of that type together. This allows the programmer to build pipelines that process data in a series of steps (also called actions), in which each action is decorated with additional processing rules provided by the monad.</p>
<p>操作方式：<br>A monad is created by defining a type constructor M and two operations, bind and return (where return is often also called unit):</p>
<p>The return operation takes a value from a plain type and puts it into a container using the constructor, creating a monadic value: M a.<br>The bind operation “&gt;&gt;=” takes as its arguments a monadic value M a and a function (a → M b) that can transform the value.<br>The bind operator unwraps the plain value a embedded in its input monadic value M a, and feeds it to the function.<br>The function then creates a new monadic value M b that can be fed to the next bind operators composed in the pipeline.</p>
<p><em>一定要先理解chain调用的原理，这个很重要，不然在swift的道路上往后走多少都将是徒劳，个人见解</em></p>
<p><em>同时补一句，目前烧脑体操系列出的其它节讲的内容也比较细致，前去观摩吧！！！</em></p>
<hr>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>实现代码在 protocol EventProducerType 的扩展里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// Transformes each event by the given `transform` function.</span><br><span class="line">public func map&lt;T&gt;(transform: EventType -&gt; T) -&gt; EventProducer&lt;T&gt; &#123;</span><br><span class="line">  return EventProducer(replayLength: replayLength) &#123; sink in</span><br><span class="line">    return observe &#123; event in</span><br><span class="line">      sink(transform(event))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了对chain调用的理解，就知道目的是返回一个和调用着本身相同，只是Wrapped Value类型上的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//   public typealias Sink = Event -&gt; Void  //是一个Func定义,作为回调</span><br><span class="line"></span><br><span class="line">public func map&lt;T&gt;(transform: EventType -&gt; T) -&gt; EventProducer&lt;T&gt; &#123;</span><br><span class="line">	var producer : (Sink -&gt; DisposableType?)?</span><br><span class="line"></span><br><span class="line">	producer = &#123; sink -&gt; DisposableType? in</span><br><span class="line">      	return self.observe &#123; event -&gt; Void in</span><br><span class="line">      		let transed = transform(event)</span><br><span class="line">        	sink(transed)</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125; //此处注册一个观察者Block对象，当主题分发事件时，observer接收event, 调用transform转换，再回调sink</span><br><span class="line">	</span><br><span class="line">	return EventProducer(replayLength: self.replayLength, producer: producer) //lifecycle 是默认值 .Managed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析EventProducer init方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  public init(replayLength: Int = 0, lifecycle: EventProducerLifecycle = .Managed, @noescape producer: Sink -&gt; DisposableType?) &#123;</span><br><span class="line">    self.lifecycle = lifecycle  // ...</span><br><span class="line">    </span><br><span class="line">    let tmpSelfReference = Reference(self)</span><br><span class="line">    tmpSelfReference.release()</span><br><span class="line">    </span><br><span class="line">    if replayLength &gt; 0 &#123;</span><br><span class="line">      replayBuffer = Buffer(size: replayLength)</span><br><span class="line">    &#125;  // ...</span><br><span class="line">    </span><br><span class="line">    let disposable = producer &#123; event in</span><br><span class="line">      tmpSelfReference.object?.next(event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if let disposable = disposable &#123;</span><br><span class="line">      deinitDisposable += disposable</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.selfReference = tmpSelfReference</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tmpSelfReference = Reference(self)</span><br><span class="line">tmpSelfReference.release()</span><br></pre></td></tr></table></figure>
<p>让对象本身成为无强引用，如果不再追加其它操作，后续会自动释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class Reference&lt;T: AnyObject&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  /// Encapsulated optional object.</span><br><span class="line">  public weak var object: T?</span><br><span class="line">  </span><br><span class="line">  /// Used to strongly reference (retain) encapsulated object.</span><br><span class="line">  private var strongReference: T?</span><br><span class="line">  </span><br><span class="line">  /// Creates the wrapper and strongly references the given object.</span><br><span class="line">  public init(_ object: T) &#123;</span><br><span class="line">    self.object = object</span><br><span class="line">    self.strongReference = object</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /// Relinquishes strong reference to the object, but keeps weak one.</span><br><span class="line">  /// If object it not strongly referenced by anyone else, it will be deallocated.</span><br><span class="line">  public func release() &#123;</span><br><span class="line">    strongReference = nil</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /// Re-establishes a strong reference to the object if it&apos;s still alive,</span><br><span class="line">  /// otherwise it doesn&apos;t do anything useful.</span><br><span class="line">  public func retain() &#123;</span><br><span class="line">    strongReference = object</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let disposable = producer &#123; event in</span><br><span class="line">  tmpSelfReference.object?.next(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var producerInit : (Sink -&gt; DisposableType?)?</span><br><span class="line">producerInit = producer</span><br><span class="line">let sink : (Event -&gt; Void) = &#123; Event -&gt; Void in</span><br><span class="line">	tmpSelfReference.object?.next(event)   //自己变成主题对象，在拿到事件后，分发事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producerInit(sink)</span><br></pre></td></tr></table></figure>
<h5 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h5><p>1.存在的主要对象1 -&gt; 注册 观察对象1 ，观察对象1 -&gt; 持有对新建 主题对象2 的弱引用<br>2.主题对象1 分发事件，-&gt; 观察对象1 接收事件，-&gt; 主要对象1 将事件 转化成（EventType -&gt; T） 事件T ， -&gt; 观察对象1 传递事件T 给主题对象2， -&gt; 主题对象2 接收事件T， -&gt; next(T) 分发事件</p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>与map区别在于 transfrom(转化) 变成了 includeEvent(过滤)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if includeEvent(event) &#123;</span><br><span class="line">  sink(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主题对象1 分发的事件值 经过 includeEvent 计算满足条件 返回true 则 传递事件。 否则 停止流程。</p>
<h2 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn"></a>deliverOn</h2><p>与map 区别 传入一个 Queue作为事件异步分发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123;</span><br><span class="line">  sink(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><p>正如名字一样作开头用处，和filter区别过滤条件 在于这个是关闭固定时间，然后分发最新一次事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public func throttle(seconds: Queue.TimeInterval, queue: Queue) -&gt; EventProducer&lt;EventType&gt; &#123;</span><br><span class="line">  return EventProducer(replayLength: replayLength) &#123; sink in</span><br><span class="line">    var shouldDispatch: Bool = true</span><br><span class="line">    var lastEvent: EventType! = nil</span><br><span class="line">    return observe &#123; event in</span><br><span class="line">      lastEvent = event</span><br><span class="line">      if shouldDispatch &#123;</span><br><span class="line">        shouldDispatch = false</span><br><span class="line">        queue.after(seconds) &#123;</span><br><span class="line">          sink(lastEvent)</span><br><span class="line">          lastEvent = nil</span><br><span class="line">          shouldDispatch = true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了两个变量让 观察对象1 持有分别用于记录最新事件 lastEvent， 判定是否可以分发 shouldDispatch；并且此处是传入的Queue内分发。</p>
<h2 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h2><p>事发定义跳过多少次事件分发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func skip(var count: Int) -&gt; EventProducer&lt;EventType&gt; &#123;</span><br><span class="line">  return EventProducer(replayLength: max(replayLength - count, 0)) &#123; sink in</span><br><span class="line">    return observe &#123; event in</span><br><span class="line">      if count &gt; 0 &#123;</span><br><span class="line">        count--</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        sink(event)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接将count参数申明为var 作为变量让 观察对象1 持有，记录跳过情况。</p>
<h2 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h2><p>定义一个必须要先分发一次的初始事件值，先sink一次。</p>
<h2 id="combineLatestWith"><a href="#combineLatestWith" class="headerlink" title="combineLatestWith"></a>combineLatestWith</h2><p>这是一个很为重要的功能，比如 可以合成多个条件来 最张决定 一个关口是否能够开启</p>
<p>常用例子：<br>名字 和 Email 都不能为空，将两个条件合成 作为判定 提交是否 enable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public func combineLatestWith&lt;U: EventProducerType&gt;(other: U) -&gt; EventProducer&lt;(EventType, U.EventType)&gt; &#123;</span><br><span class="line">  return EventProducer(replayLength: min(replayLength + other.replayLength, 1)) &#123; sink in</span><br><span class="line">    var myEvent: EventType! = nil</span><br><span class="line">    var itsEvent: U.EventType! = nil</span><br><span class="line">    </span><br><span class="line">    let onBothNext = &#123; () -&gt; Void in</span><br><span class="line">      if let myEvent = myEvent, let itsEvent = itsEvent &#123;</span><br><span class="line">        sink((myEvent, itsEvent))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let myDisposable = observe &#123; event in</span><br><span class="line">      myEvent = event</span><br><span class="line">      onBothNext()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let itsDisposable = other.observe &#123; event in</span><br><span class="line">      itsEvent = event</span><br><span class="line">      onBothNext()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return CompositeDisposable([myDisposable, itsDisposable])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义两个变量 myEvent 和 itsEvent 作为存储最新事件值。</li>
<li>定义一个onBothNext 的 闭包 持有 两个变量， 并当两个变量都有值时 调用sink 触发事件分发。</li>
<li>注册自己的 观察闭包对象 赋值新值 调用onBothNext</li>
<li>注册要合成的 另一个主题对象 的 观察闭包对象  赋值新值 调用onBothNext</li>
</ol>
<h3 id="flatMap-reduce"><a href="#flatMap-reduce" class="headerlink" title="flatMap reduce"></a>flatMap reduce</h3><p>这两个功能是放在最后的，目前没发现太好的运用场景。<br><em>说明：这里在说库中Array的用法 </em><br>在库Array里这两个功能的运用场景还是非常强大的， flatMap 会将 nil 过虑掉； reduce 求和较为方便</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/29/Bond-Chain调用/" data-id="cimszvj0c0004qpzlrjldz47a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Revel-run干了什么？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/28/Revel-run干了什么？/" class="article-date">
  <time datetime="2016-03-28T13:13:11.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/Revel-run干了什么？/">Revel-run干了什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>revel run 命令调用执行主要代码位于/revel/cmd/revel/run.go。</p>
<p>运行命令的方式：revel run github.com/revel/samples/chat prod 8080<code>，和new一样revel命令会对运行参数进行进行最后将run后面的参数提取出来作为调用</code>func runApp(args []string)`的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if len(args) == 0 &#123;</span><br><span class="line">	errorf(&quot;No import path given.\nRun &apos;revel help run&apos; for usage.\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Determine the run mode.</span><br><span class="line">mode := &quot;dev&quot;</span><br><span class="line">if len(args) &gt;= 2 &#123;</span><br><span class="line">	mode = args[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判定参数数量，如果多于2个参数则用第一个参数dev或者prod作为运行模式，不然采用默认dev运行模式。</p>
<h2 id="Revel-Init"><a href="#Revel-Init" class="headerlink" title="Revel.Init"></a>Revel.Init</h2><p>接着调用revel.go下 <code>func Init(mode, importPath, srcPath string)</code>，调用代码：<code>revel.Init(mode, args[0], &quot;&quot;)</code></p>
<p>1.该方法先设置各种路径。</p>
<ol>
<li><code>Config, err = LoadConfig(&quot;app.conf&quot;)</code>提取配置文件，读取配置参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func LoadConfig(confName string) (*MergedConfig, error) &#123;</span><br><span class="line">	var err error</span><br><span class="line">	for _, confPath := range ConfPaths &#123;</span><br><span class="line">		conf, err := config.ReadDefault(path.Join(confPath, confName))</span><br><span class="line">		if err == nil &#123;</span><br><span class="line">			return &amp;MergedConfig&#123;conf, &quot;&quot;&#125;, nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if err == nil &#123;</span><br><span class="line">		err = errors.New(&quot;not found&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实config为另一个库 <code>&quot;github.com/robfig/config&quot;</code>。</p>
<p>3.<code>func getLogger(name string) *log.Logger</code>方法生成TRACE、INFO、WARN、ERROR四个Logger。</p>
<ol>
<li><code>func loadModules()</code>加载各种资源模块。</li>
</ol>
<h2 id="Revel-LoadMimeConfig"><a href="#Revel-LoadMimeConfig" class="headerlink" title="Revel.LoadMimeConfig"></a>Revel.LoadMimeConfig</h2><p>此方法位于revel/util.go文件内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func LoadMimeConfig() &#123;</span><br><span class="line">	var err error</span><br><span class="line">	mimeConfig, err = LoadConfig(&quot;mime-types.conf&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		ERROR.Fatalln(&quot;Failed to load mime type config:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载Revel目录下conf/mime-types.conf文件。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Determine the override port, if any.</span><br><span class="line">port := revel.HttpPort</span><br><span class="line">if len(args) == 3 &#123;</span><br><span class="line">	var err error</span><br><span class="line">	if port, err = strconv.Atoi(args[2]); err != nil &#123;</span><br><span class="line">		errorf(&quot;Failed to parse port as integer: %s&quot;, args[2])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">revel.INFO.Printf(&quot;Running %s (%s) in %s mode\n&quot;, revel.AppName, revel.ImportPath, mode)</span><br><span class="line">revel.TRACE.Println(&quot;Base path:&quot;, revel.BasePath)</span><br></pre></td></tr></table></figure>
<p>提取运行的端口，打印将要运行的Server信息。</p>
<hr>
<h2 id="Source-Watch"><a href="#Source-Watch" class="headerlink" title="Source-Watch"></a>Source-Watch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// If the app is run in &quot;watched&quot; mode, use the harness to run it.</span><br><span class="line">if revel.Config.BoolDefault(&quot;watch&quot;, true) &amp;&amp; revel.Config.BoolDefault(&quot;watch.code&quot;, true) &#123;</span><br><span class="line">	revel.TRACE.Println(&quot;Running in watched mode.&quot;)</span><br><span class="line">	revel.HttpPort = port</span><br><span class="line">	harness.NewHarness().Run() // Never returns.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果配置文件内运行的watch模式，则要对src下的资源文件进行监控，发现有变化则要重新自动编译并运行。</p>
<p>在/revel/cmd/harness/harness.go文件里<code>func NewHarness() *Harness</code>生成一个harness。</p>
<h5 id="Harness-Run"><a href="#Harness-Run" class="headerlink" title="Harness.Run"></a>Harness.Run</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var paths []string</span><br><span class="line">if revel.Config.BoolDefault(&quot;watch.gopath&quot;, false) &#123;</span><br><span class="line">	gopaths := filepath.SplitList(build.Default.GOPATH)</span><br><span class="line">	paths = append(paths, gopaths...)</span><br><span class="line">&#125;</span><br><span class="line">paths = append(paths, revel.CodePaths...)</span><br></pre></td></tr></table></figure>
<p>准备Watcher需要的path  src的Code路径和gopath路径。</p>
<p>用revel/watcher.go生成watcher，文件内watcher引用其它库<code>&quot;gopkg.in/fsnotify.v1&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watcher = revel.NewWatcher()</span><br><span class="line">watcher.Listen(h, paths...)</span><br></pre></td></tr></table></figure>
<h6 id="1-通过监听文件变化触发rebuild"><a href="#1-通过监听文件变化触发rebuild" class="headerlink" title="1. 通过监听文件变化触发rebuild"></a>1. 通过监听文件变化触发rebuild</h6><p>Listen方法内目前内容比较深入，就先不分析具体功能，不过我们需要注意到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	if w.eagerRebuildEnabled() &#123;</span><br><span class="line">		// Create goroutine to notify file changes in real time</span><br><span class="line">		go w.NotifyWhenUpdated(listener, watcher)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">// If watcher.mode is set to eager, the application is rebuilt immediately</span><br><span class="line">// when a source file is changed.</span><br><span class="line">// This feature is available only in dev mode.</span><br><span class="line">func (w *Watcher) eagerRebuildEnabled() bool &#123;</span><br><span class="line">	return Config.BoolDefault(&quot;mode.dev&quot;, true) &amp;&amp;</span><br><span class="line">		Config.BoolDefault(&quot;watch&quot;, true) &amp;&amp;</span><br><span class="line">		Config.StringDefault(&quot;watcher.mode&quot;, &quot;normal&quot;) == &quot;eager&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在配置文件内：</span><br><span class="line">//#If you set watcher.mode = &quot;eager&quot;, the server starts to recompile</span><br><span class="line">//#your application every time your application&apos;s files change.</span><br><span class="line">watcher.mode = &quot;normal&quot;</span><br></pre></td></tr></table></figure></p>
<h6 id="2-通过-ReverseProxy-实现请求时观察是否变化再重新rebuild"><a href="#2-通过-ReverseProxy-实现请求时观察是否变化再重新rebuild" class="headerlink" title="2. 通过 ReverseProxy 实现请求时观察是否变化再重新rebuild"></a>2. 通过 ReverseProxy 实现请求时观察是否变化再重新rebuild</h6><p>在<code>func NewHarness() *Harness</code>方法内设置反向代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverUrl, _ := url.ParseRequestURI(fmt.Sprintf(scheme+&quot;://%s:%d&quot;, addr, port))</span><br><span class="line"></span><br><span class="line">harness := &amp;Harness&#123;</span><br><span class="line">	port:       port,</span><br><span class="line">	serverHost: serverUrl.String()[len(scheme+&quot;://&quot;):],</span><br><span class="line">	proxy:      httputil.NewSingleHostReverseProxy(serverUrl),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">		addr := fmt.Sprintf(&quot;%s:%d&quot;, revel.HttpAddr, revel.HttpPort)</span><br><span class="line">		revel.INFO.Printf(&quot;Listening on %s&quot;, addr)</span><br><span class="line"></span><br><span class="line">		var err error</span><br><span class="line">		if revel.HttpSsl &#123;</span><br><span class="line">			err = http.ListenAndServeTLS(addr, revel.HttpSslCert,</span><br><span class="line">				revel.HttpSslKey, h)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			err = http.ListenAndServe(addr, h)</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			revel.ERROR.Fatalln(&quot;Failed to start reverse proxy:&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br></pre></td></tr></table></figure>
<p>用go的并发开启接收请求的代理服务器，将harness作为回调入口。因为harness实现了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A Handler responds to an HTTP request.</span><br><span class="line"></span><br><span class="line">type Handler interface &#123;</span><br><span class="line">        ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// ServeHTTP handles all requests.</span><br><span class="line">// It checks for changes to app, rebuilds if necessary, and forwards the request.</span><br><span class="line">func (hp *Harness) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	// Don&apos;t rebuild the app for favicon requests.</span><br><span class="line">	if lastRequestHadError &gt; 0 &amp;&amp; r.URL.Path == &quot;/favicon.ico&quot; &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Flush any change events and rebuild app if necessary.</span><br><span class="line">	// Render an error page if the rebuild / restart failed.</span><br><span class="line">	err := watcher.Notify()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		atomic.CompareAndSwapInt32(&amp;lastRequestHadError, 0, 1)</span><br><span class="line">		renderError(w, r, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.CompareAndSwapInt32(&amp;lastRequestHadError, 1, 0)</span><br><span class="line"></span><br><span class="line">	// Reverse proxy the request.</span><br><span class="line">	// (Need special code for websockets, courtesy of bradfitz)</span><br><span class="line">	if strings.EqualFold(r.Header.Get(&quot;Upgrade&quot;), &quot;websocket&quot;) &#123;</span><br><span class="line">		proxyWebsocket(w, r, hp.serverHost)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		hp.proxy.ServeHTTP(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>err := watcher.Notify()</code>此处会触发watcher的Notify方法，最后调用harness的Refresh方法进行重新build。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Rebuild the Revel application and run it on the given port.</span><br><span class="line">func (h *Harness) Refresh() (err *revel.Error) &#123;</span><br><span class="line">	if h.app != nil &#123;</span><br><span class="line">		h.app.Kill()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	revel.TRACE.Println(&quot;Rebuild&quot;)</span><br><span class="line">	h.app, err = Build()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h.app.Port = h.port</span><br><span class="line">	if err2 := h.app.Cmd().Start(); err2 != nil &#123;</span><br><span class="line">		return &amp;revel.Error&#123;</span><br><span class="line">			Title:       &quot;App failed to start up&quot;,</span><br><span class="line">			Description: err2.Error(),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>h.app, err = Build()</code> 和 RunApp 方法内 <code>app, err := harness.Build()</code> 后，是进行build操作。</p>
<p>在harness.go文件的 <code>func (hp *Harness) ServeHTTP(w http.ResponseWriter, r *http.Request)</code>方法内处理完rebuild并重新开始服务器后，最后利用 ReverseProxy <code>hp.proxy.ServeHTTP(w, r)</code> 传入请求进行处理。</p>
<h1 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h1><p>开始执行/revel/cmd/revel/build.go文件内 <code>func Build(buildFlags ...string) (app *App, compileError *revel.Error)</code> 方法。</p>
<p><code>cleanSource(&quot;tmp&quot;, &quot;routes&quot;)</code>：在new的时候提到过，tmp、routes是编译时自动生成的，所以在rebuild里需要先清理一下。</p>
<p>接下来准备source info 和 dbImportPath：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sourceInfo, compileError := ProcessSource(revel.CodePaths)</span><br><span class="line">if compileError != nil &#123;</span><br><span class="line">	return nil, compileError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Add the db.import to the import paths.</span><br><span class="line">if dbImportPath, found := revel.Config.String(&quot;db.import&quot;); found &#123;</span><br><span class="line">	sourceInfo.InitImportPaths = append(sourceInfo.InitImportPaths, dbImportPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来就是生成 main.go 和 routes.go ，这个在后面部分再深究：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Generate two source files.</span><br><span class="line">templateArgs := map[string]interface&#123;&#125;&#123;</span><br><span class="line">	&quot;Controllers&quot;:    sourceInfo.ControllerSpecs(),</span><br><span class="line">	&quot;ValidationKeys&quot;: sourceInfo.ValidationKeys,</span><br><span class="line">	&quot;ImportPaths&quot;:    calcImportAliases(sourceInfo),</span><br><span class="line">	&quot;TestSuites&quot;:     sourceInfo.TestSuites(),</span><br><span class="line">&#125;</span><br><span class="line">genSource(&quot;tmp&quot;, &quot;main.go&quot;, MAIN, templateArgs)</span><br><span class="line">genSource(&quot;routes&quot;, &quot;routes.go&quot;, ROUTES, templateArgs)</span><br></pre></td></tr></table></figure>
<p><code>buildTags := revel.Config.StringDefault(&quot;build.tags&quot;, &quot;&quot;)</code>, buildTags读入。</p>
<p><code>goPath, err := exec.LookPath(&quot;go&quot;)</code>,go执行路径。</p>
<p><code>pkg, err := build.Default.Import(revel.ImportPath, &quot;&quot;, build.FindOnly)</code>，应用资源目录。</p>
<p><code>binName := path.Join(pkg.BinDir, &quot;revel.d&quot;, revel.ImportPath, path.Base(revel.BasePath))</code>，这个需要注意一下，是生成的可执行包要导出的位置。</p>
<p>准备编译可执行文件需要的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">appVersion := getAppVersion()</span><br><span class="line">		versionLinkerFlags := fmt.Sprintf(&quot;-X %s/app.APP_VERSION \&quot;%s\&quot;&quot;, revel.ImportPath, appVersion)</span><br><span class="line">		flags := []string&#123;</span><br><span class="line">			&quot;build&quot;,</span><br><span class="line">			&quot;-ldflags&quot;, versionLinkerFlags,</span><br><span class="line">			&quot;-tags&quot;, buildTags,</span><br><span class="line">			&quot;-o&quot;, binName&#125;</span><br><span class="line"></span><br><span class="line">		// Add in build flags</span><br><span class="line">		flags = append(flags, buildFlags...)</span><br><span class="line"></span><br><span class="line">		// The main path</span><br><span class="line">		flags = append(flags, path.Join(revel.ImportPath, &quot;app&quot;, &quot;tmp&quot;))</span><br></pre></td></tr></table></figure>
<p>生成可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buildCmd := exec.Command(goPath, flags...)</span><br><span class="line">revel.TRACE.Println(&quot;Exec:&quot;, buildCmd.Args)</span><br><span class="line">output, err := buildCmd.CombinedOutput()</span><br></pre></td></tr></table></figure>
<p>再关注到/revel/cmd/harness/app.go文件，用<code>func NewApp(binPath string) *App</code>生成应用返回到run.go的runApp方法内，调用app的 <code>func (a *App) Cmd() AppCmd</code> and <code>func (cmd AppCmd) Run()</code> 开始运行程序。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在harness内还有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Kill the app on signal.</span><br><span class="line">	ch := make(chan os.Signal)</span><br><span class="line">	signal.Notify(ch, os.Interrupt, os.Kill)</span><br><span class="line">	&lt;-ch</span><br><span class="line">	if h.app != nil &#123;</span><br><span class="line">		h.app.Kill()</span><br><span class="line">	&#125;</span><br><span class="line">	os.Exit(1)</span><br></pre></td></tr></table></figure>
<p>用Channel 等待 signal 的os.Interrupt 或者 os.Kill 信号事件，如果h.app存在刚kill掉应用，最后退出revel应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/28/Revel-run干了什么？/" data-id="cimszvj1h000wqpzlgcha1mbu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bond-Observable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/28/Bond-Observable/" class="article-date">
  <time datetime="2016-03-28T08:35:09.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/Bond-Observable/">Bond-Observable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Swift Bond是一个binding framework，与ReactiveCocoa、RxSwift都有相通之处。</p>
<p>github : <a href="https://github.com/SwiftBond/Bond" target="_blank" rel="external">https://github.com/SwiftBond/Bond</a></p>
<p>运用Swift Bond可以让UI管理更容易，同时它的核心概念部分是纯Swift写的，可以参考用于完成其它任务。<br>在raywenderlich有一文(<a href="https://www.raywenderlich.com/123108/bond-tutorial)讲解Swift" target="_blank" rel="external">https://www.raywenderlich.com/123108/bond-tutorial)讲解Swift</a> Bond的用法，同时运用Bond讲解如何实现MVVM。</p>
<p>这里说明Swift Bond最基础的Observable处理流程。</p>
<h1 id="EventProducerType"><a href="#EventProducerType" class="headerlink" title="EventProducerType"></a>EventProducerType</h1><p>这是框架最为核心的protocol：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public protocol EventProducerType &#123;</span><br><span class="line">  </span><br><span class="line">  /// Type of event objects or values that the observable generates.</span><br><span class="line">  typealias EventType</span><br><span class="line">  </span><br><span class="line">  /// Maximum number of past events that will be sent to each new observer upon registering.</span><br><span class="line">  /// Actual number of sent events may be less if not enough events were generated previously.</span><br><span class="line">  var replayLength: Int &#123; get &#125;</span><br><span class="line">  </span><br><span class="line">  /// Registers the given observer and returns a disposable that can cancel observing.</span><br><span class="line">  func observe(observer: EventType -&gt; Void) -&gt; DisposableType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>replayLength</code>属性结合<code>public struct Buffer&lt;EventType&gt;</code>主要功能记录主题对象最近的事件值。</p>
<p><code>func observe(observer: EventType -&gt; Void)</code>增加新的观察对象。</p>
<p><code>public class EventProducer&lt;Event&gt;: EventProducerType</code> 是框架内直接实现的 EventProducerType 的类，<code>public final class Observable&lt;Wrapped&gt;: EventProducer&lt;Wrapped&gt;</code>是继承 EventProducer 而来，被定义为final，在应用内简单使用 Observable 类定义主题对象就行。</p>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Buffer定义了一个size大小FIFO的队列用于记录主题对象最近size次事件值。</p>
<p>push func管理队列值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public mutating func push(event: EventType) &#123;</span><br><span class="line">    if size == 1 &#123;</span><br><span class="line">      if buffer.count == 0 &#123;</span><br><span class="line">        buffer.append(event)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        buffer[0] = event;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      buffer.append(event)</span><br><span class="line">      if buffer.count &gt; size &#123;</span><br><span class="line">        buffer.removeFirst()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>replayTo func 重放输出事件值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public func replayTo(sink: EventType -&gt; Void) &#123;</span><br><span class="line">  for event in buffer &#123;</span><br><span class="line">    sink(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><p>观察主题对象类，直接初始化使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public init(_ value: Wrapped) &#123;</span><br><span class="line">  super.init(replayLength: 1)</span><br><span class="line">  next(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func next(event: Event) &#123;</span><br><span class="line">  replayBuffer?.push(event)</span><br><span class="line">  dispatchNext(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.定义一个length为1的Buffer<br>2.分发初始值：push到Buffer，分发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public var value: Wrapped &#123;</span><br><span class="line">  get &#123;</span><br><span class="line">    // We&apos;ve created buffer of size 1 and we own it so it is safe</span><br><span class="line">    // to force unwrap both the buffer and the last element.</span><br><span class="line">    return replayBuffer!.last!</span><br><span class="line">  &#125;</span><br><span class="line">  set &#123;</span><br><span class="line">    next(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个value变量用于存储当前事件值，运用Swift的属性观察机制触发事件分发。</p>
<h1 id="运行调用observe"><a href="#运行调用observe" class="headerlink" title="运行调用observe"></a>运行调用observe</h1><p>要注册观察者需要调用 EventProducerType 的 <code>func observe(observer: EventType -&gt; Void) -&gt; DisposableType</code>，此方法在 EventProducer 内实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public func observe(observer: Event -&gt; Void) -&gt; DisposableType &#123;</span><br><span class="line">  </span><br><span class="line">  if lifecycle == .Managed &#123;</span><br><span class="line">    selfReference?.retain()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let eventProducerBaseDisposable = addObserver(observer)</span><br><span class="line">  </span><br><span class="line">  replayBuffer?.replayTo(observer)</span><br><span class="line">  </span><br><span class="line">  let observerDisposable = BlockDisposable &#123; [weak self] in</span><br><span class="line">    eventProducerBaseDisposable.dispose()</span><br><span class="line">    </span><br><span class="line">    if let unwrappedSelf = self &#123;</span><br><span class="line">      if unwrappedSelf.observers.count == 0 &#123;</span><br><span class="line">        unwrappedSelf.selfReference?.release()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  deinitDisposable += observerDisposable</span><br><span class="line">  return observerDisposable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法内大部分代码都是管理引用，<code>let eventProducerBaseDisposable = addObserver(observer)</code> 增加观察都对象 和 <code>replayBuffer?.replayTo(observer)</code> 将Buffer里的事件值向新增加的观察都观象重放输入。</p>
<p>在 EventProducer 内实现标准的观察者主题的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private func dispatchNext(event: Event) &#123;</span><br><span class="line">  guard !isDispatchInProgress else &#123; return &#125;</span><br><span class="line">  </span><br><span class="line">  lock.lock()</span><br><span class="line">  isDispatchInProgress = true</span><br><span class="line">  for (_, send) in observers &#123;</span><br><span class="line">    send(event)</span><br><span class="line">  &#125;</span><br><span class="line">  isDispatchInProgress = false</span><br><span class="line">  lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private func addObserver(observer: Event -&gt; Void) -&gt; DisposableType &#123;</span><br><span class="line">  lock.lock()</span><br><span class="line">  let token = nextToken</span><br><span class="line">  nextToken = nextToken + 1</span><br><span class="line">  lock.unlock()</span><br><span class="line">  </span><br><span class="line">  observers[token] = observer</span><br><span class="line">  return EventProducerDisposable(eventProducer: self, token: token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private func removeObserver(disposable: EventProducerDisposable&lt;Event&gt;) &#123;</span><br><span class="line">  observers.removeValueForKey(disposable.token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class BindViewModel &#123;</span><br><span class="line">    let object = Observable&lt;String&gt;(&quot;init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BindViewController : UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    let viewModel = BindViewModel()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        viewModel.object.observe &#123; (eventValue) -&gt; Void in</span><br><span class="line">            print(eventValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func action() &#123;</span><br><span class="line">        viewModel.object.value = &quot;1&quot;</span><br><span class="line">        viewModel.object.value = &quot;2&quot;</span><br><span class="line">        viewModel.object.value = &quot;3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行输出：</span><br><span class="line">init</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="observeNew"><a href="#observeNew" class="headerlink" title="observeNew"></a>observeNew</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public func observeNew(observer: EventType -&gt; Void) -&gt; DisposableType &#123;</span><br><span class="line">  var skip: Int = replayLength</span><br><span class="line">  return observe &#123; value in</span><br><span class="line">    if skip &gt; 0 &#123;</span><br><span class="line">      skip--</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      observer(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法为 EventProducerType extension方法，对observe封装一层，让新注册的观察者对象skip replayLength次事件值的分发，可以理解为跳过主题对象Buffer存储的旧事件，只有在注册后的新值才会被分发，，，结合名称就很好理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class BindViewModel &#123;</span><br><span class="line">    let object = Observable&lt;String&gt;(&quot;init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BindViewController : UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    let viewModel = BindViewModel()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        viewModel.object.observeNew &#123; (eventValue) -&gt; Void in</span><br><span class="line">            print(eventValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func action() &#123;</span><br><span class="line">        viewModel.object.value = &quot;1&quot;</span><br><span class="line">        viewModel.object.value = &quot;2&quot;</span><br><span class="line">        viewModel.object.value = &quot;3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行输出：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/28/Bond-Observable/" data-id="cimszvj0a0003qpzlko9sehbr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Revel-新建一个应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/27/Revel-新建一个应用/" class="article-date">
  <time datetime="2016-03-27T13:14:47.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/27/Revel-新建一个应用/">Revel-new准备了什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>运用Go内建命令获得Revel framework，参考地址: <a href="https://revel.github.io/tutorial/gettingstarted.html" target="_blank" rel="external">https://revel.github.io/tutorial/gettingstarted.html</a></p>
<p>其中Revel命令行相关的文件单独放在了./src/cmd/revel目录下，简单需要用的两个命令参数：</p>
<ol>
<li>revel new ： 新建一个应用</li>
<li>revel run ： 运行一个应用</li>
</ol>
<h3 id="Revel应用"><a href="#Revel应用" class="headerlink" title="Revel应用"></a>Revel应用</h3><p>main package 在/revel/cmd/revel/rev.go文件内。</p>
<figure class="highlight plain"><figcaption><span>Cribbed from the genius organization of the "go" command.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Command struct &#123;</span><br><span class="line">	Run                    func(args []string)</span><br><span class="line">	UsageLine, Short, Long string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *Command) Name() string &#123;</span><br><span class="line">	name := cmd.UsageLine</span><br><span class="line">	i := strings.Index(name, &quot; &quot;)</span><br><span class="line">	if i &gt;= 0 &#123;</span><br><span class="line">		name = name[:i]</span><br><span class="line">	&#125;</span><br><span class="line">	return name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var commands = []*Command&#123;</span><br><span class="line">	cmdNew,</span><br><span class="line">	cmdRun,</span><br><span class="line">	cmdBuild,</span><br><span class="line">	cmdPackage,</span><br><span class="line">	cmdClean,</span><br><span class="line">	cmdTest,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	flag.Usage = func() &#123; usage(1) &#125;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	args := flag.Args()</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	for _, cmd := range commands &#123;</span><br><span class="line">		if cmd.Name() == args[0] &#123;</span><br><span class="line">			cmd.Run(args[1:])</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行指定命令 …</p>
<h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p>今天的任务记录下 new 执行操作，主要内容为./src/cmd/revel/new.go 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var cmdNew = &amp;Command&#123;</span><br><span class="line">	UsageLine: &quot;new [path] [skeleton]&quot;,</span><br><span class="line">	Short:     &quot;create a skeleton Revel application&quot;,</span><br><span class="line">	Long: `</span><br><span class="line">New creates a few files to get a new Revel application running quickly.</span><br><span class="line"></span><br><span class="line">It puts all of the files in the given import path, taking the final element in</span><br><span class="line">the path to be the app name.</span><br><span class="line"></span><br><span class="line">Skeleton is an optional argument, provided as an import path</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line"></span><br><span class="line">    revel new import/path/helloworld</span><br><span class="line"></span><br><span class="line">    revel new import/path/helloworld import/path/skeleton</span><br><span class="line">`,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	cmdNew.Run = newApp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newApp(args []string)</span><br></pre></td></tr></table></figure>
<p>这里介绍了new 命令调用方式，revel 命令会对整个参数作处理，并将new后的参数作为newApp的参数运行newApp func。</p>
<h2 id="initGoPaths-func"><a href="#initGoPaths-func" class="headerlink" title="initGoPaths func"></a>initGoPaths func</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func initGoPaths() &#123;</span><br><span class="line">	// lookup go path</span><br><span class="line">	gopath = build.Default.GOPATH</span><br><span class="line">	if gopath == &quot;&quot; &#123;</span><br><span class="line">		errorf(&quot;Abort: GOPATH environment variable is not set. &quot; +</span><br><span class="line">			&quot;Please refer to http://golang.org/doc/code.html to configure your Go environment.&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// set go src path</span><br><span class="line">	srcRoot = filepath.Join(filepath.SplitList(gopath)[0], &quot;src&quot;)</span><br><span class="line"></span><br><span class="line">	// check for go executable</span><br><span class="line">	var err error</span><br><span class="line">	gocmd, err = exec.LookPath(&quot;go&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		errorf(&quot;Go executable not found in PATH.&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在go/build下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Default Context = defaultContext()</span><br><span class="line"></span><br><span class="line">Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables if set, or else the compiled code&apos;s GOARCH, GOOS, and GOROOT.</span><br></pre></td></tr></table></figure>
<p>所以 <code>gopath = build.Default.GOPATH</code> 是判定系统是否设置了GOPATH</p>
<p><code>srcRoot = filepath.Join(filepath.SplitList(gopath)[0], &quot;src&quot;)</code>将第0个GOPATH追加/src作为新应用的source目录。</p>
<p>文档定义exec.LookPath:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func LookPath(file string) (string, error)</span><br><span class="line"></span><br><span class="line">LookPath searches for an executable binary named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.</span><br></pre></td></tr></table></figure>
<p><code>gocmd, err = exec.LookPath(&quot;go&quot;)</code> 找到go命令的执行路径。</p>
<h2 id="setApplicationPath-func"><a href="#setApplicationPath-func" class="headerlink" title="setApplicationPath func"></a>setApplicationPath func</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func setApplicationPath(args []string) &#123;</span><br><span class="line">	var err error</span><br><span class="line">	importPath = args[0]</span><br><span class="line">	if filepath.IsAbs(importPath) &#123;</span><br><span class="line">		errorf(&quot;Abort: &apos;%s&apos; looks like a directory.  Please provide a Go import path instead.&quot;,</span><br><span class="line">			importPath)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = build.Import(importPath, &quot;&quot;, build.FindOnly)</span><br><span class="line">	if err == nil &#123;</span><br><span class="line">		errorf(&quot;Abort: Import path %s already exists.\n&quot;, importPath)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	revelPkg, err = build.Import(revel.REVEL_IMPORT_PATH, &quot;&quot;, build.FindOnly)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		errorf(&quot;Abort: Could not find Revel source code: %s\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	appPath = filepath.Join(srcRoot, filepath.FromSlash(importPath))</span><br><span class="line">	appName = filepath.Base(appPath)</span><br><span class="line">	basePath = filepath.ToSlash(filepath.Dir(importPath))</span><br><span class="line"></span><br><span class="line">	if basePath == &quot;.&quot; &#123;</span><br><span class="line">		// we need to remove the a single &apos;.&apos; when</span><br><span class="line">		// the app is in the $GOROOT/src directory</span><br><span class="line">		basePath = &quot;&quot;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// we need to append a &apos;/&apos; when the app is</span><br><span class="line">		// is a subdirectory such as $GOROOT/src/path/to/revelapp</span><br><span class="line">		basePath += &quot;/&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>importPath = args[0]</code>可用于被其它应用导入引用的目录。</p>
<p>build.Import定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)</span><br><span class="line"></span><br><span class="line">If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information.</span><br></pre></td></tr></table></figure>
<p><code>_, err = build.Import(importPath, &quot;&quot;, build.FindOnly)</code>判定准备新建的应用路径是否已经存在。</p>
<p>在revel.go文件下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	REVEL_IMPORT_PATH = &quot;github.com/revel/revel&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>revelPkg, err = build.Import(revel.REVEL_IMPORT_PATH, &quot;&quot;, build.FindOnly)</code> 判定是否已经获取的revel framework 资源。</p>
<p><code>appPath = filepath.Join(srcRoot, filepath.FromSlash(importPath))</code> 生成完整的appPath。</p>
<p><code>appName = filepath.Base(appPath)</code> 获取应用的名称。</p>
<p><code>basePath = filepath.ToSlash(filepath.Dir(importPath))</code>应用的相对src 目录。</p>
<h2 id="setSkeletonPath"><a href="#setSkeletonPath" class="headerlink" title="setSkeletonPath"></a>setSkeletonPath</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func setSkeletonPath(args []string) &#123;</span><br><span class="line">	var err error</span><br><span class="line">	if len(args) == 2 &#123; // user specified</span><br><span class="line">		skeletonName := args[1]</span><br><span class="line">		_, err = build.Import(skeletonName, &quot;&quot;, build.FindOnly)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			// Execute &quot;go get &lt;pkg&gt;&quot;</span><br><span class="line">			getCmd := exec.Command(gocmd, &quot;get&quot;, &quot;-d&quot;, skeletonName)</span><br><span class="line">			fmt.Println(&quot;Exec:&quot;, getCmd.Args)</span><br><span class="line">			getOutput, err := getCmd.CombinedOutput()</span><br><span class="line"></span><br><span class="line">			// check getOutput for no buildible string</span><br><span class="line">			bpos := bytes.Index(getOutput, []byte(&quot;no buildable Go source files in&quot;))</span><br><span class="line">			if err != nil &amp;&amp; bpos == -1 &#123;</span><br><span class="line">				errorf(&quot;Abort: Could not find or &apos;go get&apos; Skeleton  source code: %s\n%s\n&quot;, getOutput, skeletonName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// use the</span><br><span class="line">		skeletonPath = filepath.Join(srcRoot, skeletonName)</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// use the revel default</span><br><span class="line">		skeletonPath = filepath.Join(revelPkg.Dir, &quot;skeleton&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newApp第二个参数是用于导入skelenton的，如果没有第二个参数则用revel框架默认自带的资源在/src/github.com/revel/revel/skeleton下。</p>
<p>先用<code>_, err = build.Import(skeletonName, &quot;&quot;, build.FindOnly)</code>直接导入本地资源，如果不存在这里就要用到之前准备好的gocomd路径调用系统go命令以get的方式从网上拉取资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getCmd := exec.Command(gocmd, &quot;get&quot;, &quot;-d&quot;, skeletonName)</span><br><span class="line">fmt.Println(&quot;Exec:&quot;, getCmd.Args)</span><br><span class="line">getOutput, err := getCmd.CombinedOutput()</span><br><span class="line"></span><br><span class="line">// check getOutput for no buildible string</span><br><span class="line">bpos := bytes.Index(getOutput, []byte(&quot;no buildable Go source files in&quot;))</span><br><span class="line">if err != nil &amp;&amp; bpos == -1 &#123;</span><br><span class="line">	errorf(&quot;Abort: Could not find or &apos;go get&apos; Skeleton  source code: %s\n%s\n&quot;, getOutput, skeletonName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后得到 skeletonPath :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skeletonPath = filepath.Join(srcRoot, skeletonName) //有参数</span><br><span class="line">skeletonPath = filepath.Join(revelPkg.Dir, &quot;skeleton&quot;) //无参数，默认</span><br></pre></td></tr></table></figure>
<h2 id="copyNewAppFiles"><a href="#copyNewAppFiles" class="headerlink" title="copyNewAppFiles"></a>copyNewAppFiles</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func copyNewAppFiles() &#123;</span><br><span class="line">	var err error</span><br><span class="line">	err = os.MkdirAll(appPath, 0777)</span><br><span class="line">	panicOnError(err, &quot;Failed to create directory &quot;+appPath)</span><br><span class="line"></span><br><span class="line">	mustCopyDir(appPath, skeletonPath, map[string]interface&#123;&#125;&#123;</span><br><span class="line">		// app.conf</span><br><span class="line">		&quot;AppName&quot;:  appName,</span><br><span class="line">		&quot;BasePath&quot;: basePath,</span><br><span class="line">		&quot;Secret&quot;:   generateSecret(),</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	// Dotfiles are skipped by mustCopyDir, so we have to explicitly copy the .gitignore.</span><br><span class="line">	gitignore := &quot;.gitignore&quot;</span><br><span class="line">	mustCopyFile(filepath.Join(appPath, gitignore), filepath.Join(skeletonPath, gitignore))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是建一个appPath的目录，设置权限为0777。<br>调用mustCopyDir方法复制文件，该定义在/cmd/revel/util.go文件里。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>根据模板生成主要包括app、conf、messages、public、tests文件夹和README.ME文件。</p>
<p>最开始我是很纠结的，就是木有找到main方法的入口，非常让我郁闷，都开始怀疑不需要main包也能运行（当然这是说笑，只是研究到点上而已）。</p>
<p>不过最终我找到该文件，是在调用run或者build时在Build阶段由framework在app目录下自动生成子目录。</p>
<p>1.会生成一个tmp文件夹 里面有main.go。<br>2.还会生成一个routes文件 里面有routes.go。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/27/Revel-新建一个应用/" data-id="cimszvj1e000uqpzltugctnkb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-后端小记开始" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/27/后端小记开始/" class="article-date">
  <time datetime="2016-03-27T13:04:07.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/27/后端小记开始/">后端小记开始</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记的东西越多，忘得越快，为了忘时能快速回忆，所以还是得记下来 – 致开始衰退的记忆力</p>
<hr>
<p>从开始转行干编程的活，主要是以iOS开发为主，前两年Object-C，目前已用Swift快一年进入感觉和领悟也开始记下，OC的还会写，但是已经没有那么熟悉能记下的都是比较重要的部分了。</p>
<p>其它语言到现在各种都有看过；不过最让我怀念的还是大学的时候，记得汇编学得挺不错的，可惜现在是一点反应都没有。其它像C、Java都是写写语法，没有实战。唯一实战的就只有js、HTML了，毕竟在iOS开发上也要用到。</p>
<p>一不小心就开始接触Go语言，也拿着练了练手写着感觉还不错，当然Swift现在也能进行后端开发，但俗话说，不能在一棵树上吊死嘛，长点见识总是好的，所以毅然还是Go吧。</p>
<p>使用Go语言、Revel框架、MySQL作为记录的开始。</p>
<hr>
<p>各种准备就不说了，参考</p>
<p>Go语言官方网站：<a href="http://golang.org/" target="_blank" rel="external">http://golang.org/</a></p>
<p>Revel官方文档：<a href="http://revel.github.io/index.html" target="_blank" rel="external">http://revel.github.io/index.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/27/后端小记开始/" data-id="cimszvj1n0012qpzl0bks3yqc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/26/观察者模式/" class="article-date">
  <time datetime="2016-03-26T11:05:26.000Z" itemprop="datePublished">2016-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/26/观察者模式/">观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//设计原则一：为了交互对象之间的松耦合设计而努力。<br>//松耦合的设计之所以能让我们建立有弹性的oo系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p>
<p>//观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<hr>
<h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol Observer &#123;</span><br><span class="line">    var id : Int &#123;get set&#125;</span><br><span class="line">    func update(temp : Float, humidity : Float, pressure : Float)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Subject &#123;</span><br><span class="line">    func registerObserver(o : Observer)</span><br><span class="line">    func removeObserver(o : Observer)</span><br><span class="line">    func notifyObservers()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主题对象实现接口"><a href="#主题对象实现接口" class="headerlink" title="主题对象实现接口"></a>主题对象实现接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class WeatherData: Subject &#123;</span><br><span class="line">    private var observers = Array&lt;Observer&gt;()</span><br><span class="line">    </span><br><span class="line">    private var temp : Float = 0.0 &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            notifyObservers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private var humidity : Float = 0.0 &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            notifyObservers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private var pressure : Float = 0.0 &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            notifyObservers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func registerObserver(o: Observer) &#123;</span><br><span class="line">        observers.append(o)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeObserver(o: Observer) &#123;</span><br><span class="line">        let index = observers.indexOf &#123; (ob) -&gt; Bool in</span><br><span class="line">            return o.id == ob.id</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard index != nil else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        observers.removeAtIndex(index!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    internal func notifyObservers() &#123;</span><br><span class="line">        for o in observers &#123;</span><br><span class="line">            o.update(temp, humidity: humidity, pressure: pressure)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察者实现接口"><a href="#观察者实现接口" class="headerlink" title="观察者实现接口"></a>观察者实现接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol DisplayElement &#123;</span><br><span class="line">    func display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var index : Int = 0</span><br><span class="line"></span><br><span class="line">class CurrentConditionsDisplay: Observer, DisplayElement &#123;</span><br><span class="line">    internal var id : Int</span><br><span class="line">    private var temp : Float = 0.0</span><br><span class="line">    private var humidity : Float = 0.0</span><br><span class="line">    private var pressure : Float = 0.0</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">        id = ++index</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func update(temp: Float, humidity: Float, pressure: Float) &#123;</span><br><span class="line">        self.temp = temp</span><br><span class="line">        self.humidity = humidity</span><br><span class="line">        self.pressure = pressure</span><br><span class="line">        </span><br><span class="line">        display()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func display() &#123;</span><br><span class="line">       print(&quot;temp : \(temp), humidity : \(humidity), pressure : \(pressure)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let dataCenter = WeatherData()</span><br><span class="line">let displayPlat = CurrentConditionsDisplay()</span><br><span class="line">dataCenter.registerObserver(displayPlat)</span><br><span class="line"></span><br><span class="line">dataCenter.temp = 10</span><br><span class="line">dataCenter.pressure = 20</span><br><span class="line"></span><br><span class="line">dataCenter.removeObserver(displayPlat)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/26/观察者模式/" data-id="cimszvj1y001bqpzl60o5d9h2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pattern/">Pattern</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Pattern/" style="font-size: 16.67px;">Pattern</a> <a href="/tags/Swift/" style="font-size: 20px;">Swift</a> <a href="/tags/iOS/" style="font-size: 16.67px;">iOS</a> <a href="/tags/后端/" style="font-size: 20px;">后端</a> <a href="/tags/工具/" style="font-size: 13.33px;">工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/09/KVO-PG/">KVO_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/08/KVC-PG/">KVC_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
          </li>
        
          <li>
            <a href="/2016/04/06/责任链/">责任链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 天晷<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>