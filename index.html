<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>天晷</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="天晷">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="天晷">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天晷">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="天晷" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天晷</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">脑容量有限，清理出来装灵感吧！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-KVO-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/09/KVO-PG/" class="article-date">
  <time datetime="2016-04-09T08:38:06.000Z" itemprop="datePublished">2016-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/09/KVO-PG/">KVO_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVO是一种机制被用于当其它对象指定属性改变时 观察对象被及时通知。在MVC工作模式下，KVO对Model属性改变及时通知Controller是非常有利的。</p>
<p>KVO主要优势在于不用开发时去用其它机制进行实现，基础框架已经做了很好的支持。</p>
<p>关于KVO相关扩展方法定义在 ： import Foundation.NSKeyValueObserving</p>
<h2 id="Register-KVO"><a href="#Register-KVO" class="headerlink" title="Register KVO"></a>Register KVO</h2><p>要实现对特定属性采用KVO机制进行观察，必须满足以下三点：</p>
<ol>
<li>被观察的类的指定属性必须是遵守KVO规则的。</li>
<li>必须让观察对象用addObserver:forKeyPath:options:context:向被观察对象注册。</li>
<li>观察对象必须实现observeValueForKeyPath:ofObject:change:context:。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ObserveredClass : NSObject &#123;</span><br><span class="line">    var value : String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InstanceClass : NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    // Receiving Notification of a Change</span><br><span class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">        if keyPath == &quot;value&quot; &#123;</span><br><span class="line">            print(change?[NSKeyValueChangeNewKey])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observered = ObserveredClass()</span><br><span class="line">let instance = InstanceClass()</span><br><span class="line"></span><br><span class="line">// Registering as an Observer</span><br><span class="line">instance.addObserver(observered, forKeyPath: &quot;value&quot;, options: NSKeyValueObservingOptions.New, context: nil)</span><br><span class="line">observered.value = &quot;123&quot;</span><br><span class="line"></span><br><span class="line">// Removing an Object as an Observer</span><br><span class="line">instance.removeObserver(observered, forKeyPath: &quot;value&quot;, context: nil)</span><br></pre></td></tr></table></figure>
<h2 id="KVO-Compliance"><a href="#KVO-Compliance" class="headerlink" title="KVO Compliance"></a>KVO Compliance</h2><p>符合KVO规则，需要有以下三点：</p>
<ol>
<li>这个类的观察属性必须是满足 KVC 规则的，KVO支持的数据类型和KVC一致。</li>
<li>类必须能触发属性改变的通知。</li>
<li>依赖的key注册也能适合运用。</li>
</ol>
<p>有两种方法触发属性改变通知。</p>
<h4 id="Auto-Change"><a href="#Auto-Change" class="headerlink" title="Auto Change"></a>Auto Change</h4><p>自动触发：NSObject提供了默认的支持，当属性是符合KVC规则时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Call the accessor method.</span><br><span class="line">[account setName:@&quot;Savings&quot;];</span><br><span class="line"> </span><br><span class="line">// Use setValue:forKey:.</span><br><span class="line">[account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.</span><br><span class="line">[document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span><br><span class="line">Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;</span><br><span class="line">NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure>
<h4 id="Manual-Change"><a href="#Manual-Change" class="headerlink" title="Manual Change"></a>Manual Change</h4><p>手动触发： 提供了更小粒度控制，何时、如何触发通知。可以减少不必要的触发，或者集合一定数量通知同时触发。</p>
<p>Class实现手动触发必须继承NSObject并且实现 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</span><br><span class="line"> </span><br><span class="line">    BOOL automatic = NO;</span><br><span class="line">    if ([theKey isEqualToString:@&quot;openingBalance&quot;]) &#123;</span><br><span class="line">        automatic = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        automatic = [super automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    return automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现手动通知观察者，在改变值前调用 willChangeValueForKey：，并在改变值后调用 didChangeValueForKey：；可优化触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setOpeningBalance:(double)theBalance &#123;</span><br><span class="line">    if (theBalance != _openingBalance) &#123;</span><br><span class="line">        [self willChangeValueForKey:@&quot;openingBalance&quot;];</span><br><span class="line">        _openingBalance = theBalance;</span><br><span class="line">        [self didChangeValueForKey:@&quot;openingBalance&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于to-many relationship，不但要指定属性值改变，而且要通过 NSKeyValueChange 表示 改变的类型  NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, or NSKeyValueChangeReplacement。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line"> </span><br><span class="line">    // Remove the transaction objects at the specified indexes.</span><br><span class="line"> </span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Registering-Dependent-Keys"><a href="#Registering-Dependent-Keys" class="headerlink" title="Registering Dependent Keys"></a>Registering Dependent Keys</h2><h4 id="To-one"><a href="#To-one" class="headerlink" title="To-one"></a>To-one</h4><p>注册依赖keys，自动触发通知可以 重写 keyPathsForValuesAffectingValueForKey： 方法 或者  根据规则实现适当的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,firstName, lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="重写-keyPathsForValuesAffectingValueForKey：-方法："><a href="#重写-keyPathsForValuesAffectingValueForKey：-方法：" class="headerlink" title="重写 keyPathsForValuesAffectingValueForKey： 方法："></a>重写 keyPathsForValuesAffectingValueForKey： 方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line"> </span><br><span class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现-keyPathsForValuesAffecting-方法"><a href="#实现-keyPathsForValuesAffecting-方法" class="headerlink" title="实现 keyPathsForValuesAffecting 方法"></a>实现 keyPathsForValuesAffecting<key> 方法</key></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于在扩展里，由于不能override keyPathsForValuesAffectingValueForKey，所以只能通过实现 keyPathsForValuesAffecting<key> 的方式实现。</key></p>
<h4 id="To-many"><a href="#To-many" class="headerlink" title="To-many"></a>To-many</h4><p>The keyPathsForValuesAffectingValueForKey: method does not support key-paths that include a to-many relationship. For example, suppose you have a Department object with a to-many relationship (employees) to a Employee, and Employee has a salary attribute. You might want the Department object have a totalSalary attribute that is dependent upon the salaries of all the Employees in the relationship. You can not do this with, for example, keyPathsForValuesAffectingTotalSalary and returning employees.salary as a key.</p>
<p>采用过渡的技巧实现，观察：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let totalSalaryContext = UnsafeMutablePointer&lt;Void&gt;()</span><br><span class="line"></span><br><span class="line">class Employee: NSObject &#123;</span><br><span class="line">    dynamic var salary : NSNumber = 1.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Department: NSObject &#123;</span><br><span class="line">    let employees : NSArray = [Employee(), Employee()]</span><br><span class="line">    dynamic var totalSalay : CGFloat = 0.0</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        employees.forEach &#123; (object) -&gt; () in</span><br><span class="line">            object.addObserver(self, forKeyPath: &quot;salary&quot;, options: NSKeyValueObservingOptions.New, context: totalSalaryContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        employees.forEach &#123; (object) -&gt; () in</span><br><span class="line">            object.removeObserver(self, forKeyPath: &quot;salary&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">        if (context == totalSalaryContext) &#123;</span><br><span class="line">            updateTotalSalary()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func updateTotalSalary() &#123;</span><br><span class="line">        let new = self.valueForKeyPath(&quot;employees.@sum.salary&quot;) as? NSNumber ?? 0</span><br><span class="line">        totalSalay = CGFloat(new)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let department = Department()</span><br><span class="line">department.addObserver(self, forKeyPath: &quot;totalSalay&quot;, options: NSKeyValueObservingOptions.New, context: nil)</span><br><span class="line"></span><br><span class="line">override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">    if keyPath == &quot;totalSalay&quot; &#123;</span><br><span class="line">        print(change?[NSKeyValueChangeNewKey])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(department.employees.lastObject as? Employee)?.salary = 20  //触发</span><br></pre></td></tr></table></figure>
<h2 id="Key-Value-Observing-Implementation-Details"><a href="#Key-Value-Observing-Implementation-Details" class="headerlink" title="Key-Value Observing Implementation Details"></a>Key-Value Observing Implementation Details</h2><p>自动KVO采用isa-swizzling的方法实现。</p>
<p>isa是一个指向操作分发表对象类的指针。对象类的分发表包含方法的实现和其它各种数据。</p>
<p>当一个观察对象向被观察对象注册一个属性时，被观察对象的isa指针改变，去指向一个中介的class而不再指向原来的class。所以这个isa指针不能再完全反应实例对象的实际class。</p>
<p>不能用改变后的isa指针去判定class关系。需要用类方法判定实例对象所属的类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/09/KVO-PG/" data-id="cimszol57000fi8zlld8ep7g9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-KVC-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/08/KVC-PG/" class="article-date">
  <time datetime="2016-04-08T10:31:50.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/08/KVC-PG/">KVC_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVC是NSKeyValueCoding协议定义的一种机制，用string标示对象属性，间接的使用对象的属性。本质上，KVC定义了相应的模式和方法进行校验从而满足应用采用valueForKey的方式接入。</p>
<p>访问器方法，提供接入应用数据模型的方式，有get访问器 和 set访问器。</p>
<p>在应用内实现KVC是一个很重要的原则，因为KVC是作为KVO、Core Data、Cocoa绑定、scriptability的重要基础。同时采用KVC也能简化应用编码。</p>
<p>key是一个字符串用于标示对象属性。key path是dot符号分隔的字符串序列，用于说明横穿对象属性路径。</p>
<p>在Foundation.NSKeyValueCoding库内，实现了对NSObject、Dictionary、Array等的扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    var value : String = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = KVCClass()</span><br><span class="line">let value = instance.valueForKey(&quot;value&quot;)  // value = &quot;123&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Accessor-Method"><a href="#Accessor-Method" class="headerlink" title="Accessor Method"></a>Accessor Method</h2><p>为了使KVC能使用像valueForKey:、setValue:forkey:等方法，则必须实现KVC的访问器方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    var temp : String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    func operate() -&gt; String &#123;</span><br><span class="line">        return temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setOperate(o : String) &#123;</span><br><span class="line">        temp = o</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tem = instance.valueForKey(&quot;operate&quot;)  // tem == &quot;&quot;</span><br><span class="line">instance.setValue(&quot;newValue&quot;, forKey: &quot;operate&quot;)  // </span><br><span class="line">tem = instance.valueForKey(&quot;operate&quot;)   // tem == &quot;newValue&quot;</span><br></pre></td></tr></table></figure>
<h5 id="常用访问器模式"><a href="#常用访问器模式" class="headerlink" title="常用访问器模式"></a>常用访问器模式</h5><p>-<key>、-is<key></key></key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)hidden &#123;</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isHidden &#123;</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set<key>:</key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setHidden: (BOOL)flag &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Collection访问器模式"><a href="#Collection访问器模式" class="headerlink" title="Collection访问器模式"></a>Collection访问器模式</h4><ol>
<li>mutableArrayValueForKey</li>
<li>mutableSetValueForKey</li>
</ol>
<h5 id="Getter-Indexed"><a href="#Getter-Indexed" class="headerlink" title="Getter Indexed"></a>Getter Indexed</h5><ol>
<li>-countOf<key></key></li>
<li>-objectIn<key>AtIndex:、-<key>AtIndexes: —- NSArray…objectAtIndex:.objectsAtIndexes:</key></key></li>
<li>-get<key>:range:</key></li>
</ol>
<h5 id="Mutable-Indexed"><a href="#Mutable-Indexed" class="headerlink" title="Mutable Indexed"></a>Mutable Indexed</h5><ol>
<li>-insertObject:in<key>AtIndex:、-insert<key>:atIndexes:</key></key></li>
<li>-removeObjectFrom<key>AtIndex:、-remove<key>AtIndexes:</key></key></li>
<li>-replaceObjectIn<key>AtIndex:withObject:、-replace<key>AtIndexes:with<key>:</key></key></key></li>
</ol>
<h4 id="无序的访问器模式"><a href="#无序的访问器模式" class="headerlink" title="无序的访问器模式"></a>无序的访问器模式</h4><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><ol>
<li>-countOf<key></key></li>
<li>-enumeratorOf<key></key></li>
<li>memberOf<key></key></li>
</ol>
<h5 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h5><ol>
<li>-add<key>Object:、-add<key>:</key></key></li>
<li>-remove<key>Object:、remove<key>:</key></key></li>
<li>-intersect<key>:</key></li>
</ol>
<h2 id="Key-Value-Validation"><a href="#Key-Value-Validation" class="headerlink" title="Key-Value Validation"></a>Key-Value Validation</h2><p>KVC提供了一个统一的API对属性的值进行确认。这套确认机制给予一个类接入属性值的机会、或者用其它的值替代，再或者抛出一个错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)validate&lt;Key&gt;:(id *)ioValue error: (NSError * __autoreleasing *)outError &#123;</span><br><span class="line">	return ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateOperate:(inout id  _Nullable __autoreleasing *)ioValue error:(out NSError * _Nullable __autoreleasing *)outError &#123;</span><br><span class="line">    </span><br><span class="line">    *ioValue = @&quot;validate&quot;;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    KVCClass * instance = [[KVCClass alloc] init];</span><br><span class="line">    NSString * o = [[NSString alloc] init];</span><br><span class="line">    [instance validateValue:&amp;o forKey:@&quot;operate&quot; error:nil];</span><br><span class="line">    NSLog(@&quot;%@&quot;, o);   // 打印出 validate</span><br></pre></td></tr></table></figure>
<p>或者<br>The default implementation of this method searches the class of the receiver for a validator method whose name matches the pattern -validate<key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, YES is returned.</key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    override func validateValue(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String) throws &#123;</span><br><span class="line">        if inKey == &quot;operate&quot; &#123;</span><br><span class="line">            throw NSError(domain: &quot;KVC&quot;, code: 200, userInfo: nil)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try super.validateValue(ioValue, forKey: inKey)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var mu = UnsafeMutablePointer&lt;AnyObject?&gt;.alloc(1)</span><br><span class="line">var autoO = AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;(mu)</span><br><span class="line">do &#123;</span><br><span class="line">    try instance.validateValue(autoO, forKey: &quot;operate&quot;)</span><br><span class="line">    print(autoO.memory)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)             //  &quot;Error Domain=KVC Code=200 &quot;(null)&quot;\n&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if inKey == &quot;operate&quot; &#123;</span><br><span class="line">          ioValue.memory = &quot;validate&quot;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          try super.validateValue(ioValue, forKey: inKey)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      do &#123;</span><br><span class="line">  		try instance.validateValue(autoO, forKey: &quot;operate&quot;)</span><br><span class="line">  		print(autoO.memory)			//  &quot;validate\n&quot;</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  		print(error)      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出情况：</p>
<ol>
<li>object被确认，返回YES。</li>
<li>object不能被确认，并且没有一个可用的值可返回，则根据是否传Error设置错误，并返回NO。</li>
<li>一个新的值创建并返回，确认返回YES。</li>
</ol>
<h5 id="Automatic-Validation"><a href="#Automatic-Validation" class="headerlink" title="Automatic Validation"></a>Automatic Validation</h5><p>一般情况下KVC是不会自动招待validation，这是应用内应该做的校验责任。<br>但是像CoreData在执行保存的时候是自动validation的。</p>
<h2 id="Ensuring-KVC-Compliance"><a href="#Ensuring-KVC-Compliance" class="headerlink" title="Ensuring KVC Compliance"></a>Ensuring KVC Compliance</h2><p>为了让一个类的特定属性被认为是遵守KVC承诺的，则该类必须为了valueForKey:与setValue:forKey:能运行而实现对应的方法。</p>
<h4 id="To-One"><a href="#To-One" class="headerlink" title="To-One"></a>To-One</h4><ol>
<li>-<key>, -is<key> 或者 实例变量  <key>, _<key></key></key></key></key></li>
<li>可修改时要实现 -set<key>:</key></li>
<li>实现了-set<key>:则不能执行确认。</key></li>
<li>如果属性需要进行校验确认则需要实现 -validate<key>:error:。</key></li>
</ol>
<h4 id="Indexed-To-Many"><a href="#Indexed-To-Many" class="headerlink" title="Indexed To-Many"></a>Indexed To-Many</h4><ol>
<li>-<key> 或者 实例变量 <key>, _<key></key></key></key></li>
<li>-countOf<key>,  -objectIn<key>AtIndex:  或者  -<key>AtIndexes:</key></key></key></li>
<li>可选  -get<key>:range:</key></li>
</ol>
<p>对于可修改的：</p>
<ol>
<li>-insertObject:in<key>AtIndex: 或者  -insert<key>:atIndexes:</key></key></li>
<li>-removeObjectFrom<key>AtIndex 或者  -remove<key>AtIndexes:</key></key></li>
<li>-replaceObjectIn<key>AtIndex:withObject:  或者  -replace<key>AtIndexIndexes:with<key></key></key></key></li>
</ol>
<h4 id="Unordered-To-Many"><a href="#Unordered-To-Many" class="headerlink" title="Unordered To-Many"></a>Unordered To-Many</h4><ol>
<li>-<key> 或者 实例变量 <key> , _<key></key></key></key></li>
<li>-countOf<key>, -enumeratorOf<key> , -memberOf<key>:</key></key></key></li>
</ol>
<p>可修改：</p>
<ol>
<li>-add<key>Object: or -add<key>:</key></key></li>
<li>-remove<key>Object: or -remove<key>:</key></key></li>
<li>-interscet<key>: and -set<key>:</key></key></li>
</ol>
<h2 id="Scalar-and-Structure"><a href="#Scalar-and-Structure" class="headerlink" title="Scalar and Structure"></a>Scalar and Structure</h2><p>KVC提供对scalar值和数据结构的自动封包与解包成NSNumber 和 NSValue</p>
<h4 id="Handling-nil-Values"><a href="#Handling-nil-Values" class="headerlink" title="Handling nil Values"></a>Handling nil Values</h4><p>当nil被作为非对象值传入setValue:forKey:方法时，则receiver会调用setNilValueForKey:，而setNilValueForKey:默认实现是抛出一个NSInvalidArgumentException异常。可心在subclass里面重写指定的属性实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override func setNilValueForKey(key: String) &#123;</span><br><span class="line">    if key == &quot;age&quot; &#123;</span><br><span class="line">        self.setValue(0, forKey: key)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.setNilValueForKey(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collection-Operators"><a href="#Collection-Operators" class="headerlink" title="Collection Operators"></a>Collection Operators</h2><p>collection operators 允许在一个集合的元素上用keyPath标示符和action操作符表示执行操作。collection operators 表示作为参数传入valueForKeyPath的特定keyPath。 operator操作符 是一个@开头的特定字符串。</p>
<ol>
<li>在操作符左边的keyPath标示指向操作的集合。</li>
<li>在操作符右边的keyPath标示在集合对象内的属性路径。</li>
</ol>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/kvc_pg_figure1.jpg" alt="Operator key path format"></p>
<p>操作返回的对象值取决于操作符类型：</p>
<ol>
<li>简单的操作符返回 字符、数字、日期等。</li>
<li>对象操作符返回NSArray数组对象。</li>
<li>数组和Set操作符返回数组和set对象。</li>
</ol>
<p>source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class KVCObject : NSObject &#123;</span><br><span class="line">    var payee : String</span><br><span class="line">    var amount : Int</span><br><span class="line">    var date : NSDate</span><br><span class="line">    </span><br><span class="line">    init(p : String, a : Int, d : NSDate) &#123;</span><br><span class="line">        payee = p</span><br><span class="line">        amount = a</span><br><span class="line">        date = d</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let k0 = KVCObject(p: &quot;Green Power&quot;, a: 120, d: NSDate(timeIntervalSinceNow: 200))</span><br><span class="line">let k1 = KVCObject(p: &quot;Green Power&quot;, a: 150, d: NSDate(timeIntervalSinceNow: 300))</span><br><span class="line">let k2 = KVCObject(p: &quot;Green Power&quot;, a: 170, d: NSDate(timeIntervalSinceNow: 400))</span><br><span class="line"></span><br><span class="line">let k3 = KVCObject(p: &quot;Car Loan&quot;, a: 250, d: NSDate(timeIntervalSinceNow: 300))</span><br><span class="line">let k4 = KVCObject(p: &quot;Car Loan&quot;, a: 250, d: NSDate(timeIntervalSinceNow: 500))</span><br><span class="line"></span><br><span class="line">let transactions : NSArray = [k0, k1, k2, k3, k4]</span><br></pre></td></tr></table></figure>
<h4 id="Smiple"><a href="#Smiple" class="headerlink" title="Smiple"></a>Smiple</h4><p>######@avg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tranAvg = transactions.valueForKeyPath(&quot;@avg.amount&quot;)  // tranAvg : NSNumber  188</span><br></pre></td></tr></table></figure>
<p>#####@count<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tranCount = transactions.valueForKeyPath(&quot;@count&quot;)    // tranCount : NSNumber 5</span><br></pre></td></tr></table></figure></p>
<p>其它： @max @min  @sum  </p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h6 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a>@distinctUnionOfObjects</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let payees = transactions.valueForKeyPath(&quot;@distinctUnionOfObjects.payee&quot;)  // [&quot;Green Power&quot;, &quot;Car Loan&quot;]</span><br></pre></td></tr></table></figure>
<h6 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a>@unionOfObjects</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let payees = transactions.valueForKeyPath(&quot;@unionOfObjects.payee&quot;)  //[&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="Array-and-Set"><a href="#Array-and-Set" class="headerlink" title="Array and Set"></a>Array and Set</h4><p>@distinctUnionOfArrays  @unionOfArrays  @distinctUnionOfSets</p>
<h2 id="Accessor-Search"><a href="#Accessor-Search" class="headerlink" title="Accessor Search"></a>Accessor Search</h2><p>KVC是尝试用访问器get和set值。但是如何判定值是如何接入？</p>
<h5 id="Accessor-Search-Patterns-for-Simple-Attributes"><a href="#Accessor-Search-Patterns-for-Simple-Attributes" class="headerlink" title="Accessor Search Patterns for Simple Attributes"></a>Accessor Search Patterns for Simple Attributes</h5><p>####### setValue:forKey:</p>
<ol>
<li>搜索 set<key>:</key></li>
<li>如果没有访问器方法找到，并且类方法accessInstanceVariablesDirectly返回YES，则搜索实例变量类似_<key>,_is<key>,<key>,is<key></key></key></key></key></li>
<li>如果匹配上相应方法，则使用获得的值。如果有封解包操作的必要，则执行。</li>
<li>如果以上操作都失败，则调用setValue:forUndefinedKey:。</li>
</ol>
<h6 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey:"></a>valueForKey:</h6><ol>
<li>搜索get<key>,<key>,is<key>方法，如果找到则调用。如果有封解包操作的必要，则执行。</key></key></key></li>
<li>如果没有找到就搜索Array相关方法，countOf<key>,objectIn<key>AtIndex:等，详细方法看官方文档说明。</key></key></li>
<li>如果依然没有找到，则搜索Set的相关方法，enumeratorOf<key>,memberOf<key>等。</key></key></li>
<li><strong>如果以上操作都失败，并且类方法accessInstanceVariablesDirectly返回YES</strong>，则搜索实例变量类似_<key>,_is<key>,<key>,is<key>等，如果有封解包操作的必要，则执行。</key></key></key></key></li>
<li><strong>以上都失败，最后调用 valueForUndefinedKey:</strong>。</li>
</ol>
<p>对于 Accessor Search Pattern for Ordered Collections，Accessor Search Pattern for Uniquing Ordered Collections，Accessor Search Pattern for Unordered Collections<br>的搜索顺序，看官方文档，基本也Simple相似。</p>
<p>参考官方文档： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/08/KVC-PG/" data-id="cimszol53000di8zlawx6a6tm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-EventHandler-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/EventHandler-PG/" class="article-date">
  <time datetime="2016-04-07T06:55:15.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对事件的响应是应用的灵魂所在。</p>
<p><strong>一个事件沿着特定的路径分发到可以响应处理它的对象上</strong>，首先，UIApplication对象从事件队列顶取出一个事件分发准备处理。分发到key window对象上，window将事件赋予一个初始化对象处理。实始化对象取决于事件的类型。</p>
<ol>
<li>点击事件：对于点击事件，window先向一个发生点击事件的view分发，此view称为hit-test view。寻找view的过程称为：hit-testing。</li>
<li>Motion 和 远程 事件：window将事件发送到first responder处理。</li>
</ol>
<p>UIKit first sends the event to the object that is best suited to handle the event. For touch events, that object is the hit-test view, and for other events, that object is the first responder.</p>
<h2 id="hit-testing"><a href="#hit-testing" class="headerlink" title="hit-testing"></a>hit-testing</h2><p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_1.jpg" alt="Figure2_1"></p>
<p>如图，假设用户点击2-1上的E视图。iOS查找hit-test view检查顺序：</p>
<ol>
<li>touch事件在视图A内发生，所以检查视图B、C。</li>
<li>touch事件没有在视图B内，在而视图C内，所以检查视图D、E。</li>
<li>touch事件没有在视图D内，但在视图E内。</li>
<li>在视力层次结构里，视图E是最底层的，所以视图变成hist-test view。</li>
</ol>
<p>hitTest:withEvent:方法返回hit-test view通过 CGPoint point 和 UIEvent。hitTest:withEvent:方法首先调用自己的pointInside:withEvent:方法。如果传入hitTest:withEvent:方法的point在视图之内，则pointInside:withEvent:返回YES。然后hitTest方法在子视图上递归调用hitTest方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CustomHitTestView: UIView &#123;</span><br><span class="line">    </span><br><span class="line">    override func hitTest(point: CGPoint, withEvent event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line">        return self</span><br><span class="line">//        return super.hitTest(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func pointInside(point: CGPoint, withEvent event: UIEvent?) -&gt; Bool &#123;</span><br><span class="line">        return super.pointInside(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Regulating-the-Delivery-of-Touches-to-Views"><a href="#Regulating-the-Delivery-of-Touches-to-Views" class="headerlink" title="Regulating the Delivery of Touches to Views"></a>Regulating the Delivery of Touches to Views</h2><p>window首先将touch事件发送到任何依附于hit-test view（或者其父视图吗？）的Gesture。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/1_5.jpg" alt="Figure1_5"></p>
<p><strong>Gesture Recognizers Get the First Opportunity to Recognize a Touch</strong></p>
<p>window延迟向view分发事件，让手势识别器有机会先分析touch。在延迟期间，如果手势识别器识别到touch手势，则window不会分发touch事件到view，并且会取消之前已经分发到view上和这个识别序列有关的touch object。</p>
<h2 id="Creating-a-Custom-Gesture-Recognizer"><a href="#Creating-a-Custom-Gesture-Recognizer" class="headerlink" title="Creating a Custom Gesture Recognizer"></a>Creating a Custom Gesture Recognizer</h2><p>在自定义手势，则需要实现 UIGestureRecognizerSubclass 下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public func reset()</span><br><span class="line">public func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br></pre></td></tr></table></figure>
<p>Guide内的例子如下，不过官网上的代码有点Bug：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import UIKit.UIGestureRecognizerSubclass</span><br><span class="line"></span><br><span class="line">class CustomGestureRecognizer: UIGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    private var midPoint = CGPointZero</span><br><span class="line">    var strokeUp = false</span><br><span class="line">    </span><br><span class="line">    override func reset() &#123;</span><br><span class="line">        super.reset()</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesBegan(touches, withEvent:event)</span><br><span class="line">        </span><br><span class="line">        if touches.count != 1 &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesMoved(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state != .Failed else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let win = self.view?.window</span><br><span class="line">        let nowPoint = touches.first?.locationInView(win)</span><br><span class="line">        let prevPoint = touches.first?.previousLocationInView(win)</span><br><span class="line">        </span><br><span class="line">        guard let now = nowPoint, let prev = prevPoint where !strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if now.x &gt;= prev.x &amp;&amp; now.y &gt;= prev.y &#123;</span><br><span class="line">            midPoint = now</span><br><span class="line">        &#125; else if now.x &gt;= midPoint.x &amp;&amp; now.y &lt;= midPoint.y &#123;</span><br><span class="line">            strokeUp = true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesEnded(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state == .Possible &amp;&amp; strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        state = UIGestureRecognizerState.Recognized</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesCancelled(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">        state = .Failed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以参考这个例子 ： <a href="https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers" target="_blank" rel="external">https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers</a></p>
<p><strong>在完成hit-testing 且没有手势识别后，view作为responser开始响应</strong></p>
<h2 id="Responder-Object"><a href="#Responder-Object" class="headerlink" title="Responder Object"></a>Responder Object</h2><p>Responder Object是一个能够响应和处理事件的对象，UIResponder是所以Responder Object的基类。<br>一个对象成为First Responder需要做以下两个任务：</p>
<ol>
<li>Overriding the canBecomeFirstResponder method to return YES.</li>
<li>Receiving a becomeFirstResponder message. If necessary, an object can send itself this message.</li>
</ol>
<h2 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h2><p>定义：The responder chain is a series of linked responder objects. It starts with the first responder and ends with the application object.</p>
<p>作用：If the first responder cannot handle an event, it forwards the event to the next responder in the responder chain.</p>
<p>响应链用于收下事件：</p>
<ol>
<li>点击事件，事件响应开始于 hit-test view。</li>
<li>Motion：要处理shake-motion事件，第一响应者需要实现UIResponder下motionBegan:withEvent: or motionEnded:withEvent:方法。</li>
<li>Remote：要处理remote事件，第一响应者必须实现UIResponder的 remoteControlReceivedWithEvent:  方法。</li>
<li>Action Message：当操作一个Control，当添加Target并设置为nil时，这个message将沿着responder chain传递。</li>
<li>Editing-menu Message。</li>
<li>Text editing。</li>
</ol>
<h2 id="Responder-Chain-delivery-Path"><a href="#Responder-Chain-delivery-Path" class="headerlink" title="Responder Chain delivery Path"></a>Responder Chain delivery Path</h2><p>如果initial对象（hit-test view 或者 first Responder）不能处理事件，则将事件通过next Responder沿着Chain传递。每个Responder决定是否处理这个事件，或者沿着Chain继续传递下去。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_2.jpg" alt="Figure2_2"></p>
<p>参考官方文档链接：<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/EventHandler-PG/" data-id="cimszol4q0003i8zl2v0oadzp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OC-运行时概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/OC-运行时概记/" class="article-date">
  <time datetime="2016-04-06T12:29:15.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>必然时间太久还是会忘，还是记一下吧。</p>
<p>Guide中对runtime解释：The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
<p>OC将决议从编译时延迟到运行时，作为动态运行。这意味着不但需要编译器，同时还需要一个运行时系统来执行编译代码。这个运行时系统为OC充当一个操作系统，使其能够运行。</p>
<h3 id="Interact"><a href="#Interact" class="headerlink" title="Interact"></a>Interact</h3><ol>
<li>通过源码实现功能，编译后动态运行。</li>
<li>通过NSObject 提供的部分查询method，如methodForSelector: \ respondsToSelector:等。</li>
<li>通过runtime functions。</li>
</ol>
<p>OC定义Class结构，在/objc/runtime.h中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>表示一个实例对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看几个重要的定义：<br>OC版本源文件内定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">struct objc_method_description &#123;</span><br><span class="line">	SEL name;               /**&lt; The name of the method */</span><br><span class="line">	char *types;            /**&lt; The types of the method arguments */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>在Swift库中已经预留出和OC版源文件相同的头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import ObjectiveC.List</span><br><span class="line">import ObjectiveC.NSObjCRuntime</span><br><span class="line">import ObjectiveC.NSObject</span><br><span class="line">import ObjectiveC.Object</span><br><span class="line">import ObjectiveC.Protocol</span><br><span class="line">import ObjectiveC.message</span><br><span class="line">import ObjectiveC.objc</span><br><span class="line">import ObjectiveC.objc_api</span><br><span class="line">import ObjectiveC.objc_auto</span><br><span class="line">import ObjectiveC.objc_class</span><br><span class="line">import ObjectiveC.objc_exception</span><br><span class="line">import ObjectiveC.objc_load</span><br><span class="line">import ObjectiveC.objc_runtime</span><br><span class="line">import ObjectiveC.objc_sync</span><br><span class="line">import ObjectiveC.runtime</span><br></pre></td></tr></table></figure>
<p>在Apple开源的Foundation project内有如此说明：</p>
<p><strong>Runtime: The basis for interoperability.</strong></p>
<p>The classes and methods in this group provide an interface for interoperability between C code and Swift. They also provide common layers used throughout the framework such as the root class NSObject.</p>
<ol>
<li>NSObject is mostly implemented.</li>
<li>NSEnumerator is fully implemented.</li>
<li>NSSwiftRuntime (internal use only) contains Swift runtime-specific functionality.</li>
<li>NSObjCRuntime is missing some key parts such as NSClassFromString. Much of the functionality here is specific to the Objective-C runtime and is not relevant when building for Swift.</li>
</ol>
<p>Swift库ObjectiveC.runtime内定义，对runtime用Swift语法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">public typealias Method = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">public typealias Ivar = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">public typealias Category = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">public typealias objc_property_t = COpaquePointer</span><br><span class="line"></span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">public struct objc_method_description &#123;</span><br><span class="line">    /**&lt; The name of the method */</span><br><span class="line">    public var name: Selector</span><br><span class="line">    /**&lt; The types of the method arguments */</span><br><span class="line">    public var types: UnsafeMutablePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: Selector, types: UnsafeMutablePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">public struct objc_property_attribute_t &#123;</span><br><span class="line">    /**&lt; The name of the attribute */</span><br><span class="line">    public var name: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">    public var value: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: UnsafePointer&lt;Int8&gt;, value: UnsafePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Method 表示方法，分成Selector 和 IMP 部分。</li>
<li>Ivar 表示实例对象的变量。</li>
<li>Category 表示OC范筹。</li>
<li>objc_property_t 表示属性。</li>
</ol>
<h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h3><ol>
<li>将语法 [receiver message] 翻译成 objc_msgSend(receiver, selector)。</li>
<li>在objc_cache中查找方法。</li>
<li>如果在cache中没找到，则在 objc_method_list 里查找， 如果找到则 缓存。</li>
<li>如果在 objc_method_list 里没找到，则在指向父类查找。</li>
</ol>
<h3 id="Dynamic加载"><a href="#Dynamic加载" class="headerlink" title="Dynamic加载"></a>Dynamic加载</h3><h6 id="Dynamic-Method-Resolution"><a href="#Dynamic-Method-Resolution" class="headerlink" title="Dynamic Method Resolution"></a>Dynamic Method Resolution</h6><p>定义一个Class 未实现 objectSend方法，动态用 resolveObjectSend方法替换实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)resolveObjectSend &#123;</span><br><span class="line">    NSLog(@&quot;resolve message send ....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    if (sel == @selector(objectSend)) &#123;</span><br><span class="line">        IMP res = class_getMethodImplementation([self class], @selector(resolveObjectSend));</span><br><span class="line">        BOOL result = class_addMethod([self class], sel, res, &quot;v@:&quot;);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            NSLog(@&quot;method added ....&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否为 objectSend 消息。</li>
<li>用运行时方法取出 resolveObjectSend 方法 对应的实现。</li>
<li>增加方法，用 resolveObjectSend 的实现 作为 objectSend 的实现。</li>
</ol>
<p>对于实例方法或者类方法没有实现的，可以用 resolveInstanceMethod 或者 resolveClassMethod 动态添加实现。</p>
<h3 id="消息转发-Message-Forwarding"><a href="#消息转发-Message-Forwarding" class="headerlink" title="消息转发 Message Forwarding"></a>消息转发 Message Forwarding</h3><p>在发送一个消息对对象后，如果对象不能处理消息，则会产生运行时错误，在抛出这个错误之前runtime会用forwardInvocation再进行一次处理 — 称为消息转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void) forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([anInvocation selector] == @selector(objectSend)) &#123;</span><br><span class="line">        anInvocation.selector = @selector(resolveObjectSend);</span><br><span class="line">        [anInvocation invokeWithTarget:another];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature * signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        signature = [another methodSignatureForSelector:@selector(resolveObjectSend)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时func使用"><a href="#运行时func使用" class="headerlink" title="运行时func使用"></a>运行时func使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">    var pro : NSArray = [1, 2]</span><br><span class="line">    var pro1 : NSString = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObject = MyClass()</span><br><span class="line">myObject.pro = [2, 3]</span><br><span class="line"></span><br><span class="line">let proName : String = &quot;pro&quot;</span><br><span class="line">let iii : [CChar]? = proName.cStringUsingEncoding(NSUTF8StringEncoding)</span><br><span class="line">let iva : Ivar = class_getInstanceVariable(MyClass.self, iii!)</span><br><span class="line">let valueForIva = object_getIvar(myObject, iva)  // [2, 3]</span><br><span class="line"></span><br><span class="line">var count : UInt32 = 0</span><br><span class="line">let list = class_copyIvarList(MyClass.self, &amp;count)</span><br><span class="line"></span><br><span class="line">for i in 0..&lt;Int(count) &#123;</span><br><span class="line">    let name = ivar_getName(list[i])</span><br><span class="line">    print(String(UTF8String: name))  // Optional(&quot;pro&quot;)   // Optional(&quot;pro1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let my = MyClass()</span><br><span class="line">object_getIvar(my, list[1])   // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">list.dealloc(2)</span><br></pre></td></tr></table></figure>
<p>参考官方文档地址： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/OC-运行时概记/" data-id="cimszol5h000pi8zl7wceqc9a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-责任链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/责任链/" class="article-date">
  <time datetime="2016-04-06T07:24:25.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/责任链/">责任链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//职责链是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。<br>//将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>//对象本身要经过什么处理是通过每个链上元素通过运行态来决定的，决定的因素是取决于对象的属性或者一些其他方面的策略。<br>//用户无论是从哪一个节点作为他的请求头节点，最终用户都可以得到一个请求的反馈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">struct LeaveRequest &#123;</span><br><span class="line">    var id : Int</span><br><span class="line">    var day : Float</span><br><span class="line">    var reason : String</span><br><span class="line">    </span><br><span class="line">    func checkReason() &#123;</span><br><span class="line">        print(reason)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol LeaveHandler &#123;</span><br><span class="line">    var nextLevel : LeaveHandler? &#123;get set&#125;</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request : LeaveRequest) -&gt; Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension LeaveHandler &#123;</span><br><span class="line">    mutating func setNextLevel(next : LeaveHandler) &#123;</span><br><span class="line">        self.nextLevel = next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func nextLevelHandler(request : LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if let next = nextLevel &#123;</span><br><span class="line">            return next.handlerLeaveRequest(request)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request : LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        return nextLevelHandler(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Boss : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 4 &lt; request.day &amp;&amp; request.day &lt; 7 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;No Rule ...&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct HR : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 2 &lt; request.day &amp;&amp; request.day &lt;= 4 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            </span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PM : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 1 &lt; request.day &amp;&amp; request.day &lt;= 2 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Leader : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if request.day &lt;= 1 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let boss = Boss(name: &quot;Boss&quot;, nextLevel: nil)</span><br><span class="line">let hr = HR(name: &quot;HR&quot;, nextLevel: boss)</span><br><span class="line">let pm = PM(name: &quot;PM&quot;, nextLevel: hr)</span><br><span class="line">let leader = Leader(name: &quot;leader&quot;, nextLevel: pm)</span><br><span class="line"></span><br><span class="line">let leaveRequest = LeaveRequest(id: 1, day: 3, reason: &quot;个人原因&quot;)</span><br><span class="line">leader.handlerLeaveRequest(leaveRequest)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/责任链/" data-id="cimszol6k001fi8zlmfdtacz7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Unicode-UFT8-概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/Unicode-UFT8-概记/" class="article-date">
  <time datetime="2016-04-05T11:32:24.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/Unicode-UFT8-概记/">Unicode_UFT8_概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p>
<p>Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。</p>
<p>Unicode计划使用了17个平面，一共有17×65536=1114112个码位。在Unicode 5.0.0版本中，已定义的码位只有238605个，分布在平面0、平面1、平面2、平面14、平面15、平面16。其中平面15和平面16上只是定义了两个各占65534个码位的专用区（Private Use Area），分别是0xF0000-0xFFFFD和0x100000-0x10FFFD。所谓专用区，就是保留给大家放自定义字符的区域，可以简写为PUA。</p>
<p>平面0也有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。</p>
<p>如前所述在Unicode 5.0.0版本中，238605-65534*2-6400-2048=99089。余下的99089个已定义码位分布在平面0、平面1、平面2和平面14上，它们对应着Unicode定义的99089个字符，其中包括71226个汉字。平面0、平面1、平面2和平面14上分别定义了52080、3419、43253和337个字符。平面2的43253个字符都是汉字。平面0上定义了27973个汉字。</p>
<p>在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：UTF-8、UTF-16、UTF-32。<strong><em>UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。</em></strong><br>例如，“汉字”对应的数字是0x6c49和0x5b57，而编码的程序数据是：</p>
<p>| | | |<br>|<br>|1 | char  |    data_utf8[]={0xE6,0xB1,0x89,0xE5,0xAD,0x97};//UTF-8编码|<br>|2 | char16_t |  data_utf16[]={0x6C49,0x5B57};        //UTF-16编码|<br>|3 | char32_t |  data_utf32[]={0x00006C49,0x00005B57};//UTF-32编码|</p>
<p><strong><em>UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式</em></strong></p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：</p>
<p>|Unicode编码(十六进制)　|UTF-8 字节流(二进制)|<br>|<br>|00000000 - 0000007F | 0xxxxxxx |<br>|00000080 - 000007FF | 110xxxxx 10xxxxxx |<br>|00000800 - 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |<br>|00010000 - 001FFFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>|00200000 - 03FFFFFF |    111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>|04000000 - 7FFFFFFF |    1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |</p>
<p>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是6个字节。从上表可以看出，6字节模板有31个x，即可以容纳31位二进制数字。Unicode的最大码位0x7FFFFFFF也只有31位。</p>
<h6 id="例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx-10xxxxxx-10xxxxxx。将0x6C49写成二进制是：0110-1100-0100-1001，-用这个比特流依次代替模板中的x，得到：11100110-10110001-10001001，即E6-B1-89。"><a href="#例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx-10xxxxxx-10xxxxxx。将0x6C49写成二进制是：0110-1100-0100-1001，-用这个比特流依次代替模板中的x，得到：11100110-10110001-10001001，即E6-B1-89。" class="headerlink" title="例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。"></a>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</h6><h6 id="例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx-10xxxxxx-10xxxxxx-10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0-0010-0000-1100-0011-0000，用这个比特流依次代替模板中的x，得到：11110000-10100000-10110000-10110000，即F0-A0-B0-B0。"><a href="#例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx-10xxxxxx-10xxxxxx-10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0-0010-0000-1100-0011-0000，用这个比特流依次代替模板中的x，得到：11110000-10100000-10110000-10110000，即F0-A0-B0-B0。" class="headerlink" title="例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。"></a>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。</h6><h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16编码以16位无符号整数为单位。我们把Unicode<br>unicode<br>unicode<br>编码记作U。编码规则如下：<br>如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。<br>如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。</p>
<p>百度链接 ： <a href="http://baike.baidu.com/link?url=Knk24RC6XBNUrL6Rd6oMkiJvB5ZPut2fNasaco1BoKCwgPj254kWmXc-JizuydvO7MLJmLknsygroeOyCjOsb_" target="_blank" rel="external">http://baike.baidu.com/link?url=Knk24RC6XBNUrL6Rd6oMkiJvB5ZPut2fNasaco1BoKCwgPj254kWmXc-JizuydvO7MLJmLknsygroeOyCjOsb_</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/Unicode-UFT8-概记/" data-id="cimszol5w0014i8zlnnsx7zuc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/">Other</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Revel-Filter-Chain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/04/Revel-Filter-Chain/" class="article-date">
  <time datetime="2016-04-04T14:09:20.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/Revel-Filter-Chain/">Revel Filter Chain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前有提到在启用服务后，在Handle回调内处理请求会调用 <code>Filters[0](c, Filters[1:])</code>。<br>关于Filter整个处理涉及到知识点过多，对于不太理解的地方待以后慢慢补充。。。。</p>
<h2 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h2><p>在filter.go文件内定义了官方标准Filter chain的11个Filter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Filters = []Filter&#123;</span><br><span class="line">	PanicFilter,             // Recover from panics and display an error page instead.</span><br><span class="line">	RouterFilter,            // Use the routing table to select the right Action.</span><br><span class="line">	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.</span><br><span class="line">	ParamsFilter,            // Parse parameters into Controller.Params.</span><br><span class="line">	SessionFilter,           // Restore and write the session cookie.</span><br><span class="line">	FlashFilter,             // Restore and write the flash cookie.</span><br><span class="line">	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.</span><br><span class="line">	I18nFilter,              // Resolve the requested language.</span><br><span class="line">	InterceptorFilter,       // Run interceptors around the action.</span><br><span class="line">	CompressFilter,          // Compress the result.</span><br><span class="line">	ActionInvoker,           // Invoke the action.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PanicFilter"><a href="#PanicFilter" class="headerlink" title="PanicFilter"></a>PanicFilter</h4><p>在panic.go内，这个Filter定义的功能相对简单，定义一个defer func等待处理 Package builtin 的 panic 调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func PanicFilter(c *Controller, fc []Filter) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err := recover(); err != nil &#123;</span><br><span class="line">			handleInvocationPanic(c, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fc[0](c, fc[1:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在整个Chain内有错误发生，则抓取错误信息作为c.Result渲染。</p>
<h4 id="RouterFilter"><a href="#RouterFilter" class="headerlink" title="RouterFilter"></a>RouterFilter</h4><p>在router.go内，从MainRouter 根据Request 找出路由信息：</p>
<ol>
<li>判定路由如果不存在，则渲染 NotFound 错误。</li>
<li>判定route 的Action 如果是404，则渲染 NotFound 错误。</li>
<li>如果给Controller 设置 Action 出现错误， 则渲染 NotFound 错误。</li>
</ol>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Add the route and fixed params to the Request Params.</span><br><span class="line">c.Params.Route = route.Params</span><br><span class="line"></span><br><span class="line">// Add the fixed parameters mapped by name.</span><br><span class="line">// TODO: Pre-calculate this mapping.</span><br><span class="line">for i, value := range route.FixedParams &#123;</span><br><span class="line">	if c.Params.Fixed == nil &#123;</span><br><span class="line">		c.Params.Fixed = make(url.Values)</span><br><span class="line">	&#125;</span><br><span class="line">	if i &lt; len(c.MethodType.Args) &#123;</span><br><span class="line">		arg := c.MethodType.Args[i]</span><br><span class="line">		c.Params.Fixed.Set(arg.Name, value)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		WARN.Println(&quot;Too many parameters to&quot;, route.Action, &quot;trying to add&quot;, value)</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fc[0](c, fc[1:])</span><br></pre></td></tr></table></figure>
<ol>
<li><code>c.Params.Route = route.Params</code>， 类似REST声明的参数赋值给 Params.Route（Route url.Values // Parameters extracted from the route,  e.g. /customers/{id}）</li>
<li>在配置Router里可以设置固定参数，现在将固定参数赋值给 Params.Fixed (Fixed url.Values // Fixed parameters from the route, e.g. App.Action(“fixed param”))</li>
</ol>
<h4 id="FilterConfiguringFilter"><a href="#FilterConfiguringFilter" class="headerlink" title="FilterConfiguringFilter"></a>FilterConfiguringFilter</h4><p>filterconfig.go是针对Controller.Action定制Filter 的地方，并声明一个 <code>var filterOverrides = make(map[string][]Filter)</code> 管理定制的Filter Chain。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Note: the last filter stage is not subject to the configurator.  In</span><br><span class="line">// particular, Add() adds a filter to the second-to-last place.</span><br><span class="line">type FilterConfigurator struct &#123;</span><br><span class="line">	key            string // e.g. &quot;App&quot;, &quot;App.Action&quot;</span><br><span class="line">	controllerName string // e.g. &quot;App&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了3个生成 FilterConfigurator 的方法：</p>
<ol>
<li><code>func newFilterConfigurator(controllerName, methodName string) FilterConfigurator</code></li>
<li><code>func FilterController(controllerInstance interface{}) FilterConfigurator</code></li>
<li><code>func FilterAction(methodRef interface{}) FilterConfigurator</code></li>
</ol>
<p>再定义如Add、Remove等操作方法。</p>
<h6 id="FilterConfiguringFilter-操作"><a href="#FilterConfiguringFilter-操作" class="headerlink" title="FilterConfiguringFilter 操作"></a>FilterConfiguringFilter 操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// FilterConfiguringFilter is a filter stage that customizes the remaining</span><br><span class="line">// filter chain for the action being invoked.</span><br><span class="line">func FilterConfiguringFilter(c *Controller, fc []Filter) &#123;</span><br><span class="line">	if newChain := getOverrideChain(c.Name, c.Action); newChain != nil &#123;</span><br><span class="line">		newChain[0](c, newChain[1:])</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	fc[0](c, fc[1:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// getOverrideChain retrieves the overrides for the action that is set</span><br><span class="line">func getOverrideChain(controllerName, action string) []Filter &#123;</span><br><span class="line">	if newChain, ok := filterOverrides[action]; ok &#123;</span><br><span class="line">		return newChain</span><br><span class="line">	&#125;</span><br><span class="line">	if newChain, ok := filterOverrides[controllerName]; ok &#123;</span><br><span class="line">		return newChain</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否有定制的Filter Chain，如果有则接着定制的Filter Chain走。</li>
<li>判定如果没有 则继续 正常的Filter Chain。</li>
</ol>
<h2 id="ParamsFilter"><a href="#ParamsFilter" class="headerlink" title="ParamsFilter"></a>ParamsFilter</h2><p>这个很直接，为了解析请求参数，这个Filter内定义了三个功能步骤：<br>第一步，解析参数：</p>
<ol>
<li><code>params.Query = req.URL.Query()</code>， 设置查询参数 （Query url.Values // Parameters from the query string, e.g. /index?limit=10）</li>
<li>如果是application/x-www-form-urlencoded，解析Form参数，<code>params.Form = req.Form</code>， （Form  url.Values // Parameters from the request body.）</li>
<li>如果是multipart/form-data，解析Form信息，设置 (Form  url.Values // Parameters from the request body.)、（Files    map[string][]*multipart.FileHeader // Files uploaded in a multipart form）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params.Form = req.MultipartForm.Value</span><br><span class="line">params.Files = req.MultipartForm.File</span><br></pre></td></tr></table></figure>
<p>第二步，定义defer func，负责在最后的Filter Chain调用完成后清理 请求参数。<br>第三步，继续Filter Chain。</p>
<h2 id="SessionFilter"><a href="#SessionFilter" class="headerlink" title="SessionFilter"></a>SessionFilter</h2><p>在session.go里，主要功能是配置 和 保存 session，关于session的管理未记录。</p>
<ol>
<li><code>c.Session = restoreSession(c.Request.Request)</code>，恢复一个session（如果有则直接取出，没有则重新初始化一个session）</li>
<li><code>c.RenderArgs[&quot;session&quot;] = c.Session</code>，设置render参数session。</li>
<li>继续执行Filster Chain.</li>
<li>执行完后续Filter Chain后，判定是否存在session，设置Cookie。</li>
</ol>
<h2 id="FlashFilter"><a href="#FlashFilter" class="headerlink" title="FlashFilter"></a>FlashFilter</h2><p>在flash.go里，主要功能是配置 和 保存 flash cookie信息。<br>说来比较惭愧，关于Flash Cookie这个名字还真是第一次听说。</p>
<p>同Http Cookie一样，Flash Cookie也就是记录用户在访问Flash网页的时候保留的信息，鉴于Flash技术的普遍性，几乎所有的网站都采用，所以具有同Http Cookie一样的作用。但是相比起Http Cookie，Flash Cookie更加强大：1、容量更大，Flash Cookie可以容纳最多100千字节的数据，而一个标准的HTTP Cookie只有4千字节;2、FlashCookie没有默认的过期时间;3、FlashCookie将被存储在不同的地点，这使得它们很难被找到。而在10.3版本之前，几乎没有简单删除Flash Cookie的办法。</p>
<ol>
<li><code>c.Flash = restoreFlash(c.Request.Request)</code>，恢复一个 flash。</li>
<li><code>c.RenderArgs[&quot;flash&quot;] = c.Flash.Data</code>，设置render参数flash。</li>
<li>继续执行Filster Chain。</li>
<li>在执行完Filster Chain后，拼接flashValue值。</li>
<li>最后用flashValue生成http.Cookie，给controller设置Cookie。</li>
</ol>
<h2 id="ValidationFilter"><a href="#ValidationFilter" class="headerlink" title="ValidationFilter"></a>ValidationFilter</h2><p>在validation.go里， 这个文件定义了检验常规内容的func功能，并会保存成 ValidationError。</p>
<ol>
<li>恢复Cookie对应的Error信息。</li>
<li>为controller赋值一个Validation。</li>
<li><code>hasCookie := (err != http.ErrNoCookie)</code>，判定是否存在Error Cookie。</li>
<li>继续执行Filter Chain。</li>
<li>执行完Filter Chain后，<code>c.RenderArgs[&quot;errors&quot;] = c.Validation.ErrorMap()</code>，设置render校验错误参数errors。</li>
<li>拼接错误信息，给controller将错误信息设置成错误Cookie信息。</li>
</ol>
<h2 id="I18nFilter"><a href="#I18nFilter" class="headerlink" title="I18nFilter"></a>I18nFilter</h2><p>在i18n.go里，处理国际化相关内容，具体应用待研究。</p>
<ol>
<li><code>hasLocaleCookie(c.Request)</code>，判定是否存在Cookie设置本地化信息，如果有则以此为准。</li>
<li>cookie不成功后，<code>hasAcceptLanguageHeader(c.Request)</code>，判定是否存在接收语言设置本地化。</li>
<li>如果以上都不存在的情况下，则设置为空。</li>
<li>继续执行Filter Chain。</li>
</ol>
<h2 id="InterceptorFilter"><a href="#InterceptorFilter" class="headerlink" title="InterceptorFilter"></a>InterceptorFilter</h2><p>在intercept.go里，主要功能是采用AOP思维，插入操作功能。</p>
<p>添加方式：revel.InterceptMethod((*FoodController).Before, revel.BEFORE)</p>
<ol>
<li>针对controller查找嵌入的BEFORE功能点，并执行。</li>
<li>嵌入BEFORE后，Result是否为空，不为空就结束。</li>
<li>继续执行Filter Chain。</li>
<li>完成后，针对controller查找嵌入的AFTER的功能点，并执行。</li>
<li>采用defer 判定是否存在 panic嵌入功能点，如果存在则执行。</li>
<li>采用defer，针对controller查找嵌入的FINALLY的功能点，并执行。</li>
</ol>
<h2 id="CompressFilter"><a href="#CompressFilter" class="headerlink" title="CompressFilter"></a>CompressFilter</h2><p>在compress.go里，主要处理HTTP响应需要的格式信息。</p>
<ol>
<li>执行后续的Filter Chain。</li>
<li>后续功能完成后，执行响应数据封装—-需要研究下，这里对HTTP响应的处理工作。</li>
</ol>
<h2 id="ActionInvoker"><a href="#ActionInvoker" class="headerlink" title="ActionInvoker"></a>ActionInvoker</h2><p>在invoker.go里，完成controller的调用工作。</p>
<ol>
<li>根据reflect得到method。</li>
<li>组装获取请求参数。</li>
<li>调用得到Result。</li>
</ol>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>也可以自定义Filter，追加到合适的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var HeaderFilter = func(c *revel.Controller, fc []revel.Filter) &#123;</span><br><span class="line">	// Add some common security headers</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;)</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;)</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;)</span><br><span class="line"></span><br><span class="line">	fc[0](c, fc[1:]) // Execute the next filter stage.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/04/Revel-Filter-Chain/" data-id="cimszol5l000ui8zldzys8rui" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/AOP/" class="article-date">
  <time datetime="2016-04-03T13:08:18.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/AOP/">AOP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Wiki上对AOP解释，<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming：" target="_blank" rel="external">https://en.wikipedia.org/wiki/Aspect-oriented_programming：</a></p>
<p>In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a “pointcut” specification, such as “log all function calls when the function’s name begins with ‘set’”. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code core to the functionality. AOP forms a basis for aspect-oriented software development.</p>
<p>在不修改现有代码的基础之上，通过一个切入点添加特定的行为且不会影响原有的逻辑，例如当全部func开始调用的时候打印日志。</p>
<h2 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h2><h4 id="class-func-load"><a href="#class-func-load" class="headerlink" title="class func load"></a>class func load</h4><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
<p>In addition:</p>
<p>A class’s +load method is called after all of its superclasses’ +load methods.</p>
<p>A category +load method is called after the class’s own +load method.</p>
<p>Swift Class不允许overrid load方法，重写时会报错：Method ‘load()’ defines Objective-C class method ‘load’, which is not permitted by Swift.</p>
<h4 id="class-func-initialize"><a href="#class-func-initialize" class="headerlink" title="class func initialize"></a>class func initialize</h4><p>Initializes the class before it receives its first message.</p>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self == [ClassName self]) &#123;</span><br><span class="line">    // ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
<ol>
<li>initialize在接收到第一条消息以前调用。</li>
<li>initialize方法调用是线程安全的。</li>
<li>父类先于子类调用；父类可能会被调用多次，当子类未实现该方法或者子类明确调用[super initialize]。</li>
<li>想确保代码只被执行一次，可用 self == [ClassName self] 判定。</li>
<li>因为是线程安全，不能保证执行顺序，不应该做过多的任务。</li>
</ol>
<h2 id="Requiring-Dynamic-Dispatch"><a href="#Requiring-Dynamic-Dispatch" class="headerlink" title="Requiring Dynamic Dispatch"></a>Requiring Dynamic Dispatch</h2><p>在Swift Interacting with Object-C 中，<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57：" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57：</a></p>
<p>When Swift APIs are imported by the Objective-C runtime, there are no guarantees of dynamic dispatch for properties, methods, subscripts, or initializers. The Swift compiler may still devirtualize or inline member access to optimize the performance of your code, bypassing the Objective-C runtime.</p>
<p>You can use the dynamic modifier to require that access to members be dynamically dispatched through the Objective-C runtime. Requiring dynamic dispatch is rarely necessary. However, it is necessary when using using APIs like key–value observing or the method_exchangeImplementations function in the Objective-C runtime, which dynamically replace the implementation of a method at runtime. If the Swift compiler inlined the implementation of the method or devirtualized access to it, the new implementation would not be used.</p>
<ol>
<li>Swift API 是通过 Ojbect-C 运行时导入，由于Swift编译会绕过OC运行时进行 性能优化，不能保证 properties, methods, subscripts等的动态分发。</li>
<li>设置 dynamic modifier ，实现如KVC 、 method_exchangeImplementations 等功能。</li>
</ol>
<h2 id="OC-Swift-AOP"><a href="#OC-Swift-AOP" class="headerlink" title="OC/Swift AOP"></a>OC/Swift AOP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">extension UIViewController &#123;</span><br><span class="line">    public override class func initialize() &#123;</span><br><span class="line">        super.initialize()</span><br><span class="line">        </span><br><span class="line">        struct Static &#123;</span><br><span class="line">            static var token: dispatch_once_t = 0</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //make sure this isn&apos;t a subclass</span><br><span class="line">        if self !== UIViewController.self &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_once(&amp;Static.token) &#123; () -&gt; Void in</span><br><span class="line">            let originalSelector = Selector(&quot;viewDidAppear:&quot;)</span><br><span class="line">            let swizzleSelector = Selector(&quot;nsh_ViewDidAppear:&quot;)</span><br><span class="line">            </span><br><span class="line">            let originalMethod = class_getInstanceMethod(self, originalSelector)</span><br><span class="line">            let swizzleMethod = class_getInstanceMethod(self, swizzleSelector)</span><br><span class="line">            </span><br><span class="line">            let didAddMethod = class_addMethod(self, originalSelector, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod))</span><br><span class="line">            </span><br><span class="line">            if didAddMethod &#123;</span><br><span class="line">                class_replaceMethod(self, swizzleSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                method_exchangeImplementations(originalMethod, swizzleMethod)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dynamic func nsh_ViewDidAppear(animated: Bool) &#123;</span><br><span class="line">        self.nsh_ViewDidAppear(animated)</span><br><span class="line">        print(&quot;viewDidAppear: \(self.description)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Method 分成两 Selector 和 IMP 两部分。</li>
<li>当方法实现部分交换后， 用 self.nsh_ViewDidAppear(animated) 调用指向的是 之前的 ViewDidAppear 实现地址。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/AOP/" data-id="cimszol4k0001i8zlht944u07" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-策略模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/策略模式/" class="article-date">
  <time datetime="2016-04-03T05:41:10.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/策略模式/">策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Pattern-Strategy"><a href="#Pattern-Strategy" class="headerlink" title="Pattern: Strategy"></a>Pattern: Strategy</h3><p>//设计原则一：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
<p>//设计原则二：针对接口编程，而不是针对实现编程。</p>
<p>//设计原则三：多用组合，少用继承</p>
<p>//策略模式：定义算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protocol FlyBehavior &#123;</span><br><span class="line">    func fly() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol QuackBehavior &#123;</span><br><span class="line">    func quack() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct BehaviorFly : FlyBehavior &#123;</span><br><span class="line">    func fly() -&gt; String &#123;</span><br><span class="line">        return &quot;I&apos;m flying!!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct CantFly : FlyBehavior &#123;</span><br><span class="line">    func fly() -&gt; String &#123;</span><br><span class="line">        return &quot;I can&apos;t fly&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Quack : QuackBehavior &#123;</span><br><span class="line">    func quack() -&gt; String &#123;</span><br><span class="line">        return &quot;Quack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MuteQuack : QuackBehavior &#123;</span><br><span class="line">    func quack() -&gt; String &#123;</span><br><span class="line">        return &quot;Silence&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Duck &#123;</span><br><span class="line">    var fly : FlyBehavior</span><br><span class="line">    var quack : QuackBehavior</span><br><span class="line">    </span><br><span class="line">    func performFly() -&gt; String &#123;</span><br><span class="line">        return fly.fly()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func performQuack() -&gt; String &#123;</span><br><span class="line">        return quack.quack()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use</span><br><span class="line">let cantFly = CantFly()</span><br><span class="line">let muteQuack = MuteQuack()</span><br><span class="line">let duck1 = Duck(fly: cantFly, quack: muteQuack)</span><br><span class="line">duck1.performFly()</span><br><span class="line">duck1.performQuack()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/策略模式/" data-id="cimszol6j001ei8zl42lkgrzp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-错误处理-railway-oriented-programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/错误处理-railway-oriented-programming/" class="article-date">
  <time datetime="2016-04-03T03:08:51.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/错误处理-railway-oriented-programming/">错误处理-railway oriented programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>在Swift 2中，增加了Error Handler，让处理错误异常有了新的方式</strong></p>
<p>关于《Swift 2 throws 全解析 - 从原理到实践》一文对throws进行了详细描述。网站地址：<a href="http://www.ibm.com/developerworks/cn/mobile/mo-cn-swift/index.html，作者：王巍" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/mobile/mo-cn-swift/index.html，作者：王巍</a> (@onevcat)</p>
<p>Scott Wlaschin 的 Railway Oriented Programming — error handling in functional languages 视频讲述了轨道编程，地址：<a href="https://vimeo.com/97344498" target="_blank" rel="external">https://vimeo.com/97344498</a></p>
<p>这里记录一下自己 结合Swift 2 Error Handler 采用 面向轨道-错误处理 运用。</p>
<h2 id="直接抛出"><a href="#直接抛出" class="headerlink" title="直接抛出"></a>直接抛出</h2><p>直接处理方式，有错误直接抛出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum ThrowError : ErrorType &#123;</span><br><span class="line">    case ThrowError1</span><br><span class="line">    case ThrowError2</span><br><span class="line">    case ThrowError3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func handlerFlow(data : Int) throws -&gt; Int &#123;</span><br><span class="line">    let data1 = data + 5</span><br><span class="line">    guard data1 &gt; 10 else &#123;</span><br><span class="line">        throw ThrowError.ThrowError1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let data2 = data1 + 5</span><br><span class="line">    guard data2 &lt; 20 else &#123;</span><br><span class="line">        throw ThrowError.ThrowError2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let data3 = data2 + 3</span><br><span class="line">    guard data3 &gt; 20 else &#123;</span><br><span class="line">        throw ThrowError.ThrowError3</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return data3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>参考系统库Optional：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T&gt; &#123;</span><br><span class="line">    case Success(T)</span><br><span class="line">    case Failure(ErrorType)</span><br><span class="line"></span><br><span class="line">    init(start : T) &#123;</span><br><span class="line">        self = .Success(start)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func flatMap&lt;U&gt;(trans : T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Success(let value):</span><br><span class="line">            return trans(value)</span><br><span class="line">        case .Failure(let err):</span><br><span class="line">            return .Failure(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func map&lt;U&gt;(trans : ((T) throws -&gt; U)) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Success(let value):</span><br><span class="line">            do &#123;</span><br><span class="line">                let value : U = try trans(value)</span><br><span class="line">                return .Success(value)</span><br><span class="line">            &#125; catch &#123;</span><br><span class="line">                return .Failure(error)</span><br><span class="line">            &#125;</span><br><span class="line">        case .Failure(let err):</span><br><span class="line">            return .Failure(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func finish() throws -&gt; T &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Success(let value):</span><br><span class="line">            return value</span><br><span class="line">        case .Failure(let err):</span><br><span class="line">            throw err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-chain-传递"><a href="#Error-chain-传递" class="headerlink" title="Error chain 传递"></a>Error chain 传递</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func handlerFlow(data : Int) throws -&gt; Int &#123;</span><br><span class="line">    func throw1(data : Int) throws -&gt; Int &#123;</span><br><span class="line">        let res = data + 5</span><br><span class="line">        guard res &gt; 10 else &#123;</span><br><span class="line">            throw ThrowError.ThrowError1</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func throw2(data : Int) throws -&gt; Int &#123;</span><br><span class="line">        let res = data + 5</span><br><span class="line">        guard res &lt; 20 else &#123;</span><br><span class="line">            throw ThrowError.ThrowError1</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func throw3(data : Int) throws -&gt; Int &#123;</span><br><span class="line">        let res = data + 3</span><br><span class="line">        guard res &gt; 20 else &#123;</span><br><span class="line">            throw ThrowError.ThrowError1</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let value = try Result(start: data).map(throw1).map(throw2).map(throw3).finish()</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以试着用操作符将 Result map等重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">infix operator -&gt;&gt; &#123;</span><br><span class="line">    associativity left</span><br><span class="line">    precedence 140</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func -&gt;&gt;&lt;T,U&gt;(left : Result&lt;T&gt;, trans : ((T) throws -&gt; U)) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">    return left.map(trans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let start = Result(start: data)</span><br><span class="line">let value = try (start -&gt;&gt; throw1 -&gt;&gt; throw2 -&gt;&gt; throw3).finish()</span><br><span class="line">return value</span><br></pre></td></tr></table></figure>
<p><strong><em>如throw1这样的func是像验证邮箱、用户名这样的功能性func,则可以提取成为全局功能代码复用，减少代码量。</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/错误处理-railway-oriented-programming/" data-id="cimszol6n001ji8zljhhkx570" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pattern/">Pattern</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Pattern/" style="font-size: 16.67px;">Pattern</a> <a href="/tags/Swift/" style="font-size: 20px;">Swift</a> <a href="/tags/iOS/" style="font-size: 16.67px;">iOS</a> <a href="/tags/后端/" style="font-size: 20px;">后端</a> <a href="/tags/工具/" style="font-size: 13.33px;">工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/09/KVO-PG/">KVO_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/08/KVC-PG/">KVC_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
          </li>
        
          <li>
            <a href="/2016/04/06/责任链/">责任链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 天晷<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>