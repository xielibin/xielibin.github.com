<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>天晷</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="天晷">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="天晷">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天晷">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="天晷" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天晷</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">脑容量有限，清理出来装灵感吧！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-EventHandler-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/EventHandler-PG/" class="article-date">
  <time datetime="2016-04-07T06:55:15.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对事件的响应是应用的灵魂所在。</p>
<p><strong>一个事件沿着特定的路径分发到可以响应处理它的对象上</strong>，首先，UIApplication对象从事件队列顶取出一个事件分发准备处理。分发到key window对象上，window将事件赋予一个初始化对象处理。实始化对象取决于事件的类型。</p>
<ol>
<li>点击事件：对于点击事件，window先向一个发生点击事件的view分发，此view称为hit-test view。寻找view的过程称为：hit-testing。</li>
<li>Motion 和 远程 事件：window将事件发送到first responder处理。</li>
</ol>
<p>UIKit first sends the event to the object that is best suited to handle the event. For touch events, that object is the hit-test view, and for other events, that object is the first responder.</p>
<h2 id="hit-testing"><a href="#hit-testing" class="headerlink" title="hit-testing"></a>hit-testing</h2><p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_1.tiff" alt="Figure2_1"></p>
<p>如图，假设用户点击2-1上的E视图。iOS查找hit-test view检查顺序：</p>
<ol>
<li>touch事件在视图A内发生，所以检查视图B、C。</li>
<li>touch事件没有在视图B内，在而视图C内，所以检查视图D、E。</li>
<li>touch事件没有在视图D内，但在视图E内。</li>
<li>在视力层次结构里，视图E是最底层的，所以视图变成hist-test view。</li>
</ol>
<p>hitTest:withEvent:方法返回hit-test view通过 CGPoint point 和 UIEvent。hitTest:withEvent:方法首先调用自己的pointInside:withEvent:方法。如果传入hitTest:withEvent:方法的point在视图之内，则pointInside:withEvent:返回YES。然后hitTest方法在子视图上递归调用hitTest方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CustomHitTestView: UIView &#123;</span><br><span class="line">    </span><br><span class="line">    override func hitTest(point: CGPoint, withEvent event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line">        return self</span><br><span class="line">//        return super.hitTest(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func pointInside(point: CGPoint, withEvent event: UIEvent?) -&gt; Bool &#123;</span><br><span class="line">        return super.pointInside(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Regulating-the-Delivery-of-Touches-to-Views"><a href="#Regulating-the-Delivery-of-Touches-to-Views" class="headerlink" title="Regulating the Delivery of Touches to Views"></a>Regulating the Delivery of Touches to Views</h2><p>window首先将touch事件发送到任何依附于hit-test view（或者其父视图吗？）的Gesture。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/1_5.tiff" alt="Figure1_5"></p>
<p><strong>Gesture Recognizers Get the First Opportunity to Recognize a Touch</strong></p>
<p>window延迟向view分发事件，让手势识别器有机会先分析touch。在延迟期间，如果手势识别器识别到touch手势，则window不会分发touch事件到view，并且会取消之前已经分发到view上和这个识别序列有关的touch object。</p>
<h2 id="Creating-a-Custom-Gesture-Recognizer"><a href="#Creating-a-Custom-Gesture-Recognizer" class="headerlink" title="Creating a Custom Gesture Recognizer"></a>Creating a Custom Gesture Recognizer</h2><p>在自定义手势，则需要实现 UIGestureRecognizerSubclass 下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public func reset()</span><br><span class="line">public func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br></pre></td></tr></table></figure>
<p>Guide内的例子如下，不过官网上的代码有点Bug：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import UIKit.UIGestureRecognizerSubclass</span><br><span class="line"></span><br><span class="line">class CustomGestureRecognizer: UIGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    private var midPoint = CGPointZero</span><br><span class="line">    var strokeUp = false</span><br><span class="line">    </span><br><span class="line">    override func reset() &#123;</span><br><span class="line">        super.reset()</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesBegan(touches, withEvent:event)</span><br><span class="line">        </span><br><span class="line">        if touches.count != 1 &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesMoved(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state != .Failed else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let win = self.view?.window</span><br><span class="line">        let nowPoint = touches.first?.locationInView(win)</span><br><span class="line">        let prevPoint = touches.first?.previousLocationInView(win)</span><br><span class="line">        </span><br><span class="line">        guard let now = nowPoint, let prev = prevPoint where !strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if now.x &gt;= prev.x &amp;&amp; now.y &gt;= prev.y &#123;</span><br><span class="line">            midPoint = now</span><br><span class="line">        &#125; else if now.x &gt;= midPoint.x &amp;&amp; now.y &lt;= midPoint.y &#123;</span><br><span class="line">            strokeUp = true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesEnded(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state == .Possible &amp;&amp; strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        state = UIGestureRecognizerState.Recognized</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesCancelled(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">        state = .Failed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以参考这个例子 ： <a href="https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers" target="_blank" rel="external">https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers</a></p>
<p><strong>在完成hit-testing 且没有手势识别后，view作为responser开始响应</strong></p>
<h2 id="Responder-Object"><a href="#Responder-Object" class="headerlink" title="Responder Object"></a>Responder Object</h2><p>Responder Object是一个能够响应和处理事件的对象，UIResponder是所以Responder Object的基类。<br>一个对象成为First Responder需要做以下两个任务：</p>
<ol>
<li>Overriding the canBecomeFirstResponder method to return YES.</li>
<li>Receiving a becomeFirstResponder message. If necessary, an object can send itself this message.</li>
</ol>
<h2 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h2><p>定义：The responder chain is a series of linked responder objects. It starts with the first responder and ends with the application object.</p>
<p>作用：If the first responder cannot handle an event, it forwards the event to the next responder in the responder chain.</p>
<p>响应链用于收下事件：</p>
<ol>
<li>点击事件，事件响应开始于 hit-test view。</li>
<li>Motion：要处理shake-motion事件，第一响应者需要实现UIResponder下motionBegan:withEvent: or motionEnded:withEvent:方法。</li>
<li>Remote：要处理remote事件，第一响应者必须实现UIResponder的 remoteControlReceivedWithEvent:  方法。</li>
<li>Action Message：当操作一个Control，当添加Target并设置为nil时，这个message将沿着responder chain传递。</li>
<li>Editing-menu Message。</li>
<li>Text editing。</li>
</ol>
<h2 id="Responder-Chain-delivery-Path"><a href="#Responder-Chain-delivery-Path" class="headerlink" title="Responder Chain delivery Path"></a>Responder Chain delivery Path</h2><p>如果initial对象（hit-test view 或者 first Responder）不能处理事件，则将事件通过next Responder沿着Chain传递。每个Responder决定是否处理这个事件，或者沿着Chain继续传递下去。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_2.tiff" alt="Figure2_2"></p>
<p>参考官方文档链接：<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/EventHandler-PG/" data-id="cimq51h3e0008byzlg5kfos04" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OC-运行时概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/OC-运行时概记/" class="article-date">
  <time datetime="2016-04-06T12:29:15.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>必然时间太久还是会忘，还是记一下吧。</p>
<p>Guide中对runtime解释：The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
<p>OC将决议从编译时延迟到运行时，作为动态运行。这意味着不但需要编译器，同时还需要一个运行时系统来执行编译代码。这个运行时系统为OC充当一个操作系统，使其能够运行。</p>
<h3 id="Interact"><a href="#Interact" class="headerlink" title="Interact"></a>Interact</h3><ol>
<li>通过源码实现功能，编译后动态运行。</li>
<li>通过NSObject 提供的部分查询method，如methodForSelector: \ respondsToSelector:等。</li>
<li>通过runtime functions。</li>
</ol>
<p>OC定义Class结构，在/objc/runtime.h中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>表示一个实例对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看几个重要的定义：<br>OC版本源文件内定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">struct objc_method_description &#123;</span><br><span class="line">	SEL name;               /**&lt; The name of the method */</span><br><span class="line">	char *types;            /**&lt; The types of the method arguments */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>在Swift库中已经预留出和OC版源文件相同的头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import ObjectiveC.List</span><br><span class="line">import ObjectiveC.NSObjCRuntime</span><br><span class="line">import ObjectiveC.NSObject</span><br><span class="line">import ObjectiveC.Object</span><br><span class="line">import ObjectiveC.Protocol</span><br><span class="line">import ObjectiveC.message</span><br><span class="line">import ObjectiveC.objc</span><br><span class="line">import ObjectiveC.objc_api</span><br><span class="line">import ObjectiveC.objc_auto</span><br><span class="line">import ObjectiveC.objc_class</span><br><span class="line">import ObjectiveC.objc_exception</span><br><span class="line">import ObjectiveC.objc_load</span><br><span class="line">import ObjectiveC.objc_runtime</span><br><span class="line">import ObjectiveC.objc_sync</span><br><span class="line">import ObjectiveC.runtime</span><br></pre></td></tr></table></figure>
<p>在Apple开源的Foundation project内有如此说明：</p>
<p><strong>Runtime: The basis for interoperability.</strong></p>
<p>The classes and methods in this group provide an interface for interoperability between C code and Swift. They also provide common layers used throughout the framework such as the root class NSObject.</p>
<ol>
<li>NSObject is mostly implemented.</li>
<li>NSEnumerator is fully implemented.</li>
<li>NSSwiftRuntime (internal use only) contains Swift runtime-specific functionality.</li>
<li>NSObjCRuntime is missing some key parts such as NSClassFromString. Much of the functionality here is specific to the Objective-C runtime and is not relevant when building for Swift.</li>
</ol>
<p>Swift库ObjectiveC.runtime内定义，对runtime用Swift语法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">public typealias Method = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">public typealias Ivar = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">public typealias Category = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">public typealias objc_property_t = COpaquePointer</span><br><span class="line"></span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">public struct objc_method_description &#123;</span><br><span class="line">    /**&lt; The name of the method */</span><br><span class="line">    public var name: Selector</span><br><span class="line">    /**&lt; The types of the method arguments */</span><br><span class="line">    public var types: UnsafeMutablePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: Selector, types: UnsafeMutablePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">public struct objc_property_attribute_t &#123;</span><br><span class="line">    /**&lt; The name of the attribute */</span><br><span class="line">    public var name: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">    public var value: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: UnsafePointer&lt;Int8&gt;, value: UnsafePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Method 表示方法，分成Selector 和 IMP 部分。</li>
<li>Ivar 表示实例对象的变量。</li>
<li>Category 表示OC范筹。</li>
<li>objc_property_t 表示属性。</li>
</ol>
<h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h3><ol>
<li>将语法 [receiver message] 翻译成 objc_msgSend(receiver, selector)。</li>
<li>在objc_cache中查找方法。</li>
<li>如果在cache中没找到，则在 objc_method_list 里查找， 如果找到则 缓存。</li>
<li>如果在 objc_method_list 里没找到，则在指向父类查找。</li>
</ol>
<h3 id="Dynamic加载"><a href="#Dynamic加载" class="headerlink" title="Dynamic加载"></a>Dynamic加载</h3><h6 id="Dynamic-Method-Resolution"><a href="#Dynamic-Method-Resolution" class="headerlink" title="Dynamic Method Resolution"></a>Dynamic Method Resolution</h6><p>定义一个Class 未实现 objectSend方法，动态用 resolveObjectSend方法替换实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)resolveObjectSend &#123;</span><br><span class="line">    NSLog(@&quot;resolve message send ....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    if (sel == @selector(objectSend)) &#123;</span><br><span class="line">        IMP res = class_getMethodImplementation([self class], @selector(resolveObjectSend));</span><br><span class="line">        BOOL result = class_addMethod([self class], sel, res, &quot;v@:&quot;);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            NSLog(@&quot;method added ....&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否为 objectSend 消息。</li>
<li>用运行时方法取出 resolveObjectSend 方法 对应的实现。</li>
<li>增加方法，用 resolveObjectSend 的实现 作为 objectSend 的实现。</li>
</ol>
<p>对于实例方法或者类方法没有实现的，可以用 resolveInstanceMethod 或者 resolveClassMethod 动态添加实现。</p>
<h3 id="消息转发-Message-Forwarding"><a href="#消息转发-Message-Forwarding" class="headerlink" title="消息转发 Message Forwarding"></a>消息转发 Message Forwarding</h3><p>在发送一个消息对对象后，如果对象不能处理消息，则会产生运行时错误，在抛出这个错误之前runtime会用forwardInvocation再进行一次处理 — 称为消息转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void) forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([anInvocation selector] == @selector(objectSend)) &#123;</span><br><span class="line">        anInvocation.selector = @selector(resolveObjectSend);</span><br><span class="line">        [anInvocation invokeWithTarget:another];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature * signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        signature = [another methodSignatureForSelector:@selector(resolveObjectSend)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时func使用"><a href="#运行时func使用" class="headerlink" title="运行时func使用"></a>运行时func使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">    var pro : NSArray = [1, 2]</span><br><span class="line">    var pro1 : NSString = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObject = MyClass()</span><br><span class="line">myObject.pro = [2, 3]</span><br><span class="line"></span><br><span class="line">let proName : String = &quot;pro&quot;</span><br><span class="line">let iii : [CChar]? = proName.cStringUsingEncoding(NSUTF8StringEncoding)</span><br><span class="line">let iva : Ivar = class_getInstanceVariable(MyClass.self, iii!)</span><br><span class="line">let valueForIva = object_getIvar(myObject, iva)  // [2, 3]</span><br><span class="line"></span><br><span class="line">var count : UInt32 = 0</span><br><span class="line">let list = class_copyIvarList(MyClass.self, &amp;count)</span><br><span class="line"></span><br><span class="line">for i in 0..&lt;Int(count) &#123;</span><br><span class="line">    let name = ivar_getName(list[i])</span><br><span class="line">    print(String(UTF8String: name))  // Optional(&quot;pro&quot;)   // Optional(&quot;pro1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let my = MyClass()</span><br><span class="line">object_getIvar(my, list[1])   // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">list.dealloc(2)</span><br></pre></td></tr></table></figure>
<p>参考官方文档地址： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/OC-运行时概记/" data-id="cimq51h40000gbyzlbo2v7nab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-责任链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/责任链/" class="article-date">
  <time datetime="2016-04-06T07:24:25.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/责任链/">责任链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//职责链是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。<br>//将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>//对象本身要经过什么处理是通过每个链上元素通过运行态来决定的，决定的因素是取决于对象的属性或者一些其他方面的策略。<br>//用户无论是从哪一个节点作为他的请求头节点，最终用户都可以得到一个请求的反馈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">struct LeaveRequest &#123;</span><br><span class="line">    var id : Int</span><br><span class="line">    var day : Float</span><br><span class="line">    var reason : String</span><br><span class="line">    </span><br><span class="line">    func checkReason() &#123;</span><br><span class="line">        print(reason)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol LeaveHandler &#123;</span><br><span class="line">    var nextLevel : LeaveHandler? &#123;get set&#125;</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request : LeaveRequest) -&gt; Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension LeaveHandler &#123;</span><br><span class="line">    mutating func setNextLevel(next : LeaveHandler) &#123;</span><br><span class="line">        self.nextLevel = next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func nextLevelHandler(request : LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if let next = nextLevel &#123;</span><br><span class="line">            return next.handlerLeaveRequest(request)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request : LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        return nextLevelHandler(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Boss : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 4 &lt; request.day &amp;&amp; request.day &lt; 7 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;No Rule ...&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct HR : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 2 &lt; request.day &amp;&amp; request.day &lt;= 4 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            </span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PM : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 1 &lt; request.day &amp;&amp; request.day &lt;= 2 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Leader : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if request.day &lt;= 1 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let boss = Boss(name: &quot;Boss&quot;, nextLevel: nil)</span><br><span class="line">let hr = HR(name: &quot;HR&quot;, nextLevel: boss)</span><br><span class="line">let pm = PM(name: &quot;PM&quot;, nextLevel: hr)</span><br><span class="line">let leader = Leader(name: &quot;leader&quot;, nextLevel: pm)</span><br><span class="line"></span><br><span class="line">let leaveRequest = LeaveRequest(id: 1, day: 3, reason: &quot;个人原因&quot;)</span><br><span class="line">leader.handlerLeaveRequest(leaveRequest)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/责任链/" data-id="cimq51h4t000zbyzlg2hp40lb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Unicode-UFT8-概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/Unicode-UFT8-概记/" class="article-date">
  <time datetime="2016-04-05T11:32:24.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/Unicode-UFT8-概记/">Unicode_UFT8_概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p>
<p>Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。</p>
<p>Unicode计划使用了17个平面，一共有17×65536=1114112个码位。在Unicode 5.0.0版本中，已定义的码位只有238605个，分布在平面0、平面1、平面2、平面14、平面15、平面16。其中平面15和平面16上只是定义了两个各占65534个码位的专用区（Private Use Area），分别是0xF0000-0xFFFFD和0x100000-0x10FFFD。所谓专用区，就是保留给大家放自定义字符的区域，可以简写为PUA。</p>
<p>平面0也有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。</p>
<p>如前所述在Unicode 5.0.0版本中，238605-65534*2-6400-2048=99089。余下的99089个已定义码位分布在平面0、平面1、平面2和平面14上，它们对应着Unicode定义的99089个字符，其中包括71226个汉字。平面0、平面1、平面2和平面14上分别定义了52080、3419、43253和337个字符。平面2的43253个字符都是汉字。平面0上定义了27973个汉字。</p>
<p>在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：UTF-8、UTF-16、UTF-32。<strong><em>UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。</em></strong><br>例如，“汉字”对应的数字是0x6c49和0x5b57，而编码的程序数据是：</p>
<p>| | | |<br>|<br>|1 | char  |    data_utf8[]={0xE6,0xB1,0x89,0xE5,0xAD,0x97};//UTF-8编码|<br>|2 | char16_t |  data_utf16[]={0x6C49,0x5B57};        //UTF-16编码|<br>|3 | char32_t |  data_utf32[]={0x00006C49,0x00005B57};//UTF-32编码|</p>
<p><strong><em>UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式</em></strong></p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：</p>
<p>|Unicode编码(十六进制)　|UTF-8 字节流(二进制)|<br>|<br>|00000000 - 0000007F | 0xxxxxxx |<br>|00000080 - 000007FF | 110xxxxx 10xxxxxx |<br>|00000800 - 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |<br>|00010000 - 001FFFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>|00200000 - 03FFFFFF |    111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>|04000000 - 7FFFFFFF |    1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |</p>
<p>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是6个字节。从上表可以看出，6字节模板有31个x，即可以容纳31位二进制数字。Unicode的最大码位0x7FFFFFFF也只有31位。</p>
<h6 id="例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx-10xxxxxx-10xxxxxx。将0x6C49写成二进制是：0110-1100-0100-1001，-用这个比特流依次代替模板中的x，得到：11100110-10110001-10001001，即E6-B1-89。"><a href="#例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx-10xxxxxx-10xxxxxx。将0x6C49写成二进制是：0110-1100-0100-1001，-用这个比特流依次代替模板中的x，得到：11100110-10110001-10001001，即E6-B1-89。" class="headerlink" title="例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。"></a>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</h6><h6 id="例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx-10xxxxxx-10xxxxxx-10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0-0010-0000-1100-0011-0000，用这个比特流依次代替模板中的x，得到：11110000-10100000-10110000-10110000，即F0-A0-B0-B0。"><a href="#例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx-10xxxxxx-10xxxxxx-10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0-0010-0000-1100-0011-0000，用这个比特流依次代替模板中的x，得到：11110000-10100000-10110000-10110000，即F0-A0-B0-B0。" class="headerlink" title="例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。"></a>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。</h6><h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16编码以16位无符号整数为单位。我们把Unicode<br>unicode<br>unicode<br>编码记作U。编码规则如下：<br>如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。<br>如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。</p>
<p>百度链接 ： <a href="http://baike.baidu.com/link?url=Knk24RC6XBNUrL6Rd6oMkiJvB5ZPut2fNasaco1BoKCwgPj254kWmXc-JizuydvO7MLJmLknsygroeOyCjOsb_" target="_blank" rel="external">http://baike.baidu.com/link?url=Knk24RC6XBNUrL6Rd6oMkiJvB5ZPut2fNasaco1BoKCwgPj254kWmXc-JizuydvO7MLJmLknsygroeOyCjOsb_</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/Unicode-UFT8-概记/" data-id="cimq51h4l000vbyzlpbu9gvuo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/">Other</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Revel-Filter-Chain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/04/Revel-Filter-Chain/" class="article-date">
  <time datetime="2016-04-04T14:09:20.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/Revel-Filter-Chain/">Revel Filter Chain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前有提到在启用服务后，在Handle回调内处理请求会调用 <code>Filters[0](c, Filters[1:])</code>。<br>关于Filter整个处理涉及到知识点过多，对于不太理解的地方待以后慢慢补充。。。。</p>
<h2 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h2><p>在filter.go文件内定义了官方标准Filter chain的11个Filter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Filters = []Filter&#123;</span><br><span class="line">	PanicFilter,             // Recover from panics and display an error page instead.</span><br><span class="line">	RouterFilter,            // Use the routing table to select the right Action.</span><br><span class="line">	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.</span><br><span class="line">	ParamsFilter,            // Parse parameters into Controller.Params.</span><br><span class="line">	SessionFilter,           // Restore and write the session cookie.</span><br><span class="line">	FlashFilter,             // Restore and write the flash cookie.</span><br><span class="line">	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.</span><br><span class="line">	I18nFilter,              // Resolve the requested language.</span><br><span class="line">	InterceptorFilter,       // Run interceptors around the action.</span><br><span class="line">	CompressFilter,          // Compress the result.</span><br><span class="line">	ActionInvoker,           // Invoke the action.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PanicFilter"><a href="#PanicFilter" class="headerlink" title="PanicFilter"></a>PanicFilter</h4><p>在panic.go内，这个Filter定义的功能相对简单，定义一个defer func等待处理 Package builtin 的 panic 调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func PanicFilter(c *Controller, fc []Filter) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err := recover(); err != nil &#123;</span><br><span class="line">			handleInvocationPanic(c, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fc[0](c, fc[1:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在整个Chain内有错误发生，则抓取错误信息作为c.Result渲染。</p>
<h4 id="RouterFilter"><a href="#RouterFilter" class="headerlink" title="RouterFilter"></a>RouterFilter</h4><p>在router.go内，从MainRouter 根据Request 找出路由信息：</p>
<ol>
<li>判定路由如果不存在，则渲染 NotFound 错误。</li>
<li>判定route 的Action 如果是404，则渲染 NotFound 错误。</li>
<li>如果给Controller 设置 Action 出现错误， 则渲染 NotFound 错误。</li>
</ol>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Add the route and fixed params to the Request Params.</span><br><span class="line">c.Params.Route = route.Params</span><br><span class="line"></span><br><span class="line">// Add the fixed parameters mapped by name.</span><br><span class="line">// TODO: Pre-calculate this mapping.</span><br><span class="line">for i, value := range route.FixedParams &#123;</span><br><span class="line">	if c.Params.Fixed == nil &#123;</span><br><span class="line">		c.Params.Fixed = make(url.Values)</span><br><span class="line">	&#125;</span><br><span class="line">	if i &lt; len(c.MethodType.Args) &#123;</span><br><span class="line">		arg := c.MethodType.Args[i]</span><br><span class="line">		c.Params.Fixed.Set(arg.Name, value)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		WARN.Println(&quot;Too many parameters to&quot;, route.Action, &quot;trying to add&quot;, value)</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fc[0](c, fc[1:])</span><br></pre></td></tr></table></figure>
<ol>
<li><code>c.Params.Route = route.Params</code>， 类似REST声明的参数赋值给 Params.Route（Route url.Values // Parameters extracted from the route,  e.g. /customers/{id}）</li>
<li>在配置Router里可以设置固定参数，现在将固定参数赋值给 Params.Fixed (Fixed url.Values // Fixed parameters from the route, e.g. App.Action(“fixed param”))</li>
</ol>
<h4 id="FilterConfiguringFilter"><a href="#FilterConfiguringFilter" class="headerlink" title="FilterConfiguringFilter"></a>FilterConfiguringFilter</h4><p>filterconfig.go是针对Controller.Action定制Filter 的地方，并声明一个 <code>var filterOverrides = make(map[string][]Filter)</code> 管理定制的Filter Chain。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Note: the last filter stage is not subject to the configurator.  In</span><br><span class="line">// particular, Add() adds a filter to the second-to-last place.</span><br><span class="line">type FilterConfigurator struct &#123;</span><br><span class="line">	key            string // e.g. &quot;App&quot;, &quot;App.Action&quot;</span><br><span class="line">	controllerName string // e.g. &quot;App&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了3个生成 FilterConfigurator 的方法：</p>
<ol>
<li><code>func newFilterConfigurator(controllerName, methodName string) FilterConfigurator</code></li>
<li><code>func FilterController(controllerInstance interface{}) FilterConfigurator</code></li>
<li><code>func FilterAction(methodRef interface{}) FilterConfigurator</code></li>
</ol>
<p>再定义如Add、Remove等操作方法。</p>
<h6 id="FilterConfiguringFilter-操作"><a href="#FilterConfiguringFilter-操作" class="headerlink" title="FilterConfiguringFilter 操作"></a>FilterConfiguringFilter 操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// FilterConfiguringFilter is a filter stage that customizes the remaining</span><br><span class="line">// filter chain for the action being invoked.</span><br><span class="line">func FilterConfiguringFilter(c *Controller, fc []Filter) &#123;</span><br><span class="line">	if newChain := getOverrideChain(c.Name, c.Action); newChain != nil &#123;</span><br><span class="line">		newChain[0](c, newChain[1:])</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	fc[0](c, fc[1:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// getOverrideChain retrieves the overrides for the action that is set</span><br><span class="line">func getOverrideChain(controllerName, action string) []Filter &#123;</span><br><span class="line">	if newChain, ok := filterOverrides[action]; ok &#123;</span><br><span class="line">		return newChain</span><br><span class="line">	&#125;</span><br><span class="line">	if newChain, ok := filterOverrides[controllerName]; ok &#123;</span><br><span class="line">		return newChain</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否有定制的Filter Chain，如果有则接着定制的Filter Chain走。</li>
<li>判定如果没有 则继续 正常的Filter Chain。</li>
</ol>
<h2 id="ParamsFilter"><a href="#ParamsFilter" class="headerlink" title="ParamsFilter"></a>ParamsFilter</h2><p>这个很直接，为了解析请求参数，这个Filter内定义了三个功能步骤：<br>第一步，解析参数：</p>
<ol>
<li><code>params.Query = req.URL.Query()</code>， 设置查询参数 （Query url.Values // Parameters from the query string, e.g. /index?limit=10）</li>
<li>如果是application/x-www-form-urlencoded，解析Form参数，<code>params.Form = req.Form</code>， （Form  url.Values // Parameters from the request body.）</li>
<li>如果是multipart/form-data，解析Form信息，设置 (Form  url.Values // Parameters from the request body.)、（Files    map[string][]*multipart.FileHeader // Files uploaded in a multipart form）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params.Form = req.MultipartForm.Value</span><br><span class="line">params.Files = req.MultipartForm.File</span><br></pre></td></tr></table></figure>
<p>第二步，定义defer func，负责在最后的Filter Chain调用完成后清理 请求参数。<br>第三步，继续Filter Chain。</p>
<h2 id="SessionFilter"><a href="#SessionFilter" class="headerlink" title="SessionFilter"></a>SessionFilter</h2><p>在session.go里，主要功能是配置 和 保存 session，关于session的管理未记录。</p>
<ol>
<li><code>c.Session = restoreSession(c.Request.Request)</code>，恢复一个session（如果有则直接取出，没有则重新初始化一个session）</li>
<li><code>c.RenderArgs[&quot;session&quot;] = c.Session</code>，设置render参数session。</li>
<li>继续执行Filster Chain.</li>
<li>执行完后续Filter Chain后，判定是否存在session，设置Cookie。</li>
</ol>
<h2 id="FlashFilter"><a href="#FlashFilter" class="headerlink" title="FlashFilter"></a>FlashFilter</h2><p>在flash.go里，主要功能是配置 和 保存 flash cookie信息。<br>说来比较惭愧，关于Flash Cookie这个名字还真是第一次听说。</p>
<p>同Http Cookie一样，Flash Cookie也就是记录用户在访问Flash网页的时候保留的信息，鉴于Flash技术的普遍性，几乎所有的网站都采用，所以具有同Http Cookie一样的作用。但是相比起Http Cookie，Flash Cookie更加强大：1、容量更大，Flash Cookie可以容纳最多100千字节的数据，而一个标准的HTTP Cookie只有4千字节;2、FlashCookie没有默认的过期时间;3、FlashCookie将被存储在不同的地点，这使得它们很难被找到。而在10.3版本之前，几乎没有简单删除Flash Cookie的办法。</p>
<ol>
<li><code>c.Flash = restoreFlash(c.Request.Request)</code>，恢复一个 flash。</li>
<li><code>c.RenderArgs[&quot;flash&quot;] = c.Flash.Data</code>，设置render参数flash。</li>
<li>继续执行Filster Chain。</li>
<li>在执行完Filster Chain后，拼接flashValue值。</li>
<li>最后用flashValue生成http.Cookie，给controller设置Cookie。</li>
</ol>
<h2 id="ValidationFilter"><a href="#ValidationFilter" class="headerlink" title="ValidationFilter"></a>ValidationFilter</h2><p>在validation.go里， 这个文件定义了检验常规内容的func功能，并会保存成 ValidationError。</p>
<ol>
<li>恢复Cookie对应的Error信息。</li>
<li>为controller赋值一个Validation。</li>
<li><code>hasCookie := (err != http.ErrNoCookie)</code>，判定是否存在Error Cookie。</li>
<li>继续执行Filter Chain。</li>
<li>执行完Filter Chain后，<code>c.RenderArgs[&quot;errors&quot;] = c.Validation.ErrorMap()</code>，设置render校验错误参数errors。</li>
<li>拼接错误信息，给controller将错误信息设置成错误Cookie信息。</li>
</ol>
<h2 id="I18nFilter"><a href="#I18nFilter" class="headerlink" title="I18nFilter"></a>I18nFilter</h2><p>在i18n.go里，处理国际化相关内容，具体应用待研究。</p>
<ol>
<li><code>hasLocaleCookie(c.Request)</code>，判定是否存在Cookie设置本地化信息，如果有则以此为准。</li>
<li>cookie不成功后，<code>hasAcceptLanguageHeader(c.Request)</code>，判定是否存在接收语言设置本地化。</li>
<li>如果以上都不存在的情况下，则设置为空。</li>
<li>继续执行Filter Chain。</li>
</ol>
<h2 id="InterceptorFilter"><a href="#InterceptorFilter" class="headerlink" title="InterceptorFilter"></a>InterceptorFilter</h2><p>在intercept.go里，主要功能是采用AOP思维，插入操作功能。</p>
<p>添加方式：revel.InterceptMethod((*FoodController).Before, revel.BEFORE)</p>
<ol>
<li>针对controller查找嵌入的BEFORE功能点，并执行。</li>
<li>嵌入BEFORE后，Result是否为空，不为空就结束。</li>
<li>继续执行Filter Chain。</li>
<li>完成后，针对controller查找嵌入的AFTER的功能点，并执行。</li>
<li>采用defer 判定是否存在 panic嵌入功能点，如果存在则执行。</li>
<li>采用defer，针对controller查找嵌入的FINALLY的功能点，并执行。</li>
</ol>
<h2 id="CompressFilter"><a href="#CompressFilter" class="headerlink" title="CompressFilter"></a>CompressFilter</h2><p>在compress.go里，主要处理HTTP响应需要的格式信息。</p>
<ol>
<li>执行后续的Filter Chain。</li>
<li>后续功能完成后，执行响应数据封装—-需要研究下，这里对HTTP响应的处理工作。</li>
</ol>
<h2 id="ActionInvoker"><a href="#ActionInvoker" class="headerlink" title="ActionInvoker"></a>ActionInvoker</h2><p>在invoker.go里，完成controller的调用工作。</p>
<ol>
<li>根据reflect得到method。</li>
<li>组装获取请求参数。</li>
<li>调用得到Result。</li>
</ol>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>也可以自定义Filter，追加到合适的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var HeaderFilter = func(c *revel.Controller, fc []revel.Filter) &#123;</span><br><span class="line">	// Add some common security headers</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;)</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;)</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;)</span><br><span class="line"></span><br><span class="line">	fc[0](c, fc[1:]) // Execute the next filter stage.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/04/Revel-Filter-Chain/" data-id="cimq51h55001bbyzl821w6ir2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/AOP/" class="article-date">
  <time datetime="2016-04-03T13:08:18.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/AOP/">AOP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Wiki上对AOP解释，<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming：" target="_blank" rel="external">https://en.wikipedia.org/wiki/Aspect-oriented_programming：</a></p>
<p>In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a “pointcut” specification, such as “log all function calls when the function’s name begins with ‘set’”. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code core to the functionality. AOP forms a basis for aspect-oriented software development.</p>
<p>在不修改现有代码的基础之上，通过一个切入点添加特定的行为且不会影响原有的逻辑，例如当全部func开始调用的时候打印日志。</p>
<h2 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h2><h4 id="class-func-load"><a href="#class-func-load" class="headerlink" title="class func load"></a>class func load</h4><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
<p>In addition:</p>
<p>A class’s +load method is called after all of its superclasses’ +load methods.</p>
<p>A category +load method is called after the class’s own +load method.</p>
<p>Swift Class不允许overrid load方法，重写时会报错：Method ‘load()’ defines Objective-C class method ‘load’, which is not permitted by Swift.</p>
<h4 id="class-func-initialize"><a href="#class-func-initialize" class="headerlink" title="class func initialize"></a>class func initialize</h4><p>Initializes the class before it receives its first message.</p>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self == [ClassName self]) &#123;</span><br><span class="line">    // ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
<ol>
<li>initialize在接收到第一条消息以前调用。</li>
<li>initialize方法调用是线程安全的。</li>
<li>父类先于子类调用；父类可能会被调用多次，当子类未实现该方法或者子类明确调用[super initialize]。</li>
<li>想确保代码只被执行一次，可用 self == [ClassName self] 判定。</li>
<li>因为是线程安全，不能保证执行顺序，不应该做过多的任务。</li>
</ol>
<h2 id="Requiring-Dynamic-Dispatch"><a href="#Requiring-Dynamic-Dispatch" class="headerlink" title="Requiring Dynamic Dispatch"></a>Requiring Dynamic Dispatch</h2><p>在Swift Interacting with Object-C 中，<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57：" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57：</a></p>
<p>When Swift APIs are imported by the Objective-C runtime, there are no guarantees of dynamic dispatch for properties, methods, subscripts, or initializers. The Swift compiler may still devirtualize or inline member access to optimize the performance of your code, bypassing the Objective-C runtime.</p>
<p>You can use the dynamic modifier to require that access to members be dynamically dispatched through the Objective-C runtime. Requiring dynamic dispatch is rarely necessary. However, it is necessary when using using APIs like key–value observing or the method_exchangeImplementations function in the Objective-C runtime, which dynamically replace the implementation of a method at runtime. If the Swift compiler inlined the implementation of the method or devirtualized access to it, the new implementation would not be used.</p>
<ol>
<li>Swift API 是通过 Ojbect-C 运行时导入，由于Swift编译会绕过OC运行时进行 性能优化，不能保证 properties, methods, subscripts等的动态分发。</li>
<li>设置 dynamic modifier ，实现如KVC 、 method_exchangeImplementations 等功能。</li>
</ol>
<h2 id="OC-Swift-AOP"><a href="#OC-Swift-AOP" class="headerlink" title="OC/Swift AOP"></a>OC/Swift AOP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">extension UIViewController &#123;</span><br><span class="line">    public override class func initialize() &#123;</span><br><span class="line">        super.initialize()</span><br><span class="line">        </span><br><span class="line">        struct Static &#123;</span><br><span class="line">            static var token: dispatch_once_t = 0</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //make sure this isn&apos;t a subclass</span><br><span class="line">        if self !== UIViewController.self &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_once(&amp;Static.token) &#123; () -&gt; Void in</span><br><span class="line">            let originalSelector = Selector(&quot;viewDidAppear:&quot;)</span><br><span class="line">            let swizzleSelector = Selector(&quot;nsh_ViewDidAppear:&quot;)</span><br><span class="line">            </span><br><span class="line">            let originalMethod = class_getInstanceMethod(self, originalSelector)</span><br><span class="line">            let swizzleMethod = class_getInstanceMethod(self, swizzleSelector)</span><br><span class="line">            </span><br><span class="line">            let didAddMethod = class_addMethod(self, originalSelector, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod))</span><br><span class="line">            </span><br><span class="line">            if didAddMethod &#123;</span><br><span class="line">                class_replaceMethod(self, swizzleSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                method_exchangeImplementations(originalMethod, swizzleMethod)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dynamic func nsh_ViewDidAppear(animated: Bool) &#123;</span><br><span class="line">        self.nsh_ViewDidAppear(animated)</span><br><span class="line">        print(&quot;viewDidAppear: \(self.description)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Method 分成两 Selector 和 IMP 两部分。</li>
<li>当方法实现部分交换后， 用 self.nsh_ViewDidAppear(animated) 调用指向的是 之前的 ViewDidAppear 实现地址。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/AOP/" data-id="cimq51h2v0000byzlekak3sl9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-策略模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/策略模式/" class="article-date">
  <time datetime="2016-04-03T05:41:10.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/策略模式/">策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Pattern-Strategy"><a href="#Pattern-Strategy" class="headerlink" title="Pattern: Strategy"></a>Pattern: Strategy</h3><p>//设计原则一：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
<p>//设计原则二：针对接口编程，而不是针对实现编程。</p>
<p>//设计原则三：多用组合，少用继承</p>
<p>//策略模式：定义算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protocol FlyBehavior &#123;</span><br><span class="line">    func fly() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol QuackBehavior &#123;</span><br><span class="line">    func quack() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct BehaviorFly : FlyBehavior &#123;</span><br><span class="line">    func fly() -&gt; String &#123;</span><br><span class="line">        return &quot;I&apos;m flying!!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct CantFly : FlyBehavior &#123;</span><br><span class="line">    func fly() -&gt; String &#123;</span><br><span class="line">        return &quot;I can&apos;t fly&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Quack : QuackBehavior &#123;</span><br><span class="line">    func quack() -&gt; String &#123;</span><br><span class="line">        return &quot;Quack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MuteQuack : QuackBehavior &#123;</span><br><span class="line">    func quack() -&gt; String &#123;</span><br><span class="line">        return &quot;Silence&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Duck &#123;</span><br><span class="line">    var fly : FlyBehavior</span><br><span class="line">    var quack : QuackBehavior</span><br><span class="line">    </span><br><span class="line">    func performFly() -&gt; String &#123;</span><br><span class="line">        return fly.fly()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func performQuack() -&gt; String &#123;</span><br><span class="line">        return quack.quack()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use</span><br><span class="line">let cantFly = CantFly()</span><br><span class="line">let muteQuack = MuteQuack()</span><br><span class="line">let duck1 = Duck(fly: cantFly, quack: muteQuack)</span><br><span class="line">duck1.performFly()</span><br><span class="line">duck1.performQuack()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/策略模式/" data-id="cimq51h4w0012byzlm8ynrx97" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-错误处理-railway-oriented-programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/错误处理-railway-oriented-programming/" class="article-date">
  <time datetime="2016-04-03T03:08:51.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/错误处理-railway-oriented-programming/">错误处理-railway oriented programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>在Swift 2中，增加了Error Handler，让处理错误异常有了新的方式</strong></p>
<p>关于《Swift 2 throws 全解析 - 从原理到实践》一文对throws进行了详细描述。网站地址：<a href="http://www.ibm.com/developerworks/cn/mobile/mo-cn-swift/index.html，作者：王巍" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/mobile/mo-cn-swift/index.html，作者：王巍</a> (@onevcat)</p>
<p>Scott Wlaschin 的 Railway Oriented Programming — error handling in functional languages 视频讲述了轨道编程，地址：<a href="https://vimeo.com/97344498" target="_blank" rel="external">https://vimeo.com/97344498</a></p>
<p>这里记录一下自己 结合Swift 2 Error Handler 采用 面向轨道-错误处理 运用。</p>
<h2 id="直接抛出"><a href="#直接抛出" class="headerlink" title="直接抛出"></a>直接抛出</h2><p>直接处理方式，有错误直接抛出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum ThrowError : ErrorType &#123;</span><br><span class="line">    case ThrowError1</span><br><span class="line">    case ThrowError2</span><br><span class="line">    case ThrowError3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func handlerFlow(data : Int) throws -&gt; Int &#123;</span><br><span class="line">    let data1 = data + 5</span><br><span class="line">    guard data1 &gt; 10 else &#123;</span><br><span class="line">        throw ThrowError.ThrowError1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let data2 = data1 + 5</span><br><span class="line">    guard data2 &lt; 20 else &#123;</span><br><span class="line">        throw ThrowError.ThrowError2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let data3 = data2 + 3</span><br><span class="line">    guard data3 &gt; 20 else &#123;</span><br><span class="line">        throw ThrowError.ThrowError3</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return data3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>参考系统库Optional：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T&gt; &#123;</span><br><span class="line">    case Success(T)</span><br><span class="line">    case Failure(ErrorType)</span><br><span class="line"></span><br><span class="line">    init(start : T) &#123;</span><br><span class="line">        self = .Success(start)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func flatMap&lt;U&gt;(trans : T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Success(let value):</span><br><span class="line">            return trans(value)</span><br><span class="line">        case .Failure(let err):</span><br><span class="line">            return .Failure(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func map&lt;U&gt;(trans : ((T) throws -&gt; U)) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Success(let value):</span><br><span class="line">            do &#123;</span><br><span class="line">                let value : U = try trans(value)</span><br><span class="line">                return .Success(value)</span><br><span class="line">            &#125; catch &#123;</span><br><span class="line">                return .Failure(error)</span><br><span class="line">            &#125;</span><br><span class="line">        case .Failure(let err):</span><br><span class="line">            return .Failure(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func finish() throws -&gt; T &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Success(let value):</span><br><span class="line">            return value</span><br><span class="line">        case .Failure(let err):</span><br><span class="line">            throw err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-chain-传递"><a href="#Error-chain-传递" class="headerlink" title="Error chain 传递"></a>Error chain 传递</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func handlerFlow(data : Int) throws -&gt; Int &#123;</span><br><span class="line">    func throw1(data : Int) throws -&gt; Int &#123;</span><br><span class="line">        let res = data + 5</span><br><span class="line">        guard res &gt; 10 else &#123;</span><br><span class="line">            throw ThrowError.ThrowError1</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func throw2(data : Int) throws -&gt; Int &#123;</span><br><span class="line">        let res = data + 5</span><br><span class="line">        guard res &lt; 20 else &#123;</span><br><span class="line">            throw ThrowError.ThrowError1</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func throw3(data : Int) throws -&gt; Int &#123;</span><br><span class="line">        let res = data + 3</span><br><span class="line">        guard res &gt; 20 else &#123;</span><br><span class="line">            throw ThrowError.ThrowError1</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let value = try Result(start: data).map(throw1).map(throw2).map(throw3).finish()</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以试着用操作符将 Result map等重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">infix operator -&gt;&gt; &#123;</span><br><span class="line">    associativity left</span><br><span class="line">    precedence 140</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func -&gt;&gt;&lt;T,U&gt;(left : Result&lt;T&gt;, trans : ((T) throws -&gt; U)) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">    return left.map(trans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let start = Result(start: data)</span><br><span class="line">let value = try (start -&gt;&gt; throw1 -&gt;&gt; throw2 -&gt;&gt; throw3).finish()</span><br><span class="line">return value</span><br></pre></td></tr></table></figure>
<p><strong><em>如throw1这样的func是像验证邮箱、用户名这样的功能性func,则可以提取成为全局功能代码复用，减少代码量。</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/错误处理-railway-oriented-programming/" data-id="cimq51h520019byzl96cltr32" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Revel-Server-Run" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/31/Revel-Server-Run/" class="article-date">
  <time datetime="2016-03-31T14:39:53.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/Revel-Server-Run/">Revel-Server_Run</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在main执行的最后调用server.go Run func 开启HTTP服务。</p>
<ol>
<li>根据设置的地址和端口等，拼接出 localAddress</li>
<li>生成http.Server ，每个参数接收地址， 第二个是回调 handle, 最后设置Read Write 超时时长。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server = &amp;http.Server&#123;</span><br><span class="line">		Addr:         localAddress,</span><br><span class="line">		Handler:      http.HandlerFunc(handle),</span><br><span class="line">		ReadTimeout:  time.Minute,</span><br><span class="line">		WriteTimeout: time.Minute,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>runStartupHooks() 开启服务前运行在各个文件init里注册的hook 方法。</li>
<li>设置 MainTemplateLoader ，准备解析模板</li>
<li>根据watch情况，设置 MainWatcher 并在 Filter最开始加入 WatchFilter ， 并且监测 Template下文件变动</li>
<li>如果 HttpSsl 是 true , 调用 <code>Server.ListenAndServeTLS(HttpSslCert, HttpSslKey))</code> 开启Server服务。 Server.ListenAndServeTLS : ListenAndServeTLS listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</li>
<li>如果 HttpSsl 是 false , 调用 <code>listener, err := net.Listen(network, localAddress)</code> ： Listen announces on the local network address laddr. 然后 <code>Server.Serve(listener)</code> : Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</li>
</ol>
<h2 id="StartupHooks"><a href="#StartupHooks" class="headerlink" title="StartupHooks"></a>StartupHooks</h2><p>Startup Hook 定义如下 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var startupHooks []func()   //全局变量</span><br><span class="line"></span><br><span class="line">func OnAppStart(f func()) &#123;</span><br><span class="line">	startupHooks = append(startupHooks, f)</span><br><span class="line">&#125;   // 全局注册方法</span><br><span class="line"></span><br><span class="line">//      // from: yourapp/app/controllers/somefile.go</span><br><span class="line">//      func InitDB() &#123;</span><br><span class="line">//          // do DB connection stuff here</span><br><span class="line">//      &#125;</span><br><span class="line">//</span><br><span class="line">//      func FillCache() &#123;</span><br><span class="line">//          // fill a cache from DB</span><br><span class="line">//          // this depends on InitDB having been run</span><br><span class="line">//      &#125;</span><br><span class="line">//</span><br><span class="line">//      // from: yourapp/app/init.go</span><br><span class="line">//      func init() &#123;</span><br><span class="line">//          // set up filters...</span><br><span class="line">//</span><br><span class="line">//          // register startup functions</span><br><span class="line">//          revel.OnAppStart(InitDB)</span><br><span class="line">//          revel.OnAppStart(FillCache)</span><br><span class="line">//      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h2><p>回调方法，对数据处理后 调用 handleInternal ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">		req  = NewRequest(r)</span><br><span class="line">		resp = NewResponse(w)</span><br><span class="line">		c    = NewController(req, resp)</span><br><span class="line">	)   // 生成一个 Req , Res , controller</span><br></pre></td></tr></table></figure>
<p>Filter 看名字感觉是一个过滤机制，对于数据的处理全部都在这个流程  <code>Filters[0](c, Filters[1:])</code></p>
<p>最后根据数据处理的结果到不同的出口，关闭连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if c.Result != nil &#123;</span><br><span class="line">		c.Result.Apply(req, resp)</span><br><span class="line">	&#125; else if c.Response.Status != 0 &#123;</span><br><span class="line">		c.Response.Out.WriteHeader(c.Response.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	// Close the Writer if we can</span><br><span class="line">	if w, ok := resp.Out.(io.Closer); ok &#123;</span><br><span class="line">		w.Close()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/31/Revel-Server-Run/" data-id="cimq51h4f000tbyzlk0o3wfem" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bond-BindTo-实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/30/Bond-BindTo-实现/" class="article-date">
  <time datetime="2016-03-30T09:42:50.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/Bond-BindTo-实现/">Bond-BindTo 实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Bond 对 UIKit 进行了扩展，让我们能更快更方便的操作UI，来看下如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colorObservable = Observable&lt;UIColor&gt;(UIColor.blackColor())</span><br><span class="line">colorObservable.bindTo(textField.bnd_textColor)</span><br><span class="line"></span><br><span class="line">colorObservable.value = UIColor.redColor()</span><br></pre></td></tr></table></figure>
<p>以后只要根据业务逻辑改变 <code>colorObservable.value</code> 就能间接的设置 textField 的textColor 了，包括很常用 的 button.bnd_enabled 功能。</p>
<h2 id="Extension-NSObject"><a href="#Extension-NSObject" class="headerlink" title="Extension NSObject"></a>Extension NSObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public extension NSObject &#123;</span><br><span class="line">  </span><br><span class="line">  internal var bnd_associatedObservables: [String:AnyObject] &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">      return objc_getAssociatedObject(self, &amp;AssociatedKeys.AssociatedObservablesKey) as? [String:AnyObject] ?? [:]</span><br><span class="line">    &#125;</span><br><span class="line">    set(observable) &#123;</span><br><span class="line">      objc_setAssociatedObject(self, &amp;AssociatedKeys.AssociatedObservablesKey, observable, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public func bnd_associatedObservableForValueForKey&lt;T&gt;(key: String, initial: T? = nil, set: (T -&gt; Void)? = nil) -&gt; Observable&lt;T&gt; &#123;</span><br><span class="line">    if let observable: AnyObject = bnd_associatedObservables[key] &#123;</span><br><span class="line">      return observable as! Observable&lt;T&gt;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let observable = Observable&lt;T&gt;(initial ?? self.valueForKey(key) as! T)</span><br><span class="line">      bnd_associatedObservables[key] = observable</span><br><span class="line">      </span><br><span class="line">      observable</span><br><span class="line">        .observeNew &#123; [weak self] (value: T) in</span><br><span class="line">          if let set = set &#123;</span><br><span class="line">            set(value)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if let value = value as? AnyObject &#123;</span><br><span class="line">              self?.setValue(value, forKey: key)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              self?.setValue(nil, forKey: key)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      return observable</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>var bnd_associatedObservables</code>定义了一个 OC 运行时 存储 观察主题 的 Dictionary 。</p>
<p>其次 bnd_associatedObservableForValueForKey 根据 key 直接返回一个存在的观察主题对象 或者 实例化一个新的。</p>
<p>简单看下实例化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;T&gt;(initial ?? self.valueForKey(key) as! T)</span><br><span class="line">bnd_associatedObservables[key] = observable</span><br></pre></td></tr></table></figure>
<ol>
<li>如果有传入初始化的值 则使用初始化值，没有则通过 KVC 取出对应属性的当前值 ； 作为Observable 的初始值。</li>
<li>保存到 bnd_associatedObservables。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">observable</span><br><span class="line">  .observeNew &#123; [weak self] (value: T) in</span><br><span class="line">    if let set = set &#123;</span><br><span class="line">      set(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if let value = value as? AnyObject &#123;</span><br><span class="line">        self?.setValue(value, forKey: key)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        self?.setValue(nil, forKey: key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为刚才的主题对象增加一个Block观察对象（只接收注册后的值）</li>
<li>如果初始化时传入了自定义的set 闭包， 则调用 set。</li>
<li>如果没有传set 则 采用 KVC方式设置key 对应属性的值。</li>
</ol>
<p>所以继承至NSObject的类都能调用此方法，Bond内 扩展 UITextField textColor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var bnd_textColor: Observable&lt;UIColor?&gt; &#123;</span><br><span class="line">  return bnd_associatedObservableForValueForKey(&quot;textColor&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上就能完成开始时的调用。</p>
<p><strong>但是这样Oberservable并没有驱动性，如何才能有驱动性呢？</strong></p>
<h4 id="具有驱动性的"><a href="#具有驱动性的" class="headerlink" title="具有驱动性的"></a>具有驱动性的</h4><h5 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extension NSNotificationCenter &#123;</span><br><span class="line">  </span><br><span class="line">  public func bnd_notification(name: String, object: AnyObject?) -&gt; EventProducer&lt;NSNotification&gt; &#123;</span><br><span class="line">    return EventProducer &#123; sink in</span><br><span class="line">      let subscription = NSNotificationCenter.defaultCenter().addObserverForName(name, object: object, queue: nil, usingBlock: &#123; notification in</span><br><span class="line">        sink(notification)</span><br><span class="line">      &#125;)</span><br><span class="line">      return BlockDisposable &#123;</span><br><span class="line">        NSNotificationCenter.defaultCenter().removeObserver(subscription)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>利用注册 NotificationCenter 的 sink 驱动 EventProducer 分发事件。</li>
<li>dispose 自动移出 observer。</li>
</ol>
<h5 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@objc class UIControlBondHelper: NSObject</span><br><span class="line">&#123;</span><br><span class="line">  weak var control: UIControl?</span><br><span class="line">  let sink: UIControlEvents -&gt; Void</span><br><span class="line">  </span><br><span class="line">  init(control: UIControl, sink: UIControlEvents -&gt; Void) &#123;</span><br><span class="line">    self.control = control</span><br><span class="line">    self.sink = sink</span><br><span class="line">    super.init()</span><br><span class="line">    control.addTarget(self, action: Selector(&quot;eventHandlerTouchDown&quot;), forControlEvents: UIControlEvents.TouchDown)</span><br><span class="line">    ....... </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  func eventHandlerTouchDown() &#123;</span><br><span class="line">    sink(.TouchDown)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .......</span><br><span class="line">    </span><br><span class="line">  deinit &#123;</span><br><span class="line">    control?.removeTarget(self, action: nil, forControlEvents: UIControlEvents.AllEvents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIControl &#123;</span><br><span class="line">	......	</span><br><span class="line">	</span><br><span class="line">      var capturedSink: (UIControlEvents -&gt; Void)! = nil</span><br><span class="line">      </span><br><span class="line">      let bnd_controlEvent = EventProducer&lt;UIControlEvents&gt; &#123; sink in</span><br><span class="line">        capturedSink = sink</span><br><span class="line">        return nil</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      let controlHelper = UIControlBondHelper(control: self, sink: capturedSink)</span><br><span class="line">      </span><br><span class="line">      objc_setAssociatedObject(self, &amp;AssociatedKeys.ControlBondHelperKey, controlHelper, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">      objc_setAssociatedObject(self, &amp;AssociatedKeys.ControlEventKey, bnd_controlEvent, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">      </span><br><span class="line">      .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>产生bnd_controlEvent 观察主题对象，并将驱动 sink 赋值给 capturedSink。</li>
<li>实例化 controlHelper 并将 capturedSink 传递到 helper内的sink， 最后event产生 调用 sink 驱动事件分发。</li>
</ol>
<p>其中UITextField 的 bnd_text 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public var bnd_text: Observable&lt;String?&gt; &#123;</span><br><span class="line">  if let bnd_text: AnyObject = objc_getAssociatedObject(self, &amp;AssociatedKeys.TextKey) &#123;</span><br><span class="line">    return bnd_text as! Observable&lt;String?&gt;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let bnd_text = Observable&lt;String?&gt;(self.text)</span><br><span class="line">    objc_setAssociatedObject(self, &amp;AssociatedKeys.TextKey, bnd_text, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">    </span><br><span class="line">    var updatingFromSelf: Bool = false</span><br><span class="line">    </span><br><span class="line">    bnd_text.observeNew &#123; [weak self] (text: String?) in</span><br><span class="line">      if !updatingFromSelf &#123;</span><br><span class="line">        self?.text = text</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.bnd_controlEvent.filter &#123; $0 == UIControlEvents.EditingChanged &#125;.observe &#123; [weak self, weak bnd_text] event in</span><br><span class="line">      guard let unwrappedSelf = self, let bnd_text = bnd_text else &#123; return &#125;</span><br><span class="line">      updatingFromSelf = true</span><br><span class="line">      bnd_text.next(unwrappedSelf.text)</span><br><span class="line">      updatingFromSelf = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return bnd_text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BindableType"><a href="#BindableType" class="headerlink" title="BindableType"></a>BindableType</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol BindableType &#123;</span><br><span class="line">  typealias Element</span><br><span class="line">  </span><br><span class="line">  /// Returns a sink that can be used to dispatch events to the receiver.</span><br><span class="line">  /// Can accept a disposable that will be disposed on receiver&apos;s deinit.</span><br><span class="line">  func sink(disconnectDisposable: DisposableType?) -&gt; (Element -&gt; Void)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventProducer 实现了 协议 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension EventProducer: BindableType &#123;</span><br><span class="line">  </span><br><span class="line">  /// Creates a new sink that can be used to update the receiver.</span><br><span class="line">  /// Optionally accepts a disposable that will be disposed on receiver&apos;s deinit.</span><br><span class="line">  public func sink(disconnectDisposable: DisposableType?) -&gt; Event -&gt; Void &#123;</span><br><span class="line">    </span><br><span class="line">    if let disconnectDisposable = disconnectDisposable &#123;</span><br><span class="line">      deinitDisposable += disconnectDisposable</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123; [weak self] value in</span><br><span class="line">      self?.next(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释为：被绑定者自己的分发被封装成一个sink 驱动 传出作为返回</strong></p>
<p>再有绑定者的 BindTo 定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// Establishes a one-way binding between the source and the bindable&apos;s sink</span><br><span class="line">/// and returns a disposable that can cancel observing.</span><br><span class="line">public func bindTo&lt;B: BindableType where B.Element == EventType&gt;(bindable: B) -&gt; DisposableType &#123;</span><br><span class="line">  let disposable = SerialDisposable(otherDisposable: nil)</span><br><span class="line">  let sink = bindable.sink(disposable)</span><br><span class="line">  disposable.otherDisposable = observe &#123; value in</span><br><span class="line">    sink(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return disposable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>let sink = bindable.sink(disposable)</code>，接收被绑定都返回的sink。</li>
<li><code>observe { value in sink(value) }</code>，绑定者注册一个Block观察者， 被在事件响应内 调用sink 完成事件链。</li>
</ol>
<h2 id="bidirectionalBindTo"><a href="#bidirectionalBindTo" class="headerlink" title="bidirectionalBindTo"></a>bidirectionalBindTo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public extension EventProducerType where Self: BindableType &#123;</span><br><span class="line">  </span><br><span class="line">  /// Establishes a one-way binding between the source and the bindable&apos;s sink</span><br><span class="line">  /// and returns a disposable that can cancel observing.</span><br><span class="line">  public func bidirectionalBindTo&lt;B: BindableType where B: EventProducerType, B.EventType == Element, B.Element == EventType&gt;(bindable: B) -&gt; DisposableType &#123;</span><br><span class="line">    let d1 = bindTo(bindable)</span><br><span class="line">    let d2 = bindable.bindTo(self)</span><br><span class="line">    return CompositeDisposable([d1, d2])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将两个满足 BindableType 的Observable 进行相互绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obser1 = Observable&lt;String&gt;(&quot;&quot;)</span><br><span class="line">let obser2 = Observable&lt;String&gt;(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">obser1.bidirectionalBindTo(obser2)</span><br></pre></td></tr></table></figure>
<h4 id="Quertion"><a href="#Quertion" class="headerlink" title="?Quertion"></a>?Quertion</h4><p>相互绑定根据上面的定义不会产生无限相互调用吗？</p>
<p>直接从 bindTo 来看，无论如何都没有解决 这个潜在会存在的问题。</p>
<p>解决问题的代码在 EventProducer.swift 的 dispatchNext 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private func dispatchNext(event: Event) &#123;</span><br><span class="line">  guard !isDispatchInProgress else &#123; return &#125;</span><br><span class="line">  </span><br><span class="line">  lock.lock()</span><br><span class="line">  isDispatchInProgress = true</span><br><span class="line">  for (_, send) in observers &#123;</span><br><span class="line">    send(event)</span><br><span class="line">  &#125;</span><br><span class="line">  isDispatchInProgress = false</span><br><span class="line">  lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isDispatchInProgress 让正在分发事件的对象，不再分发其它事件。。。这里会不会漏掉一部分事件呢？对于这里的加锁，需要再仔细考虑一下</p>
<ol>
<li>obser1 内存地址 –0670， obser2 内存地址 –1ff0</li>
<li><code>obser1.value = &quot;123&quot;</code>, 驱动事件 </li>
<li>obser1 –0670 先进入 <code>dispatchNext(event: Event) // event &quot;123&quot;</code> 并进入for 分发</li>
<li>obser2 –1ff0 进入 <code>dispatchNext(event: Event) // event &quot;123&quot;</code>  并进入 for 分发</li>
<li>obser1 –0670 再次进入 <code>dispatchNext(event: Event) // event &quot;123&quot;</code> 直接 return 停止二次到来事件分发</li>
<li>obser2 –1ff0 先完成分发 并结束 dispatchNext。</li>
<li>obser1 –0670 完成颁发 并结束 dispatchNext。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/30/Bond-BindTo-实现/" data-id="cimq51h380004byzlqzj9wjac" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pattern/">Pattern</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Pattern/" style="font-size: 17.5px;">Pattern</a> <a href="/tags/Swift/" style="font-size: 20px;">Swift</a> <a href="/tags/iOS/" style="font-size: 12.5px;">iOS</a> <a href="/tags/后端/" style="font-size: 20px;">后端</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
          </li>
        
          <li>
            <a href="/2016/04/06/责任链/">责任链</a>
          </li>
        
          <li>
            <a href="/2016/04/05/Unicode-UFT8-概记/">Unicode_UFT8_概记</a>
          </li>
        
          <li>
            <a href="/2016/04/04/Revel-Filter-Chain/">Revel Filter Chain</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 天晷<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>