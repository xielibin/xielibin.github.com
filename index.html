<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>天晷</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="天晷">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="天晷">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天晷">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="天晷" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天晷</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">脑容量有限，清理出来装灵感吧！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ViewController3-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/22/ViewController3-PG/" class="article-date">
  <time datetime="2016-04-22T08:55:31.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/ViewController3-PG/">ViewController3-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自适应模式"><a href="#自适应模式" class="headerlink" title="自适应模式"></a>自适应模式</h2><p>自适应的应用界面表现最合适的方式使用可用的界面空间，支持自适应表现为针对任意的iOS设备将自动调整内容布局。采用自适应技术能够用少量的代码将应用适配到不同尺寸的设备上。</p>
<p>Auto Layout是构建自适应界面的重要工具。使用自动布局定义约束规则管理控制器的视图结构，可以通过IB或者代码创建约束规则。当父视图的尺寸发生变化，iOS系统自动根据约束条件调整相应的视图。</p>
<p>Traits是自适应界面模式的另一个重要组件，traits描述视图控制器和视图当前运行所处的环境，traits将界面描述抽象成更高层的描述方式。</p>
<h4 id="The-Role-of-Traits"><a href="#The-Role-of-Traits" class="headerlink" title="The Role of Traits"></a>The Role of Traits</h4><p>视图控制器有多种时机改变界面布局，单独使用线束不能满足布局管理。视图控制器、视图、其它对象管理一组当前环境特定的特性到关联的对象上。下表描述了特定的trait对界面的影响：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/vc_PG_T12_1.jpg" alt="vc_PG_T12_1"></p>
<p>关于使用trait的建议：</p>
<ol>
<li>使用size classes技术作为界面特性改变很大时检测布局。</li>
<li>不应该假定size classes下视图的某个特性关联特定的高度或者宽度。</li>
<li>使用IB为不同的size classes适当的指定不同的布局约束。</li>
<li>避免使用idiom信息作为界面布局的决定因素。</li>
</ol>
<h4 id="When-Do-Trait-and-Size-Changes-Happen"><a href="#When-Do-Trait-and-Size-Changes-Happen" class="headerlink" title="When Do Trait and Size Changes Happen?"></a>When Do Trait and Size Changes Happen?</h4><p>Trait不会频繁发生变化，但是它还是会发生。Size class发生变化的主要原因如下：</p>
<ol>
<li>由于设备发生旋转，导致视图控制器对应window改变引起视图控制器的水平或者垂直方向的size class改变。</li>
<li>由于容器视图控制器的水平或者垂直方向的size class改变引起。</li>
<li>子视图控制器的水平或者垂直方向的size class明确的被其父视图控制器改变。</li>
</ol>
<p>Size class改变会沿着VC层次结构传播到底层的子视图控制器。Window作为整个视图层次结构的根，向root VC提供基准size class traits。当设备方向发生改变时，window改变自身特性并沿着控制器层次结构传播。<strong>容器控制器能直接改变或者复写子视图控制器的特性</strong>。</p>
<p>在iOS8及之后，window的origin总是upper-left，当设备方向发生改变时window改变bounds。window传播size class改变到子视图控制器，每个视图控制器调用以下方法：</p>
<ol>
<li>willTransitionToTraitCollection:withTransitionCoordinator:告知子视图控制器特性将要改变。</li>
<li>viewWillTransitionToSize:withTransitionCoordinator: 告知子视图控制器视图大小将要改变。</li>
<li>traitCollectionDidChange:告知关联的子视图控制器，特性已经改变。</li>
</ol>
<p>UIKit框架只会在size class发生改变时才会进行报告。<strong>当一个容器视图控制器复写了子视图控制器的size class，则该子视图控制器在父VC的size class改变时不会被通知。同时，当一个视图控制器的视图有固定的长度或者宽度时，也不会收到size class改变的通知</strong>。</p>
<p>下图表明了整个通知过程的时机变化：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/vc_PG_F12_2.jpg" alt="vc_PG_F12_2"></p>
<h4 id="设备默认的Size-Class特性"><a href="#设备默认的Size-Class特性" class="headerlink" title="设备默认的Size Class特性"></a>设备默认的Size Class特性</h4><p>如下图：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/vc_PG_T12_2.jpg" alt="vc_PG_T12_2.jpg"></p>
<h2 id="构建自适应界面"><a href="#构建自适应界面" class="headerlink" title="构建自适应界面"></a>构建自适应界面</h2><p>自适应界面需要同时响应trait与size的改变。在视图控制器层面，应用大致的对内容进行布局，根据不同的size class进行布局。在界面大局确定之后，根据size大小对内容做更精细的布局。</p>
<h4 id="Adapting-to-Trait-Changes"><a href="#Adapting-to-Trait-Changes" class="headerlink" title="Adapting to Trait Changes"></a>Adapting to Trait Changes</h4><ol>
<li>应用应该使用StoryBoard针对不同的trait进行粗糙布局。</li>
<li>使用Image asset配置不同的图片。</li>
</ol>
<h4 id="改变子视图控制器Trait"><a href="#改变子视图控制器Trait" class="headerlink" title="改变子视图控制器Trait"></a>改变子视图控制器Trait</h4><p>子视图控制器默认继承父视图控制器的Trait。VC可以调用 setOverrideTraitCollection:forChildViewController:方法对子VC的Trait进行复写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UITraitCollection* horizTrait = [UITraitCollection</span><br><span class="line">                 traitCollectionWithHorizontalSizeClass:UIUserInterfaceSizeClassRegular];</span><br><span class="line">UITraitCollection* vertTrait = [UITraitCollection</span><br><span class="line">                 traitCollectionWithVerticalSizeClass:UIUserInterfaceSizeClassCompact];</span><br><span class="line">UITraitCollection* childTraits = [UITraitCollection</span><br><span class="line">                 traitCollectionWithTraitsFromCollections:@[horizTrait, vertTrait]];</span><br><span class="line"> </span><br><span class="line">[self setOverrideTraitCollection:childTraits forChildViewController:self.childViewControllers[0]];</span><br></pre></td></tr></table></figure>
<p><strong>当父视图控制器Trait改变时，子VC继承没有被明确复写的Trait。其中被明确复写的Trait不变</strong>。</p>
<h4 id="Adapting-Presented-View-Controllers-to-a-New-Style"><a href="#Adapting-Presented-View-Controllers-to-a-New-Style" class="headerlink" title="Adapting Presented View Controllers to a New Style"></a>Adapting Presented View Controllers to a New Style</h4><p>被呈现的视图控制器自动适应水平或者垂直环境因素。但部分情况，直接使用默认的呈现方式会存在问题。所以要改变默认的presentation style，为presentation controller对象设置代理，可以根据需要提供改变presentation style或者选用其它的VC代替显示。</p>
<ol>
<li>使用代理的 adaptivePresentationStyleForPresentationController:方法改变呈现方式。</li>
<li>如果要替换被呈现的视图控制器，则使用代理的presentationController:viewControllerForAdaptivePresentationStyle:方法。</li>
</ol>
<h6 id="适配Popover建议"><a href="#适配Popover建议" class="headerlink" title="适配Popover建议"></a>适配Popover建议</h6><ol>
<li>将Popover视图控制器Push到已存在的导航堆栈里。</li>
<li>增加控制器用于在全屏模式下让Popover视图控制器消失。</li>
<li>使用presentation视图控制器代理消除任何的适配改变。</li>
</ol>
<h4 id="响应尺寸大小改变"><a href="#响应尺寸大小改变" class="headerlink" title="响应尺寸大小改变"></a>响应尺寸大小改变</h4><p>尺寸改变主要的原因如下：</p>
<ol>
<li>设备旋转引起window变化。</li>
<li>父视图控制器调整子视图控制器的大小。</li>
<li>presentation controller调整被呈现的视图控制器大小。</li>
</ol>
<p>当视图尺寸大小改变，UIKit框架通过正常的布局处理流程更新视图的大小和位置。如果使用Auto Layout约束布局，应用自动根据各种变化调整。</p>
<p>如果Auto Layout约束不能满足布局的需要，还可以在viewWillTransitionToSize:withTransitionCoordinator: 方法内调整布局。同时，当设备发生旋转时，也可用 transition coordinator的targetTransform属性创建对应旋转的界面效果。</p>
<p>官方链接：<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/TheAdaptiveModel.html#//apple_ref/doc/uid/TP40007457-CH19-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/TheAdaptiveModel.html#//apple_ref/doc/uid/TP40007457-CH19-SW1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/22/ViewController3-PG/" data-id="cinbsbv9i001dsgzl5tzzm6sz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ViewController2-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/21/ViewController2-PG/" class="article-date">
  <time datetime="2016-04-21T15:07:24.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/ViewController2-PG/">ViewController2-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Customizing-the-Transition-Animations"><a href="#Customizing-the-Transition-Animations" class="headerlink" title="Customizing the Transition Animations"></a>Customizing the Transition Animations</h2><p>过渡动画提供应用界面变化可视化反馈。UIKit框架提供标准的过渡动画方式用于呈现VC，程序内也可以自定义过渡作为标准过渡的补充。</p>
<h4 id="The-Transition-Animation-Sequence"><a href="#The-Transition-Animation-Sequence" class="headerlink" title="The Transition Animation Sequence"></a>The Transition Animation Sequence</h4><p>过渡动画交换两个视图控制器视图内容，有两种类型的过渡：呈现和消失。</p>
<p>实现过渡动画需要抓取相关的对象信息，UIKit框架提供包含在过渡动画内所有对象的默认信息，可以在应用内自定义全部或者部分对象。如果选择合适的对象组合，则只需要编写少量的代码就能实现过渡动画。</p>
<h6 id="Transitioning-Delegate"><a href="#Transitioning-Delegate" class="headerlink" title="Transitioning Delegate"></a>Transitioning Delegate</h6><p>Transitioning Delegate是过渡动画与自定义呈现的起动点。代理对象需要实现UIViewControllerTransitioningDelegate协议，并向UIKit框架提供以下信息对象：</p>
<ol>
<li>Animator objects：用于创建显示和消失视图控制器视图的动画，需要符合UIViewControllerAnimatedTransitioning协议。</li>
<li>Interactive animator objects：用于驱动自定义动画时间曲线，需要符合UIViewControllerInteractiveTransitioning协议。<strong>比较简便的方式是继承UIPercentDrivenInteractiveTransition，实现相应的事件处理即可</strong>。</li>
<li>Presentation controller：用于管理视图控制器在屏幕上的呈现方式。</li>
</ol>
<p>给视图控制器的 transitioningDelegate属性设置代理对象，告诉UIKit框架应用需要执行自定义过渡或者呈现方式。代理可以决定需要提供哪些对象，如果没有提供animator对象，UIKit框架使用由视图控制器 modalTransitionStyle属性提供的标准的过渡动画。</p>
<h6 id="Custom-Animation-Sequence"><a href="#Custom-Animation-Sequence" class="headerlink" title="Custom Animation Sequence"></a>Custom Animation Sequence</h6><p>当presented VC的transitioningDelegate属性提供一个有效的对象，UIKit框架则用自定义的动画呈现VC。UIKit框架调用 animationControllerForPresentedController:presentingController:sourceController:方法检索一个自定义的animator对象，如果有一个可用的对象，则按照以下流程执行：</p>
<ol>
<li>UIKit框架调用代理对象的interactionControllerForPresentation:方法，查看是否提供交互animator对象，如果没有提供相应对象，则框架采用非交互的动画驱动方式。</li>
<li>UIKit框架调用animator对象的 transitionDuration:方法获取动画执行时间。</li>
<li>UIKit框架调用适当的方法开始执行动画：（a）对象非交互式方式，调用animator对象的animateTransition:方法。（b）对交互方式，调用提供的交互对象的startInteractiveTransition:方式。</li>
<li>UIKit框架等待animator对象调用过渡上下文对象的 completeTransition:方法。<strong>当animator对象执行完成，则必须调用些方法，使用框架能够处理presentViewController:animated:completion:方法的completion内容</strong>。</li>
</ol>
<p>当消失一个视图控制器时，UIKit框架调用代理对象animationControllerForDismissedController:方法获取animator对象，并执行以下步骤：</p>
<ol>
<li>UIKit框架调用代理对象的interactionControllerForDismissal:方法，查看是否提供交互animator对象，如果没有提供相应对象，则框架采用非交互的动画驱动方式。</li>
<li>UIKit框架调用animator对象的 transitionDuration:方法获取动画执行时间。</li>
<li>UIKit框架调用适当的方法开始执行动画：（a）对象非交互式方式，调用animator对象的animateTransition:方法。（b）对交互方式，调用提供的交互对象的startInteractiveTransition:方式。</li>
<li>UIKit框架等待animator对象调用过渡上下文对象的 completeTransition:方法。<strong>当animator对象执行完成，则必须调用些方法，使用框架能够处理presentViewController:animated:completion:方法的completion内容</strong>。</li>
</ol>
<h6 id="Transitioning-Context-Object"><a href="#Transitioning-Context-Object" class="headerlink" title="Transitioning Context Object"></a>Transitioning Context Object</h6><p>在开始执行过渡动画之前，UIKit框架创建一个过渡上下文对象，并设置执行动画的相关信息。该对象实现了UIViewControllerContextTransitioning协议，包含了执行动画需要的必要信息。下图显示了上下文对象引用的对象信息：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/vc_PG_F10_2.jpg" alt="vc_PG_F10_2"></p>
<h6 id="Transition-Coordinator"><a href="#Transition-Coordinator" class="headerlink" title="Transition Coordinator"></a>Transition Coordinator</h6><p>对于内置或者自定义的过渡动画，UIKit框架创建了一个过渡时的协调器对象触发一些需要执行的附加动画。除了呈现或者消失视图控制器，当屏幕发生旋转或者VC尺寸发生变化也会引起transitions。此类的transitions主要是改变视图层次结构显示，跟踪变化并使用动画反馈给用户。transition coordinator对象只存在于过渡期间，通过被影响的VC的transitionCoordinator属性获得对象，对象实现UIViewControllerTransitionCoordinatorContext协议。对象引用的对象信息如下：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/vc_PG_F10_3.jpg" alt="vc_PG_F10_3"></p>
<h4 id="Presenting-a-View-Controller-Using-Custom-Animations"><a href="#Presenting-a-View-Controller-Using-Custom-Animations" class="headerlink" title="Presenting a View Controller Using Custom Animations"></a>Presenting a View Controller Using Custom Animations</h4><p>用自定义动画实现视图控制器的呈现，按照以下流程执行：</p>
<ol>
<li>创建一个视图控制器。</li>
<li>创建一个过渡代理对象赋值给被呈现的视图控制器的transitioningDelegate属性。代理对象的对应方法需要创建并返回animator对象。</li>
<li>最后调用presentViewController:animated:completion:方法。</li>
</ol>
<h4 id="Implementing-the-Transitioning-Delegate"><a href="#Implementing-the-Transitioning-Delegate" class="headerlink" title="Implementing the Transitioning Delegate"></a>Implementing the Transitioning Delegate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)</span><br><span class="line">    animationControllerForPresentedController:(UIViewController *)presented</span><br><span class="line">                         presentingController:(UIViewController *)presenting</span><br><span class="line">                             sourceController:(UIViewController *)source &#123;</span><br><span class="line">    MyAnimator* animator = [[MyAnimator alloc] init];</span><br><span class="line">    return animator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Animator-Objects"><a href="#Animator-Objects" class="headerlink" title="Animator Objects"></a>Animator Objects</h4><p>Animator Objects是一个任意实现了 UIViewControllerAnimatedTransitioning协议的对象。该对象创建一个固定时间周期的动画。其中animateTransition:方法需要负责实现：（a）获取动画需要的参数信息。（b）使用Core Anination或者UIView动画方法实现动画。（c）动画完成后清理。</p>
<h6 id="Getting-the-Animation-Parameters"><a href="#Getting-the-Animation-Parameters" class="headerlink" title="Getting the Animation Parameters"></a>Getting the Animation Parameters</h6><ol>
<li>调用viewControllerForKey: 方法使用“from”或者“to”关键字获取上下文里的VC。</li>
<li>调用containerView方法获取动画执行的父视图。</li>
<li>调用viewForKey:方法获取视图对象。</li>
<li>调用finalFrameForViewController:方法获取视图对象的最后位置信息。</li>
</ol>
<h6 id="Creating-the-Transition-Animations"><a href="#Creating-the-Transition-Animations" class="headerlink" title="Creating the Transition Animations"></a>Creating the Transition Animations</h6><p>设置代理代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController : UIViewControllerTransitioningDelegate &#123;</span><br><span class="line">    @objc private func buttonTouched(sender : UIButton) &#123;</span><br><span class="line">        let presentedVC = PresentedViewController()</span><br><span class="line">        presentedVC.transitioningDelegate = self</span><br><span class="line">        self.presentViewController(presentedVC, animated: true, completion: nil)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">        animator.presenting = true</span><br><span class="line">        return animator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">        animator.presenting = false</span><br><span class="line">        return animator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Animator代码如下：<br><strong>在编写代码时要注意，改变索引对象的值；dismiss时toViewStartFrame是（0，0，0，0），按照官方文档实现会消失后，会导致toView不显示</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class PreAnimator: NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    var presenting : Bool = false</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        let containerView = transitionContext.containerView()!</span><br><span class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</span><br><span class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</span><br><span class="line">        </span><br><span class="line">        let toView = transitionContext.viewForKey(UITransitionContextToViewKey)!</span><br><span class="line">        let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)!</span><br><span class="line">        </span><br><span class="line">        let containerFrame = containerView.frame</span><br><span class="line">        var toViewStartFrame = transitionContext.initialFrameForViewController(toVC)</span><br><span class="line">        let toViewFinalFrame = transitionContext.finalFrameForViewController(toVC)</span><br><span class="line">        var fromViewFinalFrame = transitionContext.finalFrameForViewController(fromVC)</span><br><span class="line">        </span><br><span class="line">        if presenting &#123;</span><br><span class="line">            toViewStartFrame.origin.x = containerFrame.size.width</span><br><span class="line">            toViewStartFrame.origin.y = containerFrame.size.height</span><br><span class="line">            containerView.insertSubview(toView, aboveSubview: fromView)  //此处改动</span><br><span class="line">            toView.frame = toViewStartFrame  //此处改动</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fromViewFinalFrame = CGRectMake(containerFrame.width, containerFrame.height, toView.frame.width, toView.frame.height)</span><br><span class="line">            containerView.insertSubview(toView, belowSubview: fromView)  //此处改动</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        UIView.animateWithDuration(self.transitionDuration(transitionContext), animations: &#123;</span><br><span class="line">            if self.presenting &#123;</span><br><span class="line">                toView.frame = toViewFinalFrame</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fromView.frame = fromViewFinalFrame</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;) &#123; (finished) in</span><br><span class="line">                let success = !transitionContext.transitionWasCancelled()</span><br><span class="line">                </span><br><span class="line">                if (self.presenting &amp;&amp; !success) || (!self.presenting &amp;&amp; success) &#123;</span><br><span class="line">                    toView.removeFromSuperview()</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                transitionContext.completeTransition(success)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Adding-Interactivity-to-Your-Transitions"><a href="#Adding-Interactivity-to-Your-Transitions" class="headerlink" title="Adding Interactivity to Your Transitions"></a>Adding Interactivity to Your Transitions</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class PercentAnimator: UIPercentDrivenInteractiveTransition &#123;</span><br><span class="line">    var context : UIViewControllerContextTransitioning!</span><br><span class="line">    </span><br><span class="line">    override func startInteractiveTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        super.startInteractiveTransition(transitionContext)</span><br><span class="line">        </span><br><span class="line">        context = transitionContext</span><br><span class="line">        </span><br><span class="line">        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(self.handleSwipeUpdate(_:)))</span><br><span class="line">        panGesture.maximumNumberOfTouches = 1</span><br><span class="line">        </span><br><span class="line">        transitionContext.containerView()?.addGestureRecognizer(panGesture)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func handleSwipeUpdate(sender : UIPanGestureRecognizer) &#123;</span><br><span class="line">        let container = context.containerView()!</span><br><span class="line">        </span><br><span class="line">        switch sender.state &#123;</span><br><span class="line">        case .Began:</span><br><span class="line">            sender.setTranslation(CGPointMake(0, 0), inView: container)</span><br><span class="line">        case .Changed:</span><br><span class="line">            let point = sender.translationInView(container)</span><br><span class="line">            </span><br><span class="line">            let per = point.x / CGRectGetWidth(container.bounds)</span><br><span class="line">            self.updateInteractiveTransition(per)</span><br><span class="line">            print(per)</span><br><span class="line">        case .Ended:</span><br><span class="line">            self.finishInteractiveTransition()</span><br><span class="line">            container.removeGestureRecognizer(sender)</span><br><span class="line">        default:</span><br><span class="line">            self.cancelInteractiveTransition()</span><br><span class="line">            container.removeGestureRecognizer(sender)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Creating-Animations-that-Run-Alongside-a-Transition"><a href="#Creating-Animations-that-Run-Alongside-a-Transition" class="headerlink" title="Creating Animations that Run Alongside a Transition"></a>Creating Animations that Run Alongside a Transition</h6><p>视图控制器在执行transition的过程中，有可能需要调整自身的视图层次结构，或者调用动画给予界面可视反馈。在transition过程中会存在一个transition coordinator对象，通过视图控制器transitionCoordinator属性获取，调用对象 animateAlongsideTransition:completion: or animateAlongsideTransitionInView:animation:completion:方法创建动画。</p>
<h2 id="Creating-Custom-Presentations"><a href="#Creating-Custom-Presentations" class="headerlink" title="Creating Custom Presentations"></a>Creating Custom Presentations</h2><p>UIKit框架分离视图控制器的内容呈现和展示在屏幕上两个部分。底层的presentation controller对象管理被呈现的视图控制器，该控制器对象还管理视图控制器的视图呈现方式，presentation controller对象可能负责的任务：</p>
<ol>
<li>设置被呈现的视图控制器的大小。</li>
<li>添加自定义的视图用于改变被呈现内容的可视效果。</li>
<li>提供自定义视图的过渡动画。</li>
<li>当应用的当前状态环境发生变化时presentation起到适配的可视效果作用。</li>
</ol>
<h4 id="Custom-Presentation-Process"><a href="#Custom-Presentation-Process" class="headerlink" title="Custom Presentation Process"></a>Custom Presentation Process</h4><p>当呈现的视图控制器presentation方式被设置为UIModalPresentationCustom时，UIKit框架寻找自定义的presentation控制器管理呈现过程。</p>
<p>presentation控制器伴随着过渡效果整个过程，animator对象操作视图控制器内容的动画，而presentation控制器操作其它的操作。被animator对象操作的视图可以通过复写presentedView()方法改变。</p>
<p>presentation呈现过程：</p>
<ol>
<li>调用过渡代理对象presentationControllerForPresentedViewController:presentingViewController:sourceViewController:取得自定义的presentation控制器。</li>
<li>寻问过渡代理对象的animator和interactive animater对象。</li>
<li>调用presentation控制器 presentationTransitionWillBegin方法。<strong>可以在该方法内添加自定义的视图，设置视图层次结构</strong></li>
<li>调用presentedView()方法获取由animator对象操作的视图。<strong>默认情况下，返回的是被呈现视图控制器的根视图。程序也可以自定义其它视图，但是必须将被呈现的视图控制器的根视图合成到视图层次结构中</strong>。</li>
<li>执行过渡动画。在此过程中UIKit框架会调用containerViewWillLayoutSubviews and containerViewDidLayoutSubviews方法让presentation控制器可以布局自定义视图。</li>
<li>调用 presentationTransitionDidEnd:方法。</li>
</ol>
<p>消失过程：</p>
<ol>
<li>从当前可视的视图控制器获取presentation控制器。</li>
<li>寻问过渡代理对象的animator和interactive animater对象。</li>
<li>调用presentation控制器 presentationTransitionWillBegin方法。<strong>可以在该方法内添加自定义的视图，设置视图层次结构</strong>。</li>
<li>调用presentedView()方法获取由animator对象操作的视图。</li>
<li>执行过渡动画。在此过程中UIKit框架会调用containerViewWillLayoutSubviews and containerViewDidLayoutSubviews方法让presentation控制器可以布局自定义视图。</li>
<li>调用 presentationTransitionDidEnd:方法。</li>
</ol>
<p><strong>在处理过程中， frameOfPresentedViewInContainerView and presentedView方法可能会被多次调用，方法应该尽快完成处理</strong></p>
<h4 id="Creating-a-Custom-Presentation-Controller"><a href="#Creating-a-Custom-Presentation-Controller" class="headerlink" title="Creating a Custom Presentation Controller"></a>Creating a Custom Presentation Controller</h4><p>设置启动需要的步骤，可以采用内置的过渡动画；由于在呈现时UITransitionContextFromViewKey和消失时UITransitionContextToViewKey对应的值都为nil，所以记录一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@objc private func buttonTouched(sender : UIButton) &#123;</span><br><span class="line">    let presentedVC = PresentedViewController()</span><br><span class="line">    presentedVC.transitioningDelegate = self</span><br><span class="line">    presentedVC.modalPresentationStyle = .Custom</span><br><span class="line">    self.presentViewController(presentedVC, animated: true, completion: nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">    return PreCPAnimator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">    animator.presenting = false</span><br><span class="line">    return PreCDAnimator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func presentationControllerForPresentedViewController(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController) -&gt; UIPresentationController? &#123;</span><br><span class="line">    let presentation = CustomPresentationController(presentedViewController: presented, presentingViewController: presenting)</span><br><span class="line">    </span><br><span class="line">    return presentation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">class CustomPresentationController: UIPresentationController &#123;</span><br><span class="line">    </span><br><span class="line">    let dimmingView : UIView</span><br><span class="line">    </span><br><span class="line">    override init(presentedViewController: UIViewController, presentingViewController: UIViewController) &#123;</span><br><span class="line">        dimmingView = UIView()</span><br><span class="line">        dimmingView.backgroundColor = UIColor.init(white: 0.0, alpha: 0.4)</span><br><span class="line">        dimmingView.alpha = 0.0</span><br><span class="line">        </span><br><span class="line">        super.init(presentedViewController: presentedViewController, presentingViewController: presentingViewController)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func frameOfPresentedViewInContainerView() -&gt; CGRect &#123;</span><br><span class="line">        let bounds = self.containerView!.bounds</span><br><span class="line">        </span><br><span class="line">        return CGRectInset(bounds, 30, 30)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func presentationTransitionWillBegin() &#123;</span><br><span class="line">        let containerView = self.containerView!</span><br><span class="line">        </span><br><span class="line">        dimmingView.frame = containerView.bounds</span><br><span class="line">        dimmingView.alpha = 0.0</span><br><span class="line">        </span><br><span class="line">        containerView.insertSubview(dimmingView, atIndex: 0)</span><br><span class="line">        </span><br><span class="line">        if let coordinator = presentedViewController.transitionCoordinator() &#123;</span><br><span class="line">            coordinator.animateAlongsideTransition(&#123; (context) in</span><br><span class="line">                self.dimmingView.alpha = 1.0</span><br><span class="line">                &#125;, completion: nil)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dimmingView.alpha = 1.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func dismissalTransitionWillBegin() &#123;</span><br><span class="line">        if let coordiantor = presentedViewController.transitionCoordinator() &#123;</span><br><span class="line">            coordiantor.animateAlongsideTransition(&#123; (context) in</span><br><span class="line">                self.dimmingView.alpha = 0.0</span><br><span class="line">                &#125;, completion: nil)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dimmingView.alpha = 0.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func dismissalTransitionDidEnd(completed: Bool) &#123;</span><br><span class="line">        if completed &#123;</span><br><span class="line">            dimmingView.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PreCPAnimator: NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        let containerView = transitionContext.containerView()!</span><br><span class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</span><br><span class="line">        </span><br><span class="line">        let toView = transitionContext.viewForKey(UITransitionContextToViewKey)!</span><br><span class="line">        </span><br><span class="line">        let containerFrame = containerView.frame</span><br><span class="line">        var toViewStartFrame = transitionContext.initialFrameForViewController(toVC)</span><br><span class="line">        let toViewFinalFrame = transitionContext.finalFrameForViewController(toVC)</span><br><span class="line">        </span><br><span class="line">        toViewStartFrame.origin.x = containerFrame.size.width</span><br><span class="line">        toViewStartFrame.origin.y = containerFrame.size.height</span><br><span class="line">        containerView.addSubview(toView)</span><br><span class="line">        toView.frame = toViewStartFrame</span><br><span class="line">        </span><br><span class="line">        UIView.animateWithDuration(self.transitionDuration(transitionContext), animations: &#123;</span><br><span class="line">            toView.frame = toViewFinalFrame</span><br><span class="line">        &#125;) &#123; (finished) in</span><br><span class="line">            let success = !transitionContext.transitionWasCancelled()</span><br><span class="line">            </span><br><span class="line">            transitionContext.completeTransition(success)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PreCDAnimator: NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    var presenting : Bool = false</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</span><br><span class="line">        </span><br><span class="line">        let containerView = transitionContext.containerView()!</span><br><span class="line">        let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)!</span><br><span class="line">        </span><br><span class="line">        let containerFrame = containerView.frame</span><br><span class="line">        var fromViewFinalFrame = transitionContext.finalFrameForViewController(fromVC)</span><br><span class="line">        </span><br><span class="line">        fromViewFinalFrame.origin.x = containerFrame.width</span><br><span class="line">        fromViewFinalFrame.origin.y = containerFrame.height</span><br><span class="line">        </span><br><span class="line">        UIView.animateWithDuration(self.transitionDuration(transitionContext), animations: &#123;</span><br><span class="line">            fromView.frame = fromViewFinalFrame</span><br><span class="line">        &#125;) &#123; (finished) in</span><br><span class="line">            let success = !transitionContext.transitionWasCancelled()</span><br><span class="line">            </span><br><span class="line">            transitionContext.completeTransition(success)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/21/ViewController2-PG/" data-id="cinbsbv9n001hsgzl1n895sqh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ViewController-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/20/ViewController-PG/" class="article-date">
  <time datetime="2016-04-20T02:06:06.000Z" itemprop="datePublished">2016-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/20/ViewController-PG/">ViewController-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>view Controllers作为应用的结构基础，每个VC管理应用的用户界面并且管理界面与底层数据的交互，同时负责处理用户界面之间的过渡。</p>
<p>有两种类型的VC：1.承载内容VC：作为主要的VC类型，管理应用的内容呈现。2.容器VC：集合子VC的信息，协调子VC的切换与呈现。</p>
<h2 id="VC担当角色"><a href="#VC担当角色" class="headerlink" title="VC担当角色"></a>VC担当角色</h2><p>VC定义方法和属性管理界面视图、处理事件、负责视图之间切换、协调不同应用不同部分。应用继承UIViewController添加自定义的代码实现定制行为。</p>
<h4 id="View管理"><a href="#View管理" class="headerlink" title="View管理"></a>View管理</h4><p>负责管理view层次结构，每个VC有一个根视图用于添加需要显示的子内容视图。VC一直引用根视图，根视图对每一个添加的子视图都是强引用。</p>
<p>内容VC管理根视图内全部的子视图。容器VC仅管理自身的根视图和全部子VC的根视图。容器VC只对子VC的根视图位置和大小进行管理，子VC的内容全部由相应的VC控制管理。</p>
<h4 id="数据配置"><a href="#数据配置" class="headerlink" title="数据配置"></a>数据配置</h4><p>VC在管理的视图与应用的数据之间扮演一个中介者的作用。UIViewController的属性和方法用管理应用的内容呈现，当我们继承UIViewController使用时，添加适当的变量对数据进行管理。同时，在VC内我们必须保持数据对象与VC关系的独立性。大概关系如下：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/vc_PG_F1_3.jpg" alt="vc_PG_F1_3"></p>
<h4 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h4><p>虽然VC作为一个响应者对象，并且有能力处理从响应都链传递过来的事件，但是VC一般情况下是不会直接处理的。相反地，由视图处理相应的事件，并用delegate或者target-Action的方法转化成处理方法。</p>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><p>在VC里，几乎所有的资源都是自动管理的，对于一部分由程序代码创建的资源，需要由程序代码进行控制释放。</p>
<p>当内存收到内存告警时，需要对不使用或者能够重新创建的资源进行释放，避免因为内存的原因造成程序Crash。</p>
<h4 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h4><p>VC的职责是负责呈现视图内容，并且根据底层的环境适配内容的呈现。每个应用都应该能够运行在不同尺寸的iOS设备上。为了避免在不同的设备上运行不同的VC进行控制显示，我们应该使用一个VC根据空间的变化进行适配。</p>
<p>在iOS系统中，应用需要处理两种类型的变化：粗粒度（底层特性）和细粒度（视图尺寸）。iOS布局给VC定义了两个重要的特性：水平和垂直的size classes，用来表明VC在不同的维度上的空间使用情况。旋转设备可能会引起特性（traits）的变化，也有可能引起细粒度的变化。应用程序需要根据特性的变化，适配合适的布局。</p>
<h2 id="VC层次结构"><a href="#VC层次结构" class="headerlink" title="VC层次结构"></a>VC层次结构</h2><p>VC视图间的关系定义了不同VC之间的行为。我们应该按照UIKit框架定义的方式使用VC，保持VC间适当的关联关系，以保证正确的事件行为能够自动分发到指定的VC上。如果打破了预定义的行为或者呈现内容方式，应用可能会出现未定义的行为。</p>
<h4 id="Root-VC"><a href="#Root-VC" class="headerlink" title="Root VC"></a>Root VC</h4><p>根VC是作为整个VC层次结构的锚点。每个window都需要指定一个根控制器，让其根视图填充整个内容区域。</p>
<h4 id="容器VC"><a href="#容器VC" class="headerlink" title="容器VC"></a>容器VC</h4><p>容器VC让应用合成其它管理或者重用单元生成复杂的用户界面。一个容器控制器将子视图控制器的内容混合在一起形成最终的界面。UIKit框架预定义的容器控制器： UINavigationController, UISplitViewController, and UIPageViewController。</p>
<h4 id="Presented-控制器"><a href="#Presented-控制器" class="headerlink" title="Presented 控制器"></a>Presented 控制器</h4><p>Presented VC都采用模态的方式展现新的内容。通常是隐藏之前的内容，呈现的内容替换当前正在展示的VC的内容。</p>
<p><strong>当呈现一个VC时，UIKit框架会在presenting VC和presented VC建立关联关系</strong>。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li>尽可能使用框架定义的VC</li>
<li>保持不同的VC之间相互独立，不应该让不同的VC涉及或者管理其它VC的内容和状态。如果有VC间的交互，应该采用delegate等机制进行状态隔离。</li>
<li>将VC的根视图作为其它视图的容器进行使用。</li>
<li>清楚数据的生命周期。</li>
<li>适配不同的设备。</li>
</ol>
<h2 id="定义子控制器"><a href="#定义子控制器" class="headerlink" title="定义子控制器"></a>定义子控制器</h2><p>当定义子控制器用作内容控制器，根据视图的所有子视图都负责展示内容数据。框架定义的几个常用内容控制器：1.UITableViewController指定VC的根视图为一个Table。2.UICollectionViewController 定义VC的根视图为一个视图集合。3.UIViewController作为最基础的类。</p>
<p>与内容控制器相反，容器控制器仅仅只管理子控制器的根视图。可以根据需要选择框架内合适的容器控制器，如果需要自定义容器控制，则需要继承UIViewController。</p>
<h4 id="定义用户界面"><a href="#定义用户界面" class="headerlink" title="定义用户界面"></a>定义用户界面</h4><p>应用可以使用storyboard editor或者编程的方式实现用户界面。</p>
<p>使用storyboard editor定义界面，按照如下流程：</p>
<ol>
<li>添加、安排、配置控制器的视图。</li>
<li>连接outlets 和 actions。</li>
<li>创建控制器之间的关联和segues。</li>
<li>自定义控制器在不同的size classes下的布局和视图情况。</li>
<li>添加手势处理用户在视图上的交互。</li>
</ol>
<h4 id="处理用户交互"><a href="#处理用户交互" class="headerlink" title="处理用户交互"></a>处理用户交互</h4><p>应用的响应者对象处理传入的事件并采取适当的动作。虽然控制器作为响应链上的响应对象，但是很少直接处理点击事件，而是通过以下的方式进行事件处理：</p>
<ol>
<li>控制器定义动作方法处理高层的事件。（a）指定动作：Control或者View调用动作方法响应指定的交互。（b）手势识别器调用动作方法响应交互。</li>
<li>控制器注册成为观察者接收系统或者其它对象的通知，响应事件。</li>
<li>控制器扮演其它对象的数据源或者代理。</li>
</ol>
<h4 id="视图运行时展示"><a href="#视图运行时展示" class="headerlink" title="视图运行时展示"></a>视图运行时展示</h4><p>采用Storyboards处理加载和展示VC的视图非常简单。按照以下步骤执行：</p>
<ol>
<li>使用storyboard文件里的信息初始化视图。</li>
<li>连接所有的outlets和actions。</li>
<li>将生成的根视图赋值给控制器的view属性。</li>
<li>调用控制器的awakeFromNib方法。当此方法被调用后，控制器的特性还未被确认，所以子视图都没显示在最终的位置。</li>
<li>调用控制器的viewDidLoad方法。使用此方法添加或者删除视图、修改视图布局、为视图加载数据。</li>
</ol>
<p>要使控制器内容最终展现到屏幕上，UIKit框架插入了附加的步骤，供使程序具有更多的控制权：</p>
<ol>
<li>调用viewWillAppear:方法，通知该视图即将要展示到屏幕上。</li>
<li>更新视图的布局。</li>
<li>显示内容在屏幕上。</li>
<li>调用viewDidAppear:方法，通知视图已经展示在屏幕上了。</li>
</ol>
<h4 id="管理视图布局"><a href="#管理视图布局" class="headerlink" title="管理视图布局"></a>管理视图布局</h4><p>当视图的位置或者大小发生改变，UIKit框架更新视图层次的布局信息。在布局处理过程中，UIKit框架需要做如下处理影响控制器的布局：</p>
<ol>
<li>更新控制器的根视图或者子视图的trait特性。</li>
<li>调用控制器的viewWillLayoutSubviews方法。</li>
<li>调用上下文里UIPresentationController对象的containerViewWillLayoutSubviews方法。<strong>该方法在iOS8.0后出现</strong>。</li>
<li>调用控制器的根视图的layoutSubviews方法。<strong>该方法的默认实现通过可用的约束计算新的布局信息，然后该方法依据视图层次结构调用子视图的layoutSubviews。</strong></li>
<li>应用计算好的布局信息到视图。</li>
<li>调用控制器的viewDidLayoutSubviews方法。</li>
<li>调用上下文里UIPresentationController对象的containerViewDidLayoutSubviews方法。<strong>该方法在iOS8.0后出现</strong>。</li>
</ol>
<p>控制器的viewWillLayoutSubviews and viewDidLayoutSubviews方法有助于执行附加的布局处理流程。在布局前可以添加或者删除视图。在布局后，可以更新视图数据。</p>
<p>一点tips使用布局：</p>
<ol>
<li>使用AutoLayout。</li>
<li>利用top 或者 bottom layout guides。</li>
<li>当添加或者删除视图时，需要更新约束。</li>
<li>当操作控制器的动画时，临时移出约束。</li>
</ol>
<h2 id="实现容器控制器"><a href="#实现容器控制器" class="headerlink" title="实现容器控制器"></a>实现容器控制器</h2><h4 id="设计容器控制器"><a href="#设计容器控制器" class="headerlink" title="设计容器控制器"></a>设计容器控制器</h4><p>容器控制器与内容控制器区域在于容器控制器的视图内容来自于其它子控制器的根视图，合成到自己的视图层次结构中。关于容器控制实现，我们需要考虑的几点：</p>
<ol>
<li>容器与子控制器分别有何作用吗？</li>
<li>有多少个子控制器需要同时显示？</li>
<li>兄弟视图控制器之间是怎样的关系？</li>
<li>子视图控制器是如何添加和移出的？</li>
<li>子视图控制器的位置和大小能改变吗？如果能改变，在什么情况下会发生改变？</li>
<li>容器视图控制器会视图提供修饰或者导航？</li>
<li>父子视图控制器之间是如何通信？父视图控制器需要分发特别的事件到子视图控制器？</li>
<li>父视图控制器在不同的方式下需要有不同的呈现状态？</li>
</ol>
<h4 id="添加子视图控制器"><a href="#添加子视图控制器" class="headerlink" title="添加子视图控制器"></a>添加子视图控制器</h4><p>采用编程方式添加子视图控制器，需要创建父子视图控制器之间的关系采用以下步骤：</p>
<ol>
<li>调用父视图控制器的addChildViewController：方法。</li>
<li>添加子视图控制器的根视图到父视图的层次结构中。</li>
<li>添加管理子视图控制器的根视图的布局约束。</li>
<li>调用子视图控制器的didMoveToParentViewController:方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void) displayContentController: (UIViewController*) content &#123;</span><br><span class="line">   [self addChildViewController:content];</span><br><span class="line">   content.view.frame = [self frameForContentController];</span><br><span class="line">   [self.view addSubview:self.currentClientView];</span><br><span class="line">   [content didMoveToParentViewController:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移出子视图控制器"><a href="#移出子视图控制器" class="headerlink" title="移出子视图控制器"></a>移出子视图控制器</h4><p>移出子视图控制器，需要移出父子视图控制器之间的关系采用以下步骤：</p>
<ol>
<li>调用子视图控制器的willMoveToParentViewController:方法使用nil参数。</li>
<li>移出子视图控制器根视图的布局约束。</li>
<li>将子视图控制器根视图从父视图控制器根视图层次结构中移出。</li>
<li>调用子视图控制器的removeFromParentViewController方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) hideContentController: (UIViewController*) content &#123;</span><br><span class="line">   [content willMoveToParentViewController:nil];</span><br><span class="line">   [content.view removeFromSuperview];</span><br><span class="line">   [content removeFromParentViewController];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管理子视图控制器出现"><a href="#管理子视图控制器出现" class="headerlink" title="管理子视图控制器出现"></a>管理子视图控制器出现</h4><p>当添加子视图控制器，父视图控制器自动转发出现相关的事件。同时也可以复写shouldAutomaticallyForwardAppearanceMethods方法通知UIKit框架，需要如何处理事件的分发。</p>
<p>以下代码自定义出现事件的分发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) shouldAutomaticallyForwardAppearanceMethods &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void) viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self.child beginAppearanceTransition: YES animated: animated];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void) viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [self.child endAppearanceTransition];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void) viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [self.child beginAppearanceTransition: NO animated: animated];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void) viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [self.child endAppearanceTransition];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构建容器视图控制器建议"><a href="#构建容器视图控制器建议" class="headerlink" title="构建容器视图控制器建议"></a>构建容器视图控制器建议</h5><ol>
<li>父视图控制器应该只接触到子视图控制器的根视图。</li>
<li>子视图控制器应该尽量采用delegate等方法减少对父视图的关联。</li>
<li>尽量使用框架内已经定义好的视图。</li>
</ol>
<h5 id="代理子视图控制器进行控制"><a href="#代理子视图控制器进行控制" class="headerlink" title="代理子视图控制器进行控制"></a>代理子视图控制器进行控制</h5><ol>
<li><strong>让子视图控制器决定状态栏的方式</strong>。父视图控制器需要复写其中一个或者全部，childViewControllerForStatusBarStyle和childViewControllerForStatusBarHidden方法。</li>
<li>让子视图控制器优先决定视图的大小。</li>
</ol>
<h2 id="保存和恢复状态"><a href="#保存和恢复状态" class="headerlink" title="保存和恢复状态"></a>保存和恢复状态</h2><p>链接：<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/PreservingandRestoringState.html#//apple_ref/doc/uid/TP40007457-CH28-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/PreservingandRestoringState.html#//apple_ref/doc/uid/TP40007457-CH28-SW1</a></p>
<h2 id="呈现视图控制器"><a href="#呈现视图控制器" class="headerlink" title="呈现视图控制器"></a>呈现视图控制器</h2><p>有两种主要的方式展示一个视图控制器在屏幕上：嵌入到一个容器视图控制器、展示或者呈现。</p>
<p>UIKit框架为UIViewController植入了对呈现视图控制器的支持，所以应用可以在任意一个视图控制器上呈现其它的视图控制器，<strong>这个呈现请求可能会被转移到其它的视图控制器上</strong>。呈现一个视图控制器会在<strong>接受请求的视图控制器</strong>与<strong>被要求呈现的视图控制器</strong>之间创建一个关联关系，这个关联关系作为视图控制器的视图层次结构的一部分，并保持到<strong>被呈现的视图控制器消失为止</strong>。</p>
<h4 id="呈现与过渡"><a href="#呈现与过渡" class="headerlink" title="呈现与过渡"></a>呈现与过渡</h4><p>UIKit框架内置的呈现机制，可以让应用使用内置或者自定义的过渡动画。</p>
<h6 id="呈现方式"><a href="#呈现方式" class="headerlink" title="呈现方式"></a>呈现方式</h6><p>视图控制器的呈现方式决定视图在屏幕上的展现方式。UIKit框架定义了多种标准的呈现方式，每种方式都有特定的展现形式和用途。根据应用需要给视图控制器modalPresentationStyle属性设置适当的值作为呈现样式。</p>
<p><strong>对于部分呈现样式，UIKit框架会在呈现与被呈现的视图控制器的视图层之间插入一个变暗的调光视图层</strong></p>
<ol>
<li>Full-Screen Styles：覆盖整个屏幕，阻止与底层的内容进行交互。</li>
<li>Popover Style：将视图控制器的内容展示到一个popover视图里。在水平方向正常的情况下，popover视图只覆盖屏幕的一部分；在水平方向受限的情况下，popover适配成Full-Screen Styles。所以<strong>应当根据情况，适配popover的消失逻辑处理</strong>。</li>
<li>Current Context Styles：覆盖特定视图控制器内容部分，且特定的视图控制器definesPresentationContext属性需要设置为true。（a）使用此方式，可以用实呈现的视图控制器的modalTransitionStyle属性设置过渡动画，<strong>如果呈现VC的providesPresentationContextTransitionStyle 属性设置为true，则使用呈现VC的modalTransitionStyle设置的动画方式</strong>。（b）在水平方向受限的情况下，被默认适配成Full-Screen Styles。</li>
<li>Custom Presentation Styles：使用UIModalPresentationCustom设定自定义呈现方式。创建UIPresentationController子类使用方法控制屏幕上的视图的动画等，设置被呈现的视图控制器的视图大小和位置。presentation控制器还需要处理在过渡期间由于特性变化引起的适配情况。</li>
</ol>
<h6 id="过渡方式"><a href="#过渡方式" class="headerlink" title="过渡方式"></a>过渡方式</h6><p>过渡的方式定义了被呈现视图控制器视图显示的动画。对于UIKit框架内置的过渡方式，使用modalTransitionStyle属性进行设置。</p>
<p>应用可以使用animator对象和transitioning代理自定义过渡时的动画。animator对象创建视图控制器在屏幕上的动画。transitioning代理根据合适的时机使用对应的animator对象。</p>
<h6 id="显示与呈现方式对比"><a href="#显示与呈现方式对比" class="headerlink" title="显示与呈现方式对比"></a>显示与呈现方式对比</h6><p>视图控制器提供两种方式展现VC：</p>
<ol>
<li>showViewController:sender: 和showDetailViewController:sender: 方法提供灵活与适配的方式展现VC。此方法让被请求呈现的视图控制器<strong>决定更好的方式处理presentation</strong>。例如，容器视图控制器可能会把被呈现的视图控制器添加为子视图控制器。<strong>默认的处理方式是modally</strong>。</li>
<li>presentViewController:animated:completion: 方法总是采用modally方式展现视图控制器。<strong>调用此方法的视图控制器不一定是最后处理presentation的视图控制器</strong>。</li>
</ol>
<h4 id="呈现一个视图控制器"><a href="#呈现一个视图控制器" class="headerlink" title="呈现一个视图控制器"></a>呈现一个视图控制器</h4><p>可以使用Segues、showViewController:sender: or showDetailViewController:sender:方法、presentViewController:animated:completion: 方法发起一个呈现视图控制器的请求。</p>
<h6 id="Showing-View-Controllers"><a href="#Showing-View-Controllers" class="headerlink" title="Showing View Controllers"></a>Showing View Controllers</h6><p>调用showViewController:sender: and showDetailViewController:sender: 方法实现presentation直接如下：</p>
<ol>
<li>创建一个需要被呈现的视图控制器。</li>
<li>设置创建的视图控制器的modalPresentationStyle属性预定义呈现方式。但不一定是最后使用的呈现方式。</li>
<li>设置创建的视图控制器的 modalTransitionStyle 属性定义过渡时的动画。但最后过渡不一定会使用该动画。</li>
<li>在当前的VC中调用showViewController:sender: and showDetailViewController:sender:方法。</li>
</ol>
<p>UIKit框架会转发showViewController:sender: and showDetailViewController:sender:调用到适当的presenting view controller，该VC会根据需要决定如何处理presentation and transition styles。例如，navigation controller might push the view controller onto its navigation stack。</p>
<h6 id="Presenting-View-Controllers-Modally"><a href="#Presenting-View-Controllers-Modally" class="headerlink" title="Presenting View Controllers Modally"></a>Presenting View Controllers Modally</h6><p>直接 presenting a view controller，调用方法如下：</p>
<ol>
<li>创建一个视图控制器。</li>
<li>设置视图控制器的modalPresentationStyle属性决定呈现方式。</li>
<li>设置视图控制器的modalTransitionStyle属性设置过渡时的动画。</li>
<li>在当前的VC上调用presentViewController:animated:completion:方法。</li>
</ol>
<p>当presentViewController:animated:completion:方法被调用后，UIKit框架会沿着控制器的层次结构找到合适的presenting view controller，并且会更新涉及到的视图控制器的presentingViewController and presentedViewController属性关系。</p>
<h6 id="Presenting-a-View-Controller-in-a-Popover"><a href="#Presenting-a-View-Controller-in-a-Popover" class="headerlink" title="Presenting a View Controller in a Popover"></a>Presenting a View Controller in a Popover</h6><p>如果要采用Popovers方式呈现一个视图控制器，在设置VC的modalPresentationStyle属性为UIModalPresentationPopover后，还需要做以下设置：</p>
<ol>
<li>设置被呈现视图控制器的 preferredContentSize属性。</li>
<li>通过VC的 popoverPresentationController属性获得关联的UIPopoverPresentationController对象，并需要设置popover的锚点。设置以下其中之一：（a）设置一个bar button item关联到barButtonItem属性。（b）指定 sourceView and sourceRect在特定的视图区域上。</li>
</ol>
<h6 id="Dismissing-a-Presented-View-Controller"><a href="#Dismissing-a-Presented-View-Controller" class="headerlink" title="Dismissing a Presented View Controller"></a>Dismissing a Presented View Controller</h6><p>要消失一个被呈现的视图控制器，直接在presenting view controller调用dismissViewControllerAnimated:completion: 方法。也可以在presented view controller上调用dismissViewControllerAnimated:completion: 方法，UIKit框架会自动转发请求到对应的presenting view controller上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/20/ViewController-PG/" data-id="cinbsbv9j001fsgzlljdx0tpb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-View-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/View-PG/" class="article-date">
  <time datetime="2016-04-18T02:42:01.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/View-PG/">View-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>windows和view呈现应用的内容到屏幕上。</p>
<p>window主要功能可以认为是一个容器，协调管理views与用户的交互。</p>
<p>view用于封装需要展示的内容作为window的一部分呈现，占用区域一定是一个矩形。绘制内容、touch交互事件、管理子视图布局。绘制涉及到的图形技术主要是Core Graphics，OpenGL ES，以及UIKit提供的封装。</p>
<p>Animations是和应用发生交互时，在界面上以可视的效果给用户进行实时反馈的机制。</p>
<h2 id="view-and-window构造"><a href="#view-and-window构造" class="headerlink" title="view and window构造"></a>view and window构造</h2><p>view对象在屏幕上定义一个矩形区域用于绘制和处理在区域内的touch事件。view同时可以作为其它view的父视图，管理子视图的位置和大小。</p>
<p>view结合Core Animation的layer处理渲染内容和动画展示。每个view都需要结合一个Layer完成渲染和动画动作。iOS采用layer对象方式在性能提升方面有很重要的作用。</p>
<h5 id="content-mode"><a href="#content-mode" class="headerlink" title="content mode"></a>content mode</h5><p>view的Content mode定义当改变视图几何属性时，如何重新使用content的机制。当一个视图第一次显示，视图渲染内容并在后台保持底层的位图。当以下情况发生时，由content mode属性决定如何重新使用位图进行展示：</p>
<ol>
<li>改变视图的宽度或者高度引起frame和bounds的改变。</li>
<li>改变视图transform属性引起缩放因子的改变。</li>
</ol>
<h5 id="Animation-Support"><a href="#Animation-Support" class="headerlink" title="Animation Support"></a>Animation Support</h5><p>由于view视图内容是基于layer对象，此机制使执行与view相关的动画非常容易。</p>
<p>view大多数属性是支持动画执行，可以定义为半自动的执行方式，通过基于view的属性执行动画，需要按照以下步骤：</p>
<ol>
<li>告诉UIKit框架需要执行动画。</li>
<li>改变需要执行动画view的属性的值。</li>
</ol>
<h5 id="view-几何特性与坐标系统"><a href="#view-几何特性与坐标系统" class="headerlink" title="view 几何特性与坐标系统"></a>view 几何特性与坐标系统</h5><p>默认的坐标系统是以左上角为原点，坐标轴从原点垂直向下和水平向右扩展。每个子视图都依赖其自身的坐标系统。</p>
<h6 id="Frame、Bounds、Center关系"><a href="#Frame、Bounds、Center关系" class="headerlink" title="Frame、Bounds、Center关系"></a>Frame、Bounds、Center关系</h6><p>view对象通过Frame、Bounds、Center属性展示其位置和大小：</p>
<ol>
<li>frame属性是一个矩形区域，指定当前视图在其父视图内的位置和大小。</li>
<li>bounds属性是一个矩形区域，指定是的当前视图包含区域，定义视图的本地坐标系统。</li>
<li>center属性指定当前视图的anchor点在其父视图内的位置。</li>
<li>当改变frame属性，会引起bounds、center的改变。</li>
<li>当改变bounds属性，会引起frame的改变，不会影响center。</li>
<li>当改变center属性，会引起frame的改变，不会影响bounds。</li>
</ol>
<h5 id="运行时交互模型"><a href="#运行时交互模型" class="headerlink" title="运行时交互模型"></a>运行时交互模型</h5><p>任何时间当用户与界面产生交互，或者程序代码引起一些变化，将会产生一系列复杂的事件提供给UIKit框架去处理相应的交互。在该系列事件特定关键点上，UIKit框架唤起view对应的class对象，给予程序代码响应程序事件的机会。下图展示了事件发生时，唤起事件处理的关键点：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/view_PG_F1_7.jpg" alt="view_PG_F1_7"></p>
<p>上图按步骤表述了事件执行序列并解释不同步骤发生了什么，同时说明在程序代码内如何去作出响应：</p>
<ol>
<li>用户在屏幕上点击。</li>
<li>系统硬件将事件转化后，转发到UIKit框架。</li>
<li>UIKit框架打包touch事件，并分发到相应的view。（该过程由Event Handle PG处理）</li>
<li>事件处理代码负责响应事件：（a）改变视图的属性。（b）调用setNeedsLayout方法，标记view需要更新布局。（c）调用setNeedsDisplay或者setNeedsDisplayInRect：方法标记视图（包括子视图）需要重新绘制。（d）通知controller更改数据块。</li>
<li>如果视图的几何属性发生改变，UIKit框架根据以下规则更新子视图：（a）如果视图配置auto resize规则，则根据相应规则更新视图。（b）如果view实现的layoutSubviews方法，UIKit框架调用些方法。<strong>可以通过此方法适配任何子视图的位置和大小</strong>。</li>
<li>如果视图的任何部分被标记为需要重新绘制，UIKit框架询问view进行重绘。对于自定义视图，UIKit框架明确调用drawRect：方法。此方法只处理视图绘制相关的工作，不能用于处理数据等工作。</li>
<li>任何更新过的view视图与应用其它部分可视内容被打包到一起，发送到图形硬件进行显示。</li>
<li>图形硬件转化渲染内容到屏幕上。</li>
</ol>
<p>在以上的步骤中，主要用于自定义视图的集成点：</p>
<ol>
<li>event-handling方法：</li>
<li>layoutSubviews方法。</li>
<li>drawRect:方法。</li>
</ol>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>每个iOS应用程序需要至少一个window。window对象主要的职责：</p>
<ol>
<li>展示应用程序的可视化内容。</li>
<li>充当一个分发touch事件到指定view视图和其它应用对象的角色。</li>
<li>和view controllers协同工作响应设备方向的改变。</li>
</ol>
<h6 id="window-Level"><a href="#window-Level" class="headerlink" title="window Level"></a>window Level</h6><p>用一个浮点数表示(public typealias UIWindowLevel = CGFloat<br>)，常用的三种层次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(UIWindowLevelNormal)  // 0.0</span><br><span class="line">print(UIWindowLevelStatusBar)    // 1000.0</span><br><span class="line">print(UIWindowLevelAlert)      // 2000.0</span><br></pre></td></tr></table></figure>
<h6 id="Monitor-Window-changes"><a href="#Monitor-Window-changes" class="headerlink" title="Monitor Window changes"></a>Monitor Window changes</h6><p>与window相关的通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIWindowDidBecomeVisibleNotification</span><br><span class="line">UIWindowDidBecomeHiddenNotification</span><br><span class="line">UIWindowDidBecomeKeyNotification</span><br><span class="line">UIWindowDidResignKeyNotification</span><br></pre></td></tr></table></figure>
<h4 id="External-Display"><a href="#External-Display" class="headerlink" title="External Display"></a>External Display</h4><p>主要的基本处理过程如下：</p>
<ol>
<li>在程序启动时，注册screen的连接和断开连接通知。</li>
<li>当需要在扩展屏幕上显示内容时，创建和配置一个window：（a）通过UIScreen的screens获得扩展屏幕对象。（b）创建一个window对象并配置适当的大小。（c）当扩展屏幕对象赋值给新建的window对象。（d）根据屏幕分辨率适配显示内容。（e）添加任何适当的内容到window上。</li>
<li>显示window对象，并正常的处理更新。</li>
</ol>
<h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>view对象提供应用与用户主要的交互方式，必须执行相应的职责：</p>
<ol>
<li>布局与子视图管理：（a）视图定义自己的resizing行为关联到其父视图上。（b）一个视图能管理多个子视图。（c）视图可以根据需要动态改变子视图的位置与大小。（d）视图可以将自坐标系统里的点转换到对应的视图或者window坐标系统上。</li>
<li>绘制图象和动画呈现：（a）在视图的矩形区域内绘制图象内容。（b）改变视图属性，以动画形势给用户反馈，属性值改变。</li>
<li>事件处理：（a）视图可以接收事件。（b）事件是事件响应链的一部分。</li>
</ol>
<h4 id="Adjusting-the-Size-and-Position-of-Views-at-Runtime"><a href="#Adjusting-the-Size-and-Position-of-Views-at-Runtime" class="headerlink" title="Adjusting the Size and Position of Views at Runtime"></a>Adjusting the Size and Position of Views at Runtime</h4><p>当视图的size发生变化，其子视图的位置与大小必须依据情况作出改变。视图支持自动和手动改变布局。在自动布局情况下，子视图依据父视图设置的规则进行变化；在手动情况下，在应用来创建代码根据需要来控制子视图的大小和位置。</p>
<h6 id="Layout-change-触发事件"><a href="#Layout-change-触发事件" class="headerlink" title="Layout change 触发事件"></a>Layout change 触发事件</h6><p>Layout发生改变，当有以下事件发生时：</p>
<ol>
<li>视图的bounds的size发生改变。</li>
<li>当设备方向发生变化，通常根据是应用触发的根视图的bounds矩形发生变化。</li>
<li>当一组子图层关联的父图层发生变化并需要重新布局时。</li>
<li>当应用调用setNeedsLayout或者layoutIfNeeded方法强制更新视图时。</li>
<li>当应用在关联的视图图层调用setNeedsLayout方法强制布局更新。</li>
</ol>
<h5 id="使用Autoresizing-Rules处理自动布局"><a href="#使用Autoresizing-Rules处理自动布局" class="headerlink" title="使用Autoresizing Rules处理自动布局"></a>使用Autoresizing Rules处理自动布局</h5><p>父视图的autoresizesSubviews属性决定子视图是否支持resize。如果该属性设置成YES，则在父视图发生改变要求子视图需要重新布局时，子视图用autoresizingMask属性来决定如何改变位置和大小。</p>
<p>下表列出autoresizingMask可用的取值：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/view_PG_T3_2.jpg" alt="view_PG_T3_2"></p>
<p>当视图在同一轴上有超过一个灵活配置属性，UIKit框架分配等比例在相应的空间上。</p>
<h5 id="通过代码直接控制View布局"><a href="#通过代码直接控制View布局" class="headerlink" title="通过代码直接控制View布局"></a>通过代码直接控制View布局</h5><p>当视图的size发生变化，UIKit框架应用autoresizing行为在子视图上，然后再调用视图layoutSubviews方法使应用可以再次通过代码控制视图布局。我们可以在应用内实现layoutSubviews方法，当autoresizing行为不能满足要求时，再通过code改变。</p>
<p>在layoutSubviews方法内，可以实现如下功能：</p>
<ol>
<li>适配任何内存子视图的位置和大小。</li>
<li>添加或者移出子视图或者图层。</li>
<li>调用setNeedsDisplay或者setNeedsDisplayInRect:方法强制子视图进行重绘。</li>
</ol>
<h4 id="运行时修改视图"><a href="#运行时修改视图" class="headerlink" title="运行时修改视图"></a>运行时修改视图</h4><p>当应用程序接收到输入事件，应用需要适配界面来响应相应的输入。此时，应用会修改视图或者重排子视图，改变大小或者位置等。在iOS应用内，有多个地方和方法执行相应动作：</p>
<ol>
<li>在VC内：（a）一个VC在显示视图内容前必须创建它们，不管是能纯代码还是通过nib加载。最后在不使用它们时销毁。（b）当设备方向发生改变时，VC需要适配视图的大小和位置。或者会增加、移出部分视图。（c）当VC管理可编辑的内容时，VC会改变或者移动视图的层级关系。</li>
<li>在动画块内：（a）当过渡多组不同的视图展现用户界面时，需要在动画块内显示或者隐藏部分视图。（b）当需要实现特殊的效果里，则需要在动画块内改变视图指定的属性。</li>
<li>其它方式：（a）当发生touch事件或者手势时，界面需要响应视图加载或者改变等。（b）当用户与scroll view交互时，一个大的滑动区域需要动态显示和隐藏子视图。（c）当键盘出现或者隐藏时，需要重新设计视图的位置。</li>
</ol>
<h4 id="图层对象相互关联"><a href="#图层对象相互关联" class="headerlink" title="图层对象相互关联"></a>图层对象相互关联</h4><p>每个视图对象都有一个专用的图层管理内容的呈现和视图内容在屏幕上的动画。应用可以与视图对象交互，也可以直接与图层对象进行交互。视图可以嵌入其它的layer对象。</p>
<p>通过实现类方法layerClass指定view关联的layer对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    return [CATiledLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义视图注意点"><a href="#自定义视图注意点" class="headerlink" title="自定义视图注意点"></a>自定义视图注意点</h4><p>当系统框架提供的视图组件不能满足业务需求时，应用可以自定义控件，以下是自定义控件要注意的地方：</p>
<ol>
<li>需要为视图指定适当的初始化方法：（a）如果采用纯代码的方式实现自定义，则需要实现initWithFrame:方法或者自定义一个初始化方法。（b）如果采用nib的方式实现，则需要实现initWithCoder:方法，并使用该方法设置视图到初始化的状态。</li>
<li>根据情况实现dealloc方法清理数据。</li>
<li>对于采用代码绘制图像内容，则需要复写drawRect:方法并在此方法内实现内容的绘制。</li>
<li>设置自定义视图的autoresizingMask属性定义autoresizing行为。</li>
<li>如果视图类管理多个子视图：（a）在视图初始化的节点上创建子视图。（b）在子视图创建时设置对应的autoresizingMask属性。（c）如果视图需要对子视图采用定制的布局，则需要复写layoutSubviews方法并实现定制的布局代码。</li>
<li>处理touch事件相关的事件：（a）使用addGestureRecognizer:方法添加适当的手势识别器到view上。（b）当手势不能满足需要时，可以复写 touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent:, 和 touchesCancelled:withEvent: 方法对事件进行定制处理。</li>
<li>如果想为视图实现打印且打印板式与屏幕上不同，需要实现drawRect:forViewPrintFormatter:方法。具体情况需要参照Drawing and Printing PG。</li>
</ol>
<p>对于视图事件响应处理，要参考Event Handling PG。</p>
<p>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/View-PG/" data-id="cinbsbv980018sgzlvsyptaux" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Concurrency-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/Concurrency-PG/" class="article-date">
  <time datetime="2016-04-12T03:58:31.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/Concurrency-PG/">Concurrency-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>并发</strong>概念：是指多种事件任务在同一时间执行。</p>
<p>直接线程交互：应用程序必须依据操作系统的情况动态的创建和适配线程工作情况。除此之外，应用程序需要花费大量精力负责创建和维护使用的线程。</p>
<p>针对多线程管理，Apple提出采取一个异步的方式解决并发问题。异步功能函数在另外一个线程执行耗时的任务，当任务完成后，发送一个通知（调用回调函数）至原工作线程。</p>
<p>为简化异步功能的实现和使用，Apple实现了几种解决方案：Dispatch Queues、Dispatch Sources、Operation Queues。</p>
<h6 id="并发注意事项"><a href="#并发注意事项" class="headerlink" title="并发注意事项"></a>并发注意事项</h6><ol>
<li>考虑是否必须采用并发实现。</li>
<li>并发可以提升性能，但是会增加程序复杂度，同时也会增加程序调试难度。</li>
<li>并发不应该作为一个功能特征看待，不能为了并发而加入并发。</li>
<li>清楚定义程序需要完成的功能任务。分离出需要执行的任务单元。标示需要的执行队列，正确将任务单元放入队列中执行。</li>
<li>并发技术只是提供更方便的执行并发任务的操作，不能保证性能的提升，所以在编程时要注意考虑性能问题。</li>
</ol>
<p>性能考虑：</p>
<ol>
<li>如果内存是影响性能的关键，则考虑直接执行任务。</li>
<li>标示线性执行任务，调整任务结构，尽量采用并发执行。</li>
<li>避免使用lock操作。</li>
<li>尽量使用框架提供的高层API。</li>
</ol>
<h2 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>operations是一种面向对象的方式实现异步执行任务功能。operations结合operation queue使用或者单独使用。</p>
<p>operation对象是NSOperation类型的一个实例对象，用于封装在应用内需要执行的任务。以下列出关于官方定义的几个Operation类：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_T2_1.jpg" alt="Concurrency_T2_1"></p>
<p>全部operation对象都支持如下：</p>
<ol>
<li>可以建立operation对象间的依赖关系。</li>
<li>支持设定completion block回调通知。</li>
<li>支持运用KVO技术监控对象的执行状态。</li>
<li>支持通过设定优先级，影响operation对象的执行顺序。</li>
<li>支持取消任务。</li>
</ol>
<p>关于Operation相关类Apple开源代码：<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSOperation.swift" target="_blank" rel="external">https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSOperation.swift</a></p>
<h6 id="对比并发与非并发"><a href="#对比并发与非并发" class="headerlink" title="对比并发与非并发"></a>对比并发与非并发</h6><p>operation对象通常的使用方式是将其加入到operation queue中。但也可以直接调用operation的start方法执行，此时operation的运行并不不一定会保证是并发执行。可以通过NSOperration的isConcurrent方法查询当前是同步或者异步执行状态。</p>
<p>如果想要通过直接调用start方式运行在异步方式上，则必须增加附加的代码控制，实现在另外一个线程调用start方法。</p>
<p><strong>通常情况下，我们都应该直接使用Operation Queue进行操作</strong></p>
<h5 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h5><p>NSInvocationOperation是通过调用对象的selector实现，Swift不支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyCustomClass</span><br><span class="line">- (NSOperation*)taskWithData:(id)data &#123;</span><br><span class="line">    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self</span><br><span class="line">                    selector:@selector(myTaskMethod:) object:data];</span><br><span class="line"> </span><br><span class="line">   return theOp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// This is the method that does the actual work of the task.</span><br><span class="line">- (void)myTaskMethod:(id)data &#123;</span><br><span class="line">    // Perform the task.</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let operation = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;Begin operation.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Custom-Operation-Object"><a href="#Custom-Operation-Object" class="headerlink" title="Custom Operation Object"></a>Custom Operation Object</h5><p>定义一个非并发操作，只需要实现main任务，及响应取消操作，其它部分NSOpertion已经实现。</p>
<p>定义一个并发操作，则必须重写NSOperation内已经实现的部分。</p>
<h6 id="Main-Task"><a href="#Main-Task" class="headerlink" title="Main Task"></a>Main Task</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyNoConcurrentOperation: NSOperation &#123;</span><br><span class="line">    </span><br><span class="line">    var data : AnyObject</span><br><span class="line">    </span><br><span class="line">    init(d  : AnyObject) &#123;</span><br><span class="line">        data = d</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        print(&quot;Do something.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Respond-Cancel"><a href="#Respond-Cancel" class="headerlink" title="Respond Cancel"></a>Respond Cancel</h6><p>当一个任务开始执行，则任务会一直执行，直至完成或者明确取消操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override func main() &#123;</span><br><span class="line">       print(&quot;Do something.&quot;)</span><br><span class="line">       var isDone = false</span><br><span class="line">       </span><br><span class="line">       while !cancelled &amp;&amp; !isDone &#123;</span><br><span class="line">           // Do some work and set isDone to YES when finished</span><br><span class="line">           isDone = true</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="configuring-operation-concurrent"><a href="#configuring-operation-concurrent" class="headerlink" title="configuring operation concurrent"></a>configuring operation concurrent</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class MyOperation: NSOperation &#123;</span><br><span class="line">    </span><br><span class="line">    override var concurrent : Bool &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var finish : Bool = false</span><br><span class="line">    override var finished : Bool &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return finish</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var execute : Bool = false</span><br><span class="line">    override var executing : Bool &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return execute</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        execute = false</span><br><span class="line">        finish = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func start() &#123;</span><br><span class="line">        guard !cancelled else &#123;</span><br><span class="line">            self.willChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">            finish = true</span><br><span class="line">            self.didChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.willChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">        NSThread.detachNewThreadSelector(&quot;main&quot;, toTarget: self, withObject: nil)</span><br><span class="line">        execute = true</span><br><span class="line">        self.didChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        // Do main task of operation.</span><br><span class="line">        print(NSThread.currentThread())  // &quot;&lt;NSThread: 0x7fd8bb423dd0&gt;&#123;number = 3, name = (null)&#125;\n&quot;</span><br><span class="line">        completeOperation()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func completeOperation() &#123;</span><br><span class="line">        self.willChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">        self.willChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">        </span><br><span class="line">        execute = false</span><br><span class="line">        finish = true</span><br><span class="line">        </span><br><span class="line">        self.didChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">        self.didChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o = MyOperation()</span><br><span class="line">NSThread.currentThread()   // &lt;NSThread: 0x7fd8bb506f30&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">o.start()</span><br></pre></td></tr></table></figure>
<h4 id="Execution-Behavior-of-Operation"><a href="#Execution-Behavior-of-Operation" class="headerlink" title="Execution Behavior of Operation"></a>Execution Behavior of Operation</h4><ol>
<li>用 addDependency(op: NSOperation) 、 removeDependency(op: NSOperation) 控制依赖关系。</li>
<li>用 queuePriority: NSOperationQueuePriority 设置执行优先级。</li>
<li>用 threadPriority: Double 改变底层线程优先级，value在0 到 1之间。</li>
<li>用 completionBlock: (() -&gt; Void)? 设置完成时回调。</li>
</ol>
<h2 id="Executing-Operations"><a href="#Executing-Operations" class="headerlink" title="Executing Operations"></a>Executing Operations</h2><h4 id="Operation-Queue"><a href="#Operation-Queue" class="headerlink" title="Operation Queue"></a>Operation Queue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let aQueue = NSOperationQueue()</span><br><span class="line">aQueue.addOperation(anOp)</span><br><span class="line"></span><br><span class="line">aQueue.addOperations([anOOp], waitUntilFinished: false)</span><br></pre></td></tr></table></figure>
<p>public func addOperations(ops: [NSOperation], waitUntilFinished wait: Bool) 开源实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    public func addOperations(_ ops: [NSOperation], waitUntilFinished wait: Bool) &#123;</span><br><span class="line">#if DEPLOYMENT_ENABLE_LIBDISPATCH</span><br><span class="line">        var waitGroup: dispatch_group_t?</span><br><span class="line">        if wait &#123;</span><br><span class="line">            waitGroup = dispatch_group_create()</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        /*</span><br><span class="line">         If OperationQueuePriority was not supported this could be much faster</span><br><span class="line">         since it would not need to have the extra book-keeping for managing a priority</span><br><span class="line">         queue. However this implementation attempts to be similar to the specification.</span><br><span class="line">         As a concequence this means that the dequeue may NOT nessicarly be the same as</span><br><span class="line">         the enqueued operation in this callout. So once the dispatch_block is created</span><br><span class="line">         the operation must NOT be touched; since it has nothing to do with the actual</span><br><span class="line">         execution. The only differential is that the block enqueued to dispatch_async</span><br><span class="line">         is balanced with the number of Operations enqueued to the NSOperationQueue.</span><br><span class="line">         */</span><br><span class="line">        ops.forEach &#123; (operation: NSOperation) -&gt; Void in</span><br><span class="line">            lock.lock()</span><br><span class="line">            operation._queue = self</span><br><span class="line">            _operations.insert(operation)</span><br><span class="line">            lock.unlock()</span><br><span class="line">#if DEPLOYMENT_ENABLE_LIBDISPATCH</span><br><span class="line">            if let group = waitGroup &#123;</span><br><span class="line">                dispatch_group_enter(group)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            let block = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS) &#123; () -&gt; Void in</span><br><span class="line">                if let sema = self._concurrencyGate &#123;</span><br><span class="line">                    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)</span><br><span class="line">                    self._runOperation()</span><br><span class="line">                    dispatch_semaphore_signal(sema)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    self._runOperation()</span><br><span class="line">                &#125;</span><br><span class="line">                if let group = waitGroup &#123;</span><br><span class="line">                    dispatch_group_leave(group)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_group_async(queueGroup, _underlyingQueue, block)</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">#if DEPLOYMENT_ENABLE_LIBDISPATCH</span><br><span class="line">        if let group = waitGroup &#123;</span><br><span class="line">            dispatch_group_wait(group, DISPATCH_TIME_FOREVER)</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Manually"><a href="#Manually" class="headerlink" title="Manually"></a>Manually</h4><p>手动执行需要判定是否就绪、已经取消等条件。</p>
<h4 id="Cancel-Operation"><a href="#Cancel-Operation" class="headerlink" title="Cancel Operation"></a>Cancel Operation</h4><p>直接调用 cancel 方法，对于Queue中 调用 func cancelAllOperations()。</p>
<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>GCD分发队列是非常强大的工具允许构造任意的Block任务同步 或者 异步执行。</p>
<p>系统内定义的队列类型：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_T3_1.jpg" alt="Dispatch_Queues_Type"></p>
<p><strong>注意点：</strong></p>
<ol>
<li>队列执行任务的并发情况依赖当前系统其它队列的执行情况。线性队列全部任务都限制在同一队列内执行。</li>
<li>同一时间队列内执行任务的数量由系统决定。</li>
<li>系统根据任务优先级动态调整执行顺序。</li>
<li>一个任务被加入队列之前必须是准备就绪的。</li>
<li>私有的新建队列是引用记数的对象，需要考虑对象引用问题。</li>
</ol>
<h4 id="队列相关"><a href="#队列相关" class="headerlink" title="队列相关"></a>队列相关</h4><p><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_T3_2.jpg" alt="Queue_Related Tech"></p>
<h4 id="实现任务闭包"><a href="#实现任务闭包" class="headerlink" title="实现任务闭包"></a>实现任务闭包</h4><p>这个不用多提了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let task = &#123;</span><br><span class="line">    print(&quot;Current task.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建和管理队列"><a href="#创建和管理队列" class="headerlink" title="创建和管理队列"></a>创建和管理队列</h4><h6 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h6><p>let global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</p>
<h6 id="线性队列"><a href="#线性队列" class="headerlink" title="线性队列"></a>线性队列</h6><p>let serial = dispatch_queue_create(“com.example.MyQueue”, DISPATCH_QUEUE_SERIAL)</p>
<h6 id="获取全局队列"><a href="#获取全局队列" class="headerlink" title="获取全局队列"></a>获取全局队列</h6><p>用 dispatch_get_current_queue 、 dispatch_get_main_queue 、dispatch_get_global_queue。</p>
<h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><h6 id="简单任务"><a href="#简单任务" class="headerlink" title="简单任务"></a>简单任务</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let serial = dispatch_queue_create(&quot;com.example.MyQueue&quot;, DISPATCH_QUEUE_SERIAL)</span><br><span class="line">dispatch_async(serial) &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;current task finish.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Loop-Iterations"><a href="#Loop-Iterations" class="headerlink" title="Loop Iterations"></a>Loop Iterations</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let serial = dispatch_queue_create(&quot;com.example.MyQueue&quot;, DISPATCH_QUEUE_SERIAL)</span><br><span class="line"></span><br><span class="line">dispatch_apply(100, serial) &#123; (i) -&gt; Void in</span><br><span class="line">    print(&quot;current index: \(i)&quot;)    // 执行100次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="分发信号量"><a href="#分发信号量" class="headerlink" title="分发信号量"></a>分发信号量</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sema = dispatch_semaphore_create(100)</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)  //等待之前正在占用资源的任务</span><br><span class="line"></span><br><span class="line">//执行资源冲突的任务</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(sema)</span><br></pre></td></tr></table></figure>
<h6 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line"></span><br><span class="line">let group = dispatch_group_create()</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, global) &#123; () -&gt; Void in</span><br><span class="line">    // some asy task ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// current thread task ..</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER)</span><br><span class="line"></span><br><span class="line">//asy task 和 syn task 完成后执行。</span><br></pre></td></tr></table></figure>
<p>关于同步或者异步，及是否开启线程情况如下：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_1_1.png" alt="Dispatch_Queue_Thread_OO"></p>
<p>参考此链接：<a href="http://www.cnblogs.com/wendingding/p/3806821.html" target="_blank" rel="external">http://www.cnblogs.com/wendingding/p/3806821.html</a></p>
<h2 id="Dispatch-Sources"><a href="#Dispatch-Sources" class="headerlink" title="Dispatch Sources"></a>Dispatch Sources</h2><p>Dispatch Sources提供了一种向内核提交请求，异步响应内核事件的机制。是一个基本的数据类型，协调进程关于底层的事件。</p>
<p>支持的事件源类型如下：</p>
<ol>
<li>时钟产生周期性的通知。</li>
<li>信号源通知应用系统产生信号。</li>
<li>文件描述符或者基于socket操作的通知：（1）数据准备好可读。（2）文件可写数据。（3）当文件被系统删除、移动、重命名。（4）当文件的原信息修改。</li>
<li>和进程相关的通知事件：（1）进程退出。（2）通过命令fork或者exec产生进程。（3）当一个信号在线程内分发。</li>
<li>基于Mach相关的事件分发。</li>
<li>自定义的事件分发源。</li>
</ol>
<p>记录一下关于信号量和进行的监控，其它的参考文档实现：</p>
<h6 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h6><p>func installSignalHandler() {<br>    // Make sure the signal does not terminate the application.<br>    signal(SIGHUP, SIG_IGN)</p>
<pre><code>let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
let source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, UInt(SIGHUP), 0, queue)

if source != nil {
    dispatch_source_set_event_handler(source, { () -&gt; Void in
        // 处理信号发生
    })

    // Start processing signals
    dispatch_resume(source)
}
</code></pre><p>}</p>
<h6 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func monitorParentProcess() &#123;</span><br><span class="line">    let parentPID = getpid()</span><br><span class="line">    </span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    let source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, UInt(parentPID), DISPATCH_PROC_EXIT, queue)</span><br><span class="line">    </span><br><span class="line">    if source != nil &#123;</span><br><span class="line">        dispatch_source_set_event_handler(source, &#123; () -&gt; Void in</span><br><span class="line">            //Handler exit ...</span><br><span class="line">            </span><br><span class="line">            dispatch_source_cancel(source)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><ol>
<li>队列减少多线程应用对系统存储的使用。</li>
<li>消除创建和管理线程的代码。</li>
<li>消除在线程上管理和计划执行的代码。</li>
<li>简化应用程序代码书写。</li>
</ol>
<p>参考官方文档：<a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/12/Concurrency-PG/" data-id="cinbsbv7z0004sgzlvzgjwt23" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RunLoop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/11/RunLoop/" class="article-date">
  <time datetime="2016-04-11T04:18:27.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/RunLoop/">RunLoop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>线程是一种在同一应用内并行执行多任务轻量级的实现方式。在系统层面不同程序并行执行，系统依据不同程序的需要分配执行时间。在不同的应用程序内，存在一个或者多个线程，同时执行任务或者趋于同时执行。系统对实际的线程进行控制，安排线程在可用的内核上执行，依据优先级切换不同的线程执行任务。</p>
<p>从技术层面讲，线程是内核层面和应用层面的数据结构组合用于管理执行代码。在内核结构上协调事件分发、依据优先级安排线程执行在可用的内核上。在应用层面上该数据结构包括调用堆栈存储函数并且应用需要管理和操控线程的属性和状态。</p>
<ol>
<li>对于非并发的应用内，则只有一个线程执行任务。线程必须响应程序内的任何事件。</li>
<li>对于并发的应用，则有多条path同时执行任务。每个path都有自定义的入口，并独立于主线程的任务。多线程优势：可以提升程序的响应。可以提升程序的实时性能在多核系统上。</li>
</ol>
<p><strong>Run Loops是线程的基本构成的一部分。Run Loop是一个处理事件的循环，用于我们安排任务或者协调进入的Event。run loop的作用是当有任务需要处理时保持线程忙碌，在没有任务需要执行时让线程进入休眠。</strong></p>
<ol>
<li>run loop不完成完全自动进行管理，应用必须设计程序代码在响应接入的event，并在适当的时候启动。</li>
<li>应用不需要明确创建run loop对象，每个线程都有一个关联的run loop对象。</li>
<li>app框架自动设置并开启线程的run loop对象，只有新启的其它线程需要明确的开启run loop。</li>
</ol>
<h2 id="解析Run-Loop"><a href="#解析Run-Loop" class="headerlink" title="解析Run Loop"></a>解析Run Loop</h2><p>run loop接收两种不同来源类型的事件。<strong>Input Sources</strong>分发异步事件。<strong>Timer Sources</strong>分发同步事件。</p>
<p>下图描述的Run loop的概念结构和各种不同的输入源：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/runloop_3_1.jpg" alt="RunLoop_3_1"></p>
<p>除了处理输入的事件源，run loop同时会生成关于自身的行为通知。注册通知可以接收到相应的通知并且可以用这些通知进行附加的处理。</p>
<h2 id="Run-Loop-Modes"><a href="#Run-Loop-Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h2><p>一个Run loop模式是输入源、时钟和注册的观察者的集合。</p>
<p>每当应用程序启动run loop，指定一个特定模式运行。在run loop运行期间，只有关联到相应模式上的事件会被监控和分发（相似的，只有关联到指定模式的观察者才会被通知）。关联到其它模式的输入源被挂起直到run loop运行适当的模式。</p>
<p>在程序内，用字符串标示指定的模式，框架内定义的default和几种能用模式：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/runloop_T3_1.jpg" alt="RunLoop_T3_1"></p>
<p>应用使用不同的模式筛选出在特定途径下不想执行的事件任务。在应用执行的大部分时间，都应该将程序使用default模式执行。</p>
<h2 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h2><p>输入源异步的分发事件到指定线程。源事件依赖于输入源类型，被分为能用的两种：一是基于端口的输入源监控应用程序的Mach ports，另一种是自定义输入源监控事件。系统实现对于常用的两种类型输入都适用，唯一不同的地方就是它们如何触发信号。基于端口的输入源自动触发信息通过系统内核，而自定义输入源需要代码控制实现在另一个纯种。</p>
<h6 id="基于端口的输入源"><a href="#基于端口的输入源" class="headerlink" title="基于端口的输入源"></a>基于端口的输入源</h6><p>Cocoa和CoreFoundation框架提供内置的支持创建基于端口的输入源。在Cocoa框架内使用NSPort进行端口输入源的创建。在CoreFoundation用CFMachPortRef等。</p>
<h6 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h6><p>如果要创建一个自定义的输入源，则必须使用CFRunLoopSourceRef相关联的功能函数。定义一个自定义的输入源需要使用不同的回调函数。CoreFoundation框架在不同的时间点调用不同的架设函数，处理任何的接入事件、或者sources完成后移出run loop。</p>
<p>除了定义当事件到达时输入源的行为定义，同时必须定义事件的分发机制。这部分内容运行在独立的线程上，负责响应提供输入源的数据并且当数据准备完成时要触发信号。关于事件分发机制部分取决于代码实现，但不应该过于复杂。</p>
<h6 id="Cocoa-Selector-Sources"><a href="#Cocoa-Selector-Sources" class="headerlink" title="Cocoa Selector Sources"></a>Cocoa Selector Sources</h6><p>除了基于端口的输入源，Cocoa定义了定制的输入源允许应用通过调用Selector方式实现。和端口输入源一样，selector源在目标线程上也是连续的执行，从而避免在同一个线程上多个方法同时的执行的同步问题。</p>
<p><strong>如果要在另一个线程调用Selector，该线程必须有一个活动的active</strong>，且run loop处理全部入队的selector调用在插入run loop时，而不是在loop迭代循环的时候。</p>
<p>下表列出定义在NSObject上可以在另一个线程上执行selector的方法：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/runloop_T3_2.jpg" alt="RunLoop_T3_2"></p>
<h2 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h2><p>时间输入源是预定义的在将来某个时间点同步分发事件到指定线程上。时钟源是一种通知线程执行任务的方式。</p>
<h6 id="Configuring-Timer-Sources"><a href="#Configuring-Timer-Sources" class="headerlink" title="Configuring Timer Sources"></a>Configuring Timer Sources</h6><p>创建一个时钟输入源，程序需要创建一个时间对象，并且将时钟对象安排到run loop上执行。</p>
<p>在Cocoa框架里，定义了两个方法来创建并安排时钟到run loop，这两个方法创建并添加timer至run loop的default模式：</p>
<ol>
<li>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</li>
<li>scheduledTimerWithTimeInterval:invocation:repeats:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">// Create and schedule the first timer.</span><br><span class="line">NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];</span><br><span class="line">NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate</span><br><span class="line">                        interval:0.1</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer1:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">// Create and schedule the second timer.</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:0.2</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer2:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context = &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,</span><br><span class="line">                                        &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"> </span><br><span class="line">CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<h2 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h2><p>可以关联以下事件至Run Loop：</p>
<ol>
<li>进入run loop时。</li>
<li>当一个run loop处理一个timer。</li>
<li>当一个run loop处理一个输入源。</li>
<li>当一个run loop进入睡眠状态。</li>
<li>当一个输入源准备要唤醒run loop。</li>
<li>退出run loop。</li>
</ol>
<p>创建和使用Run Loop Objservers 需要使用 CFRunLoopObserverRef  相关功能函数。</p>
<h2 id="Run-Loop-事件顺序"><a href="#Run-Loop-事件顺序" class="headerlink" title="Run Loop 事件顺序"></a>Run Loop 事件顺序</h2><p>run loop事件指定顺序如下：</p>
<ol>
<li>通知观察者已经进入run loop。</li>
<li>通知观察者处于准备状态的timer将要执行。</li>
<li>通知观察者任何非基于端口的输入源将要执行。</li>
<li>非基于端口的输入源准备执行。</li>
<li>如果基于端口的输入源已经准备就绪且等待执行，则立即处理事件。跳转至步骤9</li>
<li>通知观察者线程将要进入休眠。</li>
<li>将线程变成休眠状态，直到如下事件发生：（1）一个基于端口的事件到达。（2）timer触发。（3）runloop到达设置的超时时间。（4）runloop被明确的唤醒。</li>
<li>通知观察者线程刚刚被唤醒。</li>
<li>处理等待状态的事件。（1）如果用户定义的timer触发，处理timer事件，并重新启动runloop。进入步骤2。（2）如果input源触发，则分发事件。（3）如果runloop被明确唤醒但是没有超时，则重新启动runloop。进入步骤2</li>
<li>通知观察者run loop退出。</li>
</ol>
<h2 id="什么时候用RunLoop"><a href="#什么时候用RunLoop" class="headerlink" title="什么时候用RunLoop"></a>什么时候用RunLoop</h2><p>仅仅只有在应用内创建第二个线程，有可能需要启动runloop。</p>
<p>需要启动runloop，当计划做如下任务：</p>
<ol>
<li>使用基于端口或者自定义的输入源和其它的线程进行通信。</li>
<li>在线程中使用timer。</li>
<li>需要使用selector输入源。</li>
<li>想要线程执行周期性的任务。</li>
</ol>
<h2 id="使用RunLoop"><a href="#使用RunLoop" class="headerlink" title="使用RunLoop"></a>使用RunLoop</h2><p>Cocoa框架提供NSRunLoop类。在应用更底层，是一个指针指向CFRunLoopRef类型。</p>
<h6 id="获取runloop对象"><a href="#获取runloop对象" class="headerlink" title="获取runloop对象"></a>获取runloop对象</h6><p>在当前线程获取runloop：Cocoa框架用NSRunLoop 的 currentRunLoop 类方法。CoreFoundation框架用CFRunLoopGetCurrent方法。</p>
<h6 id="启动runloop"><a href="#启动runloop" class="headerlink" title="启动runloop"></a>启动runloop</h6><p>runloop必须有一个输入源或者时钟依附其上，不然就会立即退出。</p>
<p>有以下几种方式启动runloop：</p>
<ol>
<li>无条件的启动：是最简单的方式启动，可以添加或者删除输入源和时钟源。但是只有通过杀掉才能停止runloop。并且没有办法进入自定义的模式。</li>
<li>采用超时限制：只有当被分配的时间过期或者一个事件到达，runloop会退出。当一个事件到达，事件被分发处理，然后runloop退出；但可以再添加另一个事件。这个过期时间可以重新设定。</li>
<li>采用指定模式运行。</li>
</ol>
<p>a skeleton version of a thread’s main entry routine:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)skeletonThreadMain</span><br><span class="line">&#123;</span><br><span class="line">    // Set up an autorelease pool here if not using garbage collection.</span><br><span class="line">    BOOL done = NO;</span><br><span class="line"> </span><br><span class="line">    // Add your sources or timers to the run loop and do any other setup.</span><br><span class="line"> </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        // Start the run loop but return after each source is handled.</span><br><span class="line">        SInt32    result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);</span><br><span class="line"> </span><br><span class="line">        // If a source explicitly stopped the run loop, or if there are no</span><br><span class="line">        // sources or timers, go ahead and exit.</span><br><span class="line">        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))</span><br><span class="line">            done = YES;</span><br><span class="line"> </span><br><span class="line">        // Check for any other exit conditions here and set the</span><br><span class="line">        // done variable as needed.</span><br><span class="line">    &#125;</span><br><span class="line">    while (!done);</span><br><span class="line"> </span><br><span class="line">    // Clean up code here. Be sure to release any allocated autorelease pools.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runloop可以递归的执行。即：可以在任何的RunLoop方法内启动runloop的执行入口。</p>
<h6 id="退出runloop"><a href="#退出runloop" class="headerlink" title="退出runloop"></a>退出runloop</h6><p>两个方法退出：1.使用timeout机制退出。2.明确执行退出操作。</p>
<p>关于配置自定义输入源，参考官方文档。</p>
<p>参考文档：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/11/RunLoop/" data-id="cinbsbv940013sgzlzeiu424v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-KVO-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/09/KVO-PG/" class="article-date">
  <time datetime="2016-04-09T08:38:06.000Z" itemprop="datePublished">2016-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/09/KVO-PG/">KVO_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVO是一种机制被用于当其它对象指定属性改变时 观察对象被及时通知。在MVC工作模式下，KVO对Model属性改变及时通知Controller是非常有利的。</p>
<p>KVO主要优势在于不用开发时去用其它机制进行实现，基础框架已经做了很好的支持。</p>
<p>关于KVO相关扩展方法定义在 ： import Foundation.NSKeyValueObserving</p>
<h2 id="Register-KVO"><a href="#Register-KVO" class="headerlink" title="Register KVO"></a>Register KVO</h2><p>要实现对特定属性采用KVO机制进行观察，必须满足以下三点：</p>
<ol>
<li>被观察的类的指定属性必须是遵守KVO规则的。</li>
<li>必须让观察对象用addObserver:forKeyPath:options:context:向被观察对象注册。</li>
<li>观察对象必须实现observeValueForKeyPath:ofObject:change:context:。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ObserveredClass : NSObject &#123;</span><br><span class="line">    dynamic var value : String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InstanceClass : NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    // Receiving Notification of a Change</span><br><span class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">        if keyPath == &quot;value&quot; &#123;</span><br><span class="line">            print(change?[NSKeyValueChangeNewKey])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observered = ObserveredClass()</span><br><span class="line">let instance = InstanceClass()</span><br><span class="line"></span><br><span class="line">// Registering as an Observer</span><br><span class="line">instance.addObserver(observered, forKeyPath: &quot;value&quot;, options: NSKeyValueObservingOptions.New, context: nil)</span><br><span class="line">observered.value = &quot;123&quot;</span><br><span class="line"></span><br><span class="line">// Removing an Object as an Observer</span><br><span class="line">instance.removeObserver(observered, forKeyPath: &quot;value&quot;, context: nil)</span><br></pre></td></tr></table></figure>
<h2 id="KVO-Compliance"><a href="#KVO-Compliance" class="headerlink" title="KVO Compliance"></a>KVO Compliance</h2><p>符合KVO规则，需要有以下三点：</p>
<ol>
<li>这个类的观察属性必须是满足 KVC 规则的，KVO支持的数据类型和KVC一致。</li>
<li>类必须能触发属性改变的通知。</li>
<li>依赖的key注册也能适合运用。</li>
</ol>
<p>有两种方法触发属性改变通知。</p>
<h4 id="Auto-Change"><a href="#Auto-Change" class="headerlink" title="Auto Change"></a>Auto Change</h4><p>自动触发：NSObject提供了默认的支持，当属性是符合KVC规则时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Call the accessor method.</span><br><span class="line">[account setName:@&quot;Savings&quot;];</span><br><span class="line"> </span><br><span class="line">// Use setValue:forKey:.</span><br><span class="line">[account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.</span><br><span class="line">[document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span><br><span class="line">Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;</span><br><span class="line">NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure>
<h4 id="Manual-Change"><a href="#Manual-Change" class="headerlink" title="Manual Change"></a>Manual Change</h4><p>手动触发： 提供了更小粒度控制，何时、如何触发通知。可以减少不必要的触发，或者集合一定数量通知同时触发。</p>
<p>Class实现手动触发必须继承NSObject并且实现 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</span><br><span class="line"> </span><br><span class="line">    BOOL automatic = NO;</span><br><span class="line">    if ([theKey isEqualToString:@&quot;openingBalance&quot;]) &#123;</span><br><span class="line">        automatic = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        automatic = [super automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    return automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现手动通知观察者，在改变值前调用 willChangeValueForKey：，并在改变值后调用 didChangeValueForKey：；可优化触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setOpeningBalance:(double)theBalance &#123;</span><br><span class="line">    if (theBalance != _openingBalance) &#123;</span><br><span class="line">        [self willChangeValueForKey:@&quot;openingBalance&quot;];</span><br><span class="line">        _openingBalance = theBalance;</span><br><span class="line">        [self didChangeValueForKey:@&quot;openingBalance&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于to-many relationship，不但要指定属性值改变，而且要通过 NSKeyValueChange 表示 改变的类型  NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, or NSKeyValueChangeReplacement。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line"> </span><br><span class="line">    // Remove the transaction objects at the specified indexes.</span><br><span class="line"> </span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Registering-Dependent-Keys"><a href="#Registering-Dependent-Keys" class="headerlink" title="Registering Dependent Keys"></a>Registering Dependent Keys</h2><h4 id="To-one"><a href="#To-one" class="headerlink" title="To-one"></a>To-one</h4><p>注册依赖keys，自动触发通知可以 重写 keyPathsForValuesAffectingValueForKey： 方法 或者  根据规则实现适当的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,firstName, lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="重写-keyPathsForValuesAffectingValueForKey：-方法："><a href="#重写-keyPathsForValuesAffectingValueForKey：-方法：" class="headerlink" title="重写 keyPathsForValuesAffectingValueForKey： 方法："></a>重写 keyPathsForValuesAffectingValueForKey： 方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line"> </span><br><span class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现-keyPathsForValuesAffecting-方法"><a href="#实现-keyPathsForValuesAffecting-方法" class="headerlink" title="实现 keyPathsForValuesAffecting 方法"></a>实现 keyPathsForValuesAffecting<key> 方法</key></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于在扩展里，由于不能override keyPathsForValuesAffectingValueForKey，所以只能通过实现 keyPathsForValuesAffecting<key> 的方式实现。</key></p>
<h4 id="To-many"><a href="#To-many" class="headerlink" title="To-many"></a>To-many</h4><p>The keyPathsForValuesAffectingValueForKey: method does not support key-paths that include a to-many relationship. For example, suppose you have a Department object with a to-many relationship (employees) to a Employee, and Employee has a salary attribute. You might want the Department object have a totalSalary attribute that is dependent upon the salaries of all the Employees in the relationship. You can not do this with, for example, keyPathsForValuesAffectingTotalSalary and returning employees.salary as a key.</p>
<p>采用过渡的技巧实现，观察：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let totalSalaryContext = UnsafeMutablePointer&lt;Void&gt;()</span><br><span class="line"></span><br><span class="line">class Employee: NSObject &#123;</span><br><span class="line">    dynamic var salary : NSNumber = 1.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Department: NSObject &#123;</span><br><span class="line">    let employees : NSArray = [Employee(), Employee()]</span><br><span class="line">    dynamic var totalSalay : CGFloat = 0.0</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        employees.forEach &#123; (object) -&gt; () in</span><br><span class="line">            object.addObserver(self, forKeyPath: &quot;salary&quot;, options: NSKeyValueObservingOptions.New, context: totalSalaryContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        employees.forEach &#123; (object) -&gt; () in</span><br><span class="line">            object.removeObserver(self, forKeyPath: &quot;salary&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">        if (context == totalSalaryContext) &#123;</span><br><span class="line">            updateTotalSalary()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func updateTotalSalary() &#123;</span><br><span class="line">        let new = self.valueForKeyPath(&quot;employees.@sum.salary&quot;) as? NSNumber ?? 0</span><br><span class="line">        totalSalay = CGFloat(new)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let department = Department()</span><br><span class="line">department.addObserver(self, forKeyPath: &quot;totalSalay&quot;, options: NSKeyValueObservingOptions.New, context: nil)</span><br><span class="line"></span><br><span class="line">override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">    if keyPath == &quot;totalSalay&quot; &#123;</span><br><span class="line">        print(change?[NSKeyValueChangeNewKey])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(department.employees.lastObject as? Employee)?.salary = 20  //触发</span><br></pre></td></tr></table></figure>
<h2 id="Key-Value-Observing-Implementation-Details"><a href="#Key-Value-Observing-Implementation-Details" class="headerlink" title="Key-Value Observing Implementation Details"></a>Key-Value Observing Implementation Details</h2><p>自动KVO采用isa-swizzling的方法实现。</p>
<p>isa是一个指向操作分发表对象类的指针。对象类的分发表包含方法的实现和其它各种数据。</p>
<p>当一个观察对象向被观察对象注册一个属性时，被观察对象的isa指针改变，去指向一个中介的class而不再指向原来的class。所以这个isa指针不能再完全反应实例对象的实际class。</p>
<p>不能用改变后的isa指针去判定class关系。需要用类方法判定实例对象所属的类。</p>
<p>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/09/KVO-PG/" data-id="cinbsbv8g000dsgzloe2tygs1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-KVC-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/08/KVC-PG/" class="article-date">
  <time datetime="2016-04-08T10:31:50.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/08/KVC-PG/">KVC_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVC是NSKeyValueCoding协议定义的一种机制，用string标示对象属性，间接的使用对象的属性。本质上，KVC定义了相应的模式和方法进行校验从而满足应用采用valueForKey的方式接入。</p>
<p>访问器方法，提供接入应用数据模型的方式，有get访问器 和 set访问器。</p>
<p>在应用内实现KVC是一个很重要的原则，因为KVC是作为KVO、Core Data、Cocoa绑定、scriptability的重要基础。同时采用KVC也能简化应用编码。</p>
<p>key是一个字符串用于标示对象属性。key path是dot符号分隔的字符串序列，用于说明横穿对象属性路径。</p>
<p>在Foundation.NSKeyValueCoding库内，实现了对NSObject、Dictionary、Array等的扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    var value : String = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = KVCClass()</span><br><span class="line">let value = instance.valueForKey(&quot;value&quot;)  // value = &quot;123&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Accessor-Method"><a href="#Accessor-Method" class="headerlink" title="Accessor Method"></a>Accessor Method</h2><p>为了使KVC能使用像valueForKey:、setValue:forkey:等方法，则必须实现KVC的访问器方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    var temp : String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    func operate() -&gt; String &#123;</span><br><span class="line">        return temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setOperate(o : String) &#123;</span><br><span class="line">        temp = o</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tem = instance.valueForKey(&quot;operate&quot;)  // tem == &quot;&quot;</span><br><span class="line">instance.setValue(&quot;newValue&quot;, forKey: &quot;operate&quot;)  // </span><br><span class="line">tem = instance.valueForKey(&quot;operate&quot;)   // tem == &quot;newValue&quot;</span><br></pre></td></tr></table></figure>
<h5 id="常用访问器模式"><a href="#常用访问器模式" class="headerlink" title="常用访问器模式"></a>常用访问器模式</h5><p>-<key>、-is<key></key></key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)hidden &#123;</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isHidden &#123;</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set<key>:</key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setHidden: (BOOL)flag &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Collection访问器模式"><a href="#Collection访问器模式" class="headerlink" title="Collection访问器模式"></a>Collection访问器模式</h4><ol>
<li>mutableArrayValueForKey</li>
<li>mutableSetValueForKey</li>
</ol>
<h5 id="Getter-Indexed"><a href="#Getter-Indexed" class="headerlink" title="Getter Indexed"></a>Getter Indexed</h5><ol>
<li>-countOf<key></key></li>
<li>-objectIn<key>AtIndex:、-<key>AtIndexes: —- NSArray…objectAtIndex:.objectsAtIndexes:</key></key></li>
<li>-get<key>:range:</key></li>
</ol>
<h5 id="Mutable-Indexed"><a href="#Mutable-Indexed" class="headerlink" title="Mutable Indexed"></a>Mutable Indexed</h5><ol>
<li>-insertObject:in<key>AtIndex:、-insert<key>:atIndexes:</key></key></li>
<li>-removeObjectFrom<key>AtIndex:、-remove<key>AtIndexes:</key></key></li>
<li>-replaceObjectIn<key>AtIndex:withObject:、-replace<key>AtIndexes:with<key>:</key></key></key></li>
</ol>
<h4 id="无序的访问器模式"><a href="#无序的访问器模式" class="headerlink" title="无序的访问器模式"></a>无序的访问器模式</h4><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><ol>
<li>-countOf<key></key></li>
<li>-enumeratorOf<key></key></li>
<li>memberOf<key></key></li>
</ol>
<h5 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h5><ol>
<li>-add<key>Object:、-add<key>:</key></key></li>
<li>-remove<key>Object:、remove<key>:</key></key></li>
<li>-intersect<key>:</key></li>
</ol>
<h2 id="Key-Value-Validation"><a href="#Key-Value-Validation" class="headerlink" title="Key-Value Validation"></a>Key-Value Validation</h2><p>KVC提供了一个统一的API对属性的值进行确认。这套确认机制给予一个类接入属性值的机会、或者用其它的值替代，再或者抛出一个错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)validate&lt;Key&gt;:(id *)ioValue error: (NSError * __autoreleasing *)outError &#123;</span><br><span class="line">	return ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateOperate:(inout id  _Nullable __autoreleasing *)ioValue error:(out NSError * _Nullable __autoreleasing *)outError &#123;</span><br><span class="line">    </span><br><span class="line">    *ioValue = @&quot;validate&quot;;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    KVCClass * instance = [[KVCClass alloc] init];</span><br><span class="line">    NSString * o = [[NSString alloc] init];</span><br><span class="line">    [instance validateValue:&amp;o forKey:@&quot;operate&quot; error:nil];</span><br><span class="line">    NSLog(@&quot;%@&quot;, o);   // 打印出 validate</span><br></pre></td></tr></table></figure>
<p>或者<br>The default implementation of this method searches the class of the receiver for a validator method whose name matches the pattern -validate<key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, YES is returned.</key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    override func validateValue(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String) throws &#123;</span><br><span class="line">        if inKey == &quot;operate&quot; &#123;</span><br><span class="line">            throw NSError(domain: &quot;KVC&quot;, code: 200, userInfo: nil)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try super.validateValue(ioValue, forKey: inKey)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var mu = UnsafeMutablePointer&lt;AnyObject?&gt;.alloc(1)</span><br><span class="line">var autoO = AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;(mu)</span><br><span class="line">do &#123;</span><br><span class="line">    try instance.validateValue(autoO, forKey: &quot;operate&quot;)</span><br><span class="line">    print(autoO.memory)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)             //  &quot;Error Domain=KVC Code=200 &quot;(null)&quot;\n&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if inKey == &quot;operate&quot; &#123;</span><br><span class="line">          ioValue.memory = &quot;validate&quot;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          try super.validateValue(ioValue, forKey: inKey)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      do &#123;</span><br><span class="line">  		try instance.validateValue(autoO, forKey: &quot;operate&quot;)</span><br><span class="line">  		print(autoO.memory)			//  &quot;validate\n&quot;</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  		print(error)      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出情况：</p>
<ol>
<li>object被确认，返回YES。</li>
<li>object不能被确认，并且没有一个可用的值可返回，则根据是否传Error设置错误，并返回NO。</li>
<li>一个新的值创建并返回，确认返回YES。</li>
</ol>
<h5 id="Automatic-Validation"><a href="#Automatic-Validation" class="headerlink" title="Automatic Validation"></a>Automatic Validation</h5><p>一般情况下KVC是不会自动招待validation，这是应用内应该做的校验责任。<br>但是像CoreData在执行保存的时候是自动validation的。</p>
<h2 id="Ensuring-KVC-Compliance"><a href="#Ensuring-KVC-Compliance" class="headerlink" title="Ensuring KVC Compliance"></a>Ensuring KVC Compliance</h2><p>为了让一个类的特定属性被认为是遵守KVC承诺的，则该类必须为了valueForKey:与setValue:forKey:能运行而实现对应的方法。</p>
<h4 id="To-One"><a href="#To-One" class="headerlink" title="To-One"></a>To-One</h4><ol>
<li>-<key>, -is<key> 或者 实例变量  <key>, _<key></key></key></key></key></li>
<li>可修改时要实现 -set<key>:</key></li>
<li>实现了-set<key>:则不能执行确认。</key></li>
<li>如果属性需要进行校验确认则需要实现 -validate<key>:error:。</key></li>
</ol>
<h4 id="Indexed-To-Many"><a href="#Indexed-To-Many" class="headerlink" title="Indexed To-Many"></a>Indexed To-Many</h4><ol>
<li>-<key> 或者 实例变量 <key>, _<key></key></key></key></li>
<li>-countOf<key>,  -objectIn<key>AtIndex:  或者  -<key>AtIndexes:</key></key></key></li>
<li>可选  -get<key>:range:</key></li>
</ol>
<p>对于可修改的：</p>
<ol>
<li>-insertObject:in<key>AtIndex: 或者  -insert<key>:atIndexes:</key></key></li>
<li>-removeObjectFrom<key>AtIndex 或者  -remove<key>AtIndexes:</key></key></li>
<li>-replaceObjectIn<key>AtIndex:withObject:  或者  -replace<key>AtIndexIndexes:with<key></key></key></key></li>
</ol>
<h4 id="Unordered-To-Many"><a href="#Unordered-To-Many" class="headerlink" title="Unordered To-Many"></a>Unordered To-Many</h4><ol>
<li>-<key> 或者 实例变量 <key> , _<key></key></key></key></li>
<li>-countOf<key>, -enumeratorOf<key> , -memberOf<key>:</key></key></key></li>
</ol>
<p>可修改：</p>
<ol>
<li>-add<key>Object: or -add<key>:</key></key></li>
<li>-remove<key>Object: or -remove<key>:</key></key></li>
<li>-interscet<key>: and -set<key>:</key></key></li>
</ol>
<h2 id="Scalar-and-Structure"><a href="#Scalar-and-Structure" class="headerlink" title="Scalar and Structure"></a>Scalar and Structure</h2><p>KVC提供对scalar值和数据结构的自动封包与解包成NSNumber 和 NSValue</p>
<h4 id="Handling-nil-Values"><a href="#Handling-nil-Values" class="headerlink" title="Handling nil Values"></a>Handling nil Values</h4><p>当nil被作为非对象值传入setValue:forKey:方法时，则receiver会调用setNilValueForKey:，而setNilValueForKey:默认实现是抛出一个NSInvalidArgumentException异常。可心在subclass里面重写指定的属性实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override func setNilValueForKey(key: String) &#123;</span><br><span class="line">    if key == &quot;age&quot; &#123;</span><br><span class="line">        self.setValue(0, forKey: key)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.setNilValueForKey(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collection-Operators"><a href="#Collection-Operators" class="headerlink" title="Collection Operators"></a>Collection Operators</h2><p>collection operators 允许在一个集合的元素上用keyPath标示符和action操作符表示执行操作。collection operators 表示作为参数传入valueForKeyPath的特定keyPath。 operator操作符 是一个@开头的特定字符串。</p>
<ol>
<li>在操作符左边的keyPath标示指向操作的集合。</li>
<li>在操作符右边的keyPath标示在集合对象内的属性路径。</li>
</ol>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/kvc_pg_figure1.jpg" alt="Operator key path format"></p>
<p>操作返回的对象值取决于操作符类型：</p>
<ol>
<li>简单的操作符返回 字符、数字、日期等。</li>
<li>对象操作符返回NSArray数组对象。</li>
<li>数组和Set操作符返回数组和set对象。</li>
</ol>
<p>source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class KVCObject : NSObject &#123;</span><br><span class="line">    var payee : String</span><br><span class="line">    var amount : Int</span><br><span class="line">    var date : NSDate</span><br><span class="line">    </span><br><span class="line">    init(p : String, a : Int, d : NSDate) &#123;</span><br><span class="line">        payee = p</span><br><span class="line">        amount = a</span><br><span class="line">        date = d</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let k0 = KVCObject(p: &quot;Green Power&quot;, a: 120, d: NSDate(timeIntervalSinceNow: 200))</span><br><span class="line">let k1 = KVCObject(p: &quot;Green Power&quot;, a: 150, d: NSDate(timeIntervalSinceNow: 300))</span><br><span class="line">let k2 = KVCObject(p: &quot;Green Power&quot;, a: 170, d: NSDate(timeIntervalSinceNow: 400))</span><br><span class="line"></span><br><span class="line">let k3 = KVCObject(p: &quot;Car Loan&quot;, a: 250, d: NSDate(timeIntervalSinceNow: 300))</span><br><span class="line">let k4 = KVCObject(p: &quot;Car Loan&quot;, a: 250, d: NSDate(timeIntervalSinceNow: 500))</span><br><span class="line"></span><br><span class="line">let transactions : NSArray = [k0, k1, k2, k3, k4]</span><br></pre></td></tr></table></figure>
<h4 id="Smiple"><a href="#Smiple" class="headerlink" title="Smiple"></a>Smiple</h4><p>######@avg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tranAvg = transactions.valueForKeyPath(&quot;@avg.amount&quot;)  // tranAvg : NSNumber  188</span><br></pre></td></tr></table></figure>
<p>#####@count<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tranCount = transactions.valueForKeyPath(&quot;@count&quot;)    // tranCount : NSNumber 5</span><br></pre></td></tr></table></figure></p>
<p>其它： @max @min  @sum  </p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h6 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a>@distinctUnionOfObjects</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let payees = transactions.valueForKeyPath(&quot;@distinctUnionOfObjects.payee&quot;)  // [&quot;Green Power&quot;, &quot;Car Loan&quot;]</span><br></pre></td></tr></table></figure>
<h6 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a>@unionOfObjects</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let payees = transactions.valueForKeyPath(&quot;@unionOfObjects.payee&quot;)  //[&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="Array-and-Set"><a href="#Array-and-Set" class="headerlink" title="Array and Set"></a>Array and Set</h4><p>@distinctUnionOfArrays  @unionOfArrays  @distinctUnionOfSets</p>
<h2 id="Accessor-Search"><a href="#Accessor-Search" class="headerlink" title="Accessor Search"></a>Accessor Search</h2><p>KVC是尝试用访问器get和set值。但是如何判定值是如何接入？</p>
<h5 id="Accessor-Search-Patterns-for-Simple-Attributes"><a href="#Accessor-Search-Patterns-for-Simple-Attributes" class="headerlink" title="Accessor Search Patterns for Simple Attributes"></a>Accessor Search Patterns for Simple Attributes</h5><p>####### setValue:forKey:</p>
<ol>
<li>搜索 set<key>:</key></li>
<li>如果没有访问器方法找到，并且类方法accessInstanceVariablesDirectly返回YES，则搜索实例变量类似_<key>,_is<key>,<key>,is<key></key></key></key></key></li>
<li>如果匹配上相应方法，则使用获得的值。如果有封解包操作的必要，则执行。</li>
<li>如果以上操作都失败，则调用setValue:forUndefinedKey:。</li>
</ol>
<h6 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey:"></a>valueForKey:</h6><ol>
<li>搜索get<key>,<key>,is<key>方法，如果找到则调用。如果有封解包操作的必要，则执行。</key></key></key></li>
<li>如果没有找到就搜索Array相关方法，countOf<key>,objectIn<key>AtIndex:等，详细方法看官方文档说明。</key></key></li>
<li>如果依然没有找到，则搜索Set的相关方法，enumeratorOf<key>,memberOf<key>等。</key></key></li>
<li><strong>如果以上操作都失败，并且类方法accessInstanceVariablesDirectly返回YES</strong>，则搜索实例变量类似_<key>,_is<key>,<key>,is<key>等，如果有封解包操作的必要，则执行。</key></key></key></key></li>
<li><strong>以上都失败，最后调用 valueForUndefinedKey:</strong>。</li>
</ol>
<p>对于 Accessor Search Pattern for Ordered Collections，Accessor Search Pattern for Uniquing Ordered Collections，Accessor Search Pattern for Unordered Collections<br>的搜索顺序，看官方文档，基本也Simple相似。</p>
<p>参考官方文档： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/08/KVC-PG/" data-id="cinbsbv8i000gsgzl4yh8y3xf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-EventHandler-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/EventHandler-PG/" class="article-date">
  <time datetime="2016-04-07T06:55:15.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对事件的响应是应用的灵魂所在。</p>
<p><strong>一个事件沿着特定的路径分发到可以响应处理它的对象上</strong>，首先，UIApplication对象从事件队列顶取出一个事件分发准备处理。分发到key window对象上，window将事件赋予一个初始化对象处理。实始化对象取决于事件的类型。</p>
<ol>
<li>点击事件：对于点击事件，window先向一个发生点击事件的view分发，此view称为hit-test view。寻找view的过程称为：hit-testing。</li>
<li>Motion 和 远程 事件：window将事件发送到first responder处理。</li>
</ol>
<p>UIKit first sends the event to the object that is best suited to handle the event. For touch events, that object is the hit-test view, and for other events, that object is the first responder.</p>
<h2 id="hit-testing"><a href="#hit-testing" class="headerlink" title="hit-testing"></a>hit-testing</h2><p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_1.jpg" alt="Figure2_1"></p>
<p>如图，假设用户点击2-1上的E视图。iOS查找hit-test view检查顺序：</p>
<ol>
<li>touch事件在视图A内发生，所以检查视图B、C。</li>
<li>touch事件没有在视图B内，在而视图C内，所以检查视图D、E。</li>
<li>touch事件没有在视图D内，但在视图E内。</li>
<li>在视力层次结构里，视图E是最底层的，所以视图变成hist-test view。</li>
</ol>
<p>hitTest:withEvent:方法返回hit-test view通过 CGPoint point 和 UIEvent。hitTest:withEvent:方法首先调用自己的pointInside:withEvent:方法。如果传入hitTest:withEvent:方法的point在视图之内，则pointInside:withEvent:返回YES。然后hitTest方法在子视图上递归调用hitTest方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CustomHitTestView: UIView &#123;</span><br><span class="line">    </span><br><span class="line">    override func hitTest(point: CGPoint, withEvent event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line">        return self</span><br><span class="line">//        return super.hitTest(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func pointInside(point: CGPoint, withEvent event: UIEvent?) -&gt; Bool &#123;</span><br><span class="line">        return super.pointInside(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Regulating-the-Delivery-of-Touches-to-Views"><a href="#Regulating-the-Delivery-of-Touches-to-Views" class="headerlink" title="Regulating the Delivery of Touches to Views"></a>Regulating the Delivery of Touches to Views</h2><p>window首先将touch事件发送到任何依附于hit-test view（或者其父视图吗？）的Gesture。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/1_5.jpg" alt="Figure1_5"></p>
<p><strong>Gesture Recognizers Get the First Opportunity to Recognize a Touch</strong></p>
<p>window延迟向view分发事件，让手势识别器有机会先分析touch。在延迟期间，如果手势识别器识别到touch手势，则window不会分发touch事件到view，并且会取消之前已经分发到view上和这个识别序列有关的touch object。</p>
<h2 id="Creating-a-Custom-Gesture-Recognizer"><a href="#Creating-a-Custom-Gesture-Recognizer" class="headerlink" title="Creating a Custom Gesture Recognizer"></a>Creating a Custom Gesture Recognizer</h2><p>在自定义手势，则需要实现 UIGestureRecognizerSubclass 下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public func reset()</span><br><span class="line">public func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br></pre></td></tr></table></figure>
<p>Guide内的例子如下，不过官网上的代码有点Bug：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import UIKit.UIGestureRecognizerSubclass</span><br><span class="line"></span><br><span class="line">class CustomGestureRecognizer: UIGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    private var midPoint = CGPointZero</span><br><span class="line">    var strokeUp = false</span><br><span class="line">    </span><br><span class="line">    override func reset() &#123;</span><br><span class="line">        super.reset()</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesBegan(touches, withEvent:event)</span><br><span class="line">        </span><br><span class="line">        if touches.count != 1 &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesMoved(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state != .Failed else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let win = self.view?.window</span><br><span class="line">        let nowPoint = touches.first?.locationInView(win)</span><br><span class="line">        let prevPoint = touches.first?.previousLocationInView(win)</span><br><span class="line">        </span><br><span class="line">        guard let now = nowPoint, let prev = prevPoint where !strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if now.x &gt;= prev.x &amp;&amp; now.y &gt;= prev.y &#123;</span><br><span class="line">            midPoint = now</span><br><span class="line">        &#125; else if now.x &gt;= midPoint.x &amp;&amp; now.y &lt;= midPoint.y &#123;</span><br><span class="line">            strokeUp = true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesEnded(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state == .Possible &amp;&amp; strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        state = UIGestureRecognizerState.Recognized</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesCancelled(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">        state = .Failed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以参考这个例子 ： <a href="https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers" target="_blank" rel="external">https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers</a></p>
<p><strong>在完成hit-testing 且没有手势识别后，view作为responser开始响应</strong></p>
<h2 id="Responder-Object"><a href="#Responder-Object" class="headerlink" title="Responder Object"></a>Responder Object</h2><p>Responder Object是一个能够响应和处理事件的对象，UIResponder是所以Responder Object的基类。<br>一个对象成为First Responder需要做以下两个任务：</p>
<ol>
<li>Overriding the canBecomeFirstResponder method to return YES.</li>
<li>Receiving a becomeFirstResponder message. If necessary, an object can send itself this message.</li>
</ol>
<h2 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h2><p>定义：The responder chain is a series of linked responder objects. It starts with the first responder and ends with the application object.</p>
<p>作用：If the first responder cannot handle an event, it forwards the event to the next responder in the responder chain.</p>
<p>响应链用于收下事件：</p>
<ol>
<li>点击事件，事件响应开始于 hit-test view。</li>
<li>Motion：要处理shake-motion事件，第一响应者需要实现UIResponder下motionBegan:withEvent: or motionEnded:withEvent:方法。</li>
<li>Remote：要处理remote事件，第一响应者必须实现UIResponder的 remoteControlReceivedWithEvent:  方法。</li>
<li>Action Message：当操作一个Control，当添加Target并设置为nil时，这个message将沿着responder chain传递。</li>
<li>Editing-menu Message。</li>
<li>Text editing。</li>
</ol>
<h2 id="Responder-Chain-delivery-Path"><a href="#Responder-Chain-delivery-Path" class="headerlink" title="Responder Chain delivery Path"></a>Responder Chain delivery Path</h2><p>如果initial对象（hit-test view 或者 first Responder）不能处理事件，则将事件通过next Responder沿着Chain传递。每个Responder决定是否处理这个事件，或者沿着Chain继续传递下去。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_2.jpg" alt="Figure2_2"></p>
<p>参考官方文档链接：<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/EventHandler-PG/" data-id="cinbsbv8a000csgzlpdogxsh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OC-运行时概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/OC-运行时概记/" class="article-date">
  <time datetime="2016-04-06T12:29:15.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>必然时间太久还是会忘，还是记一下吧。</p>
<p>Guide中对runtime解释：The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
<p>OC将决议从编译时延迟到运行时，作为动态运行。这意味着不但需要编译器，同时还需要一个运行时系统来执行编译代码。这个运行时系统为OC充当一个操作系统，使其能够运行。</p>
<h3 id="Interact"><a href="#Interact" class="headerlink" title="Interact"></a>Interact</h3><ol>
<li>通过源码实现功能，编译后动态运行。</li>
<li>通过NSObject 提供的部分查询method，如methodForSelector: \ respondsToSelector:等。</li>
<li>通过runtime functions。</li>
</ol>
<p>OC定义Class结构，在/objc/runtime.h中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>表示一个实例对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看几个重要的定义：<br>OC版本源文件内定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">struct objc_method_description &#123;</span><br><span class="line">	SEL name;               /**&lt; The name of the method */</span><br><span class="line">	char *types;            /**&lt; The types of the method arguments */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>在Swift库中已经预留出和OC版源文件相同的头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import ObjectiveC.List</span><br><span class="line">import ObjectiveC.NSObjCRuntime</span><br><span class="line">import ObjectiveC.NSObject</span><br><span class="line">import ObjectiveC.Object</span><br><span class="line">import ObjectiveC.Protocol</span><br><span class="line">import ObjectiveC.message</span><br><span class="line">import ObjectiveC.objc</span><br><span class="line">import ObjectiveC.objc_api</span><br><span class="line">import ObjectiveC.objc_auto</span><br><span class="line">import ObjectiveC.objc_class</span><br><span class="line">import ObjectiveC.objc_exception</span><br><span class="line">import ObjectiveC.objc_load</span><br><span class="line">import ObjectiveC.objc_runtime</span><br><span class="line">import ObjectiveC.objc_sync</span><br><span class="line">import ObjectiveC.runtime</span><br></pre></td></tr></table></figure>
<p>在Apple开源的Foundation project内有如此说明：</p>
<p><strong>Runtime: The basis for interoperability.</strong></p>
<p>The classes and methods in this group provide an interface for interoperability between C code and Swift. They also provide common layers used throughout the framework such as the root class NSObject.</p>
<ol>
<li>NSObject is mostly implemented.</li>
<li>NSEnumerator is fully implemented.</li>
<li>NSSwiftRuntime (internal use only) contains Swift runtime-specific functionality.</li>
<li>NSObjCRuntime is missing some key parts such as NSClassFromString. Much of the functionality here is specific to the Objective-C runtime and is not relevant when building for Swift.</li>
</ol>
<p>Swift库ObjectiveC.runtime内定义，对runtime用Swift语法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">public typealias Method = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">public typealias Ivar = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">public typealias Category = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">public typealias objc_property_t = COpaquePointer</span><br><span class="line"></span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">public struct objc_method_description &#123;</span><br><span class="line">    /**&lt; The name of the method */</span><br><span class="line">    public var name: Selector</span><br><span class="line">    /**&lt; The types of the method arguments */</span><br><span class="line">    public var types: UnsafeMutablePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: Selector, types: UnsafeMutablePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">public struct objc_property_attribute_t &#123;</span><br><span class="line">    /**&lt; The name of the attribute */</span><br><span class="line">    public var name: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">    public var value: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: UnsafePointer&lt;Int8&gt;, value: UnsafePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Method 表示方法，分成Selector 和 IMP 部分。</li>
<li>Ivar 表示实例对象的变量。</li>
<li>Category 表示OC范筹。</li>
<li>objc_property_t 表示属性。</li>
</ol>
<h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h3><ol>
<li>将语法 [receiver message] 翻译成 objc_msgSend(receiver, selector)。</li>
<li>在objc_cache中查找方法。</li>
<li>如果在cache中没找到，则在 objc_method_list 里查找， 如果找到则 缓存。</li>
<li>如果在 objc_method_list 里没找到，则在指向父类查找。</li>
</ol>
<h3 id="Dynamic加载"><a href="#Dynamic加载" class="headerlink" title="Dynamic加载"></a>Dynamic加载</h3><h6 id="Dynamic-Method-Resolution"><a href="#Dynamic-Method-Resolution" class="headerlink" title="Dynamic Method Resolution"></a>Dynamic Method Resolution</h6><p>定义一个Class 未实现 objectSend方法，动态用 resolveObjectSend方法替换实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)resolveObjectSend &#123;</span><br><span class="line">    NSLog(@&quot;resolve message send ....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    if (sel == @selector(objectSend)) &#123;</span><br><span class="line">        IMP res = class_getMethodImplementation([self class], @selector(resolveObjectSend));</span><br><span class="line">        BOOL result = class_addMethod([self class], sel, res, &quot;v@:&quot;);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            NSLog(@&quot;method added ....&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否为 objectSend 消息。</li>
<li>用运行时方法取出 resolveObjectSend 方法 对应的实现。</li>
<li>增加方法，用 resolveObjectSend 的实现 作为 objectSend 的实现。</li>
</ol>
<p>对于实例方法或者类方法没有实现的，可以用 resolveInstanceMethod 或者 resolveClassMethod 动态添加实现。</p>
<h3 id="消息转发-Message-Forwarding"><a href="#消息转发-Message-Forwarding" class="headerlink" title="消息转发 Message Forwarding"></a>消息转发 Message Forwarding</h3><p>在发送一个消息对对象后，如果对象不能处理消息，则会产生运行时错误，在抛出这个错误之前runtime会用forwardInvocation再进行一次处理 — 称为消息转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void) forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([anInvocation selector] == @selector(objectSend)) &#123;</span><br><span class="line">        anInvocation.selector = @selector(resolveObjectSend);</span><br><span class="line">        [anInvocation invokeWithTarget:another];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature * signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        signature = [another methodSignatureForSelector:@selector(resolveObjectSend)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时func使用"><a href="#运行时func使用" class="headerlink" title="运行时func使用"></a>运行时func使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">    var pro : NSArray = [1, 2]</span><br><span class="line">    var pro1 : NSString = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObject = MyClass()</span><br><span class="line">myObject.pro = [2, 3]</span><br><span class="line"></span><br><span class="line">let proName : String = &quot;pro&quot;</span><br><span class="line">let iii : [CChar]? = proName.cStringUsingEncoding(NSUTF8StringEncoding)</span><br><span class="line">let iva : Ivar = class_getInstanceVariable(MyClass.self, iii!)</span><br><span class="line">let valueForIva = object_getIvar(myObject, iva)  // [2, 3]</span><br><span class="line"></span><br><span class="line">var count : UInt32 = 0</span><br><span class="line">let list = class_copyIvarList(MyClass.self, &amp;count)</span><br><span class="line"></span><br><span class="line">for i in 0..&lt;Int(count) &#123;</span><br><span class="line">    let name = ivar_getName(list[i])</span><br><span class="line">    print(String(UTF8String: name))  // Optional(&quot;pro&quot;)   // Optional(&quot;pro1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let my = MyClass()</span><br><span class="line">object_getIvar(my, list[1])   // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">list.dealloc(2)</span><br></pre></td></tr></table></figure>
<p>参考官方文档地址： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/OC-运行时概记/" data-id="cinbsbv8r000msgzlxxscr9nn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pattern/">Pattern</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Pattern/" style="font-size: 15px;">Pattern</a> <a href="/tags/Swift/" style="font-size: 17.5px;">Swift</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/后端/" style="font-size: 17.5px;">后端</a> <a href="/tags/工具/" style="font-size: 12.5px;">工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/22/ViewController3-PG/">ViewController3-PG</a>
          </li>
        
          <li>
            <a href="/2016/04/21/ViewController2-PG/">ViewController2-PG</a>
          </li>
        
          <li>
            <a href="/2016/04/20/ViewController-PG/">ViewController-PG</a>
          </li>
        
          <li>
            <a href="/2016/04/18/View-PG/">View-PG</a>
          </li>
        
          <li>
            <a href="/2016/04/12/Concurrency-PG/">Concurrency-PG</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 天晷<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>