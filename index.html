<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>天晷</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="天晷">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="天晷">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天晷">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="天晷" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天晷</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">脑容量有限，清理出来装灵感吧！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-View-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/View-PG/" class="article-date">
  <time datetime="2016-04-18T02:42:01.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/View-PG/">View-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>windows和view呈现应用的内容到屏幕上。</p>
<p>window主要功能可以认为是一个容器，协调管理views与用户的交互。</p>
<p>view用于封装需要展示的内容作为window的一部分呈现，占用区域一定是一个矩形。绘制内容、touch交互事件、管理子视图布局。绘制涉及到的图形技术主要是Core Graphics，OpenGL ES，以及UIKit提供的封装。</p>
<p>Animations是和应用发生交互时，在界面上以可视的效果给用户进行实时反馈的机制。</p>
<h2 id="view-and-window构造"><a href="#view-and-window构造" class="headerlink" title="view and window构造"></a>view and window构造</h2><p>view对象在屏幕上定义一个矩形区域用于绘制和处理在区域内的touch事件。view同时可以作为其它view的父视图，管理子视图的位置和大小。</p>
<p>view结合Core Animation的layer处理渲染内容和动画展示。每个view都需要结合一个Layer完成渲染和动画动作。iOS采用layer对象方式在性能提升方面有很重要的作用。</p>
<h5 id="content-mode"><a href="#content-mode" class="headerlink" title="content mode"></a>content mode</h5><p>view的Content mode定义当改变视图几何属性时，如何重新使用content的机制。当一个视图第一次显示，视图渲染内容并在后台保持底层的位图。当以下情况发生时，由content mode属性决定如何重新使用位图进行展示：</p>
<ol>
<li>改变视图的宽度或者高度引起frame和bounds的改变。</li>
<li>改变视图transform属性引起缩放因子的改变。</li>
</ol>
<h5 id="Animation-Support"><a href="#Animation-Support" class="headerlink" title="Animation Support"></a>Animation Support</h5><p>由于view视图内容是基于layer对象，此机制使执行与view相关的动画非常容易。</p>
<p>view大多数属性是支持动画执行，可以定义为半自动的执行方式，通过基于view的属性执行动画，需要按照以下步骤：</p>
<ol>
<li>告诉UIKit框架需要执行动画。</li>
<li>改变需要执行动画view的属性的值。</li>
</ol>
<h5 id="view-几何特性与坐标系统"><a href="#view-几何特性与坐标系统" class="headerlink" title="view 几何特性与坐标系统"></a>view 几何特性与坐标系统</h5><p>默认的坐标系统是以左上角为原点，坐标轴从原点垂直向下和水平向右扩展。每个子视图都依赖其自身的坐标系统。</p>
<h6 id="Frame、Bounds、Center关系"><a href="#Frame、Bounds、Center关系" class="headerlink" title="Frame、Bounds、Center关系"></a>Frame、Bounds、Center关系</h6><p>view对象通过Frame、Bounds、Center属性展示其位置和大小：</p>
<ol>
<li>frame属性是一个矩形区域，指定当前视图在其父视图内的位置和大小。</li>
<li>bounds属性是一个矩形区域，指定是的当前视图包含区域，定义视图的本地坐标系统。</li>
<li>center属性指定当前视图的anchor点在其父视图内的位置。</li>
<li>当改变frame属性，会引起bounds、center的改变。</li>
<li>当改变bounds属性，会引起frame的改变，不会影响center。</li>
<li>当改变center属性，会引起frame的改变，不会影响bounds。</li>
</ol>
<h5 id="运行时交互模型"><a href="#运行时交互模型" class="headerlink" title="运行时交互模型"></a>运行时交互模型</h5><p>任何时间当用户与界面产生交互，或者程序代码引起一些变化，将会产生一系列复杂的事件提供给UIKit框架去处理相应的交互。在该系列事件特定关键点上，UIKit框架唤起view对应的class对象，给予程序代码响应程序事件的机会。下图展示了事件发生时，唤起事件处理的关键点：</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/view_PG_F1_7.jpg" alt="view_PG_F1_7"></p>
<p>上图按步骤表述了事件执行序列并解释不同步骤发生了什么，同时说明在程序代码内如何去作出响应：</p>
<ol>
<li>用户在屏幕上点击。</li>
<li>系统硬件将事件转化后，转发到UIKit框架。</li>
<li>UIKit框架打包touch事件，并分发到相应的view。（该过程由Event Handle PG处理）</li>
<li>事件处理代码负责响应事件：（a）改变视图的属性。（b）调用setNeedsLayout方法，标记view需要更新布局。（c）调用setNeedsDisplay或者setNeedsDisplayInRect：方法标记视图（包括子视图）需要重新绘制。（d）通知controller更改数据块。</li>
<li>如果视图的几何属性发生改变，UIKit框架根据以下规则更新子视图：（a）如果视图配置auto resize规则，则根据相应规则更新视图。（b）如果view实现的layoutSubviews方法，UIKit框架调用些方法。<strong>可以通过此方法适配任何子视图的位置和大小</strong>。</li>
<li>如果视图的任何部分被标记为需要重新绘制，UIKit框架询问view进行重绘。对于自定义视图，UIKit框架明确调用drawRect：方法。此方法只处理视图绘制相关的工作，不能用于处理数据等工作。</li>
<li>任何更新过的view视图与应用其它部分可视内容被打包到一起，发送到图形硬件进行显示。</li>
<li>图形硬件转化渲染内容到屏幕上。</li>
</ol>
<p>在以上的步骤中，主要用于自定义视图的集成点：</p>
<ol>
<li>event-handling方法：</li>
<li>layoutSubviews方法。</li>
<li>drawRect:方法。</li>
</ol>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>每个iOS应用程序需要至少一个window。window对象主要的职责：</p>
<ol>
<li>展示应用程序的可视化内容。</li>
<li>充当一个分发touch事件到指定view视图和其它应用对象的角色。</li>
<li>和view controllers协同工作响应设备方向的改变。</li>
</ol>
<h6 id="window-Level"><a href="#window-Level" class="headerlink" title="window Level"></a>window Level</h6><p>用一个浮点数表示(public typealias UIWindowLevel = CGFloat<br>)，常用的三种层次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(UIWindowLevelNormal)  // 0.0</span><br><span class="line">print(UIWindowLevelStatusBar)    // 1000.0</span><br><span class="line">print(UIWindowLevelAlert)      // 2000.0</span><br></pre></td></tr></table></figure>
<h6 id="Monitor-Window-changes"><a href="#Monitor-Window-changes" class="headerlink" title="Monitor Window changes"></a>Monitor Window changes</h6><p>与window相关的通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIWindowDidBecomeVisibleNotification</span><br><span class="line">UIWindowDidBecomeHiddenNotification</span><br><span class="line">UIWindowDidBecomeKeyNotification</span><br><span class="line">UIWindowDidResignKeyNotification</span><br></pre></td></tr></table></figure>
<h4 id="External-Display"><a href="#External-Display" class="headerlink" title="External Display"></a>External Display</h4><p>主要的基本处理过程如下：</p>
<ol>
<li>在程序启动时，注册screen的连接和断开连接通知。</li>
<li>当需要在扩展屏幕上显示内容时，创建和配置一个window：（a）通过UIScreen的screens获得扩展屏幕对象。（b）创建一个window对象并配置适当的大小。（c）当扩展屏幕对象赋值给新建的window对象。（d）根据屏幕分辨率适配显示内容。（e）添加任何适当的内容到window上。</li>
<li>显示window对象，并正常的处理更新。</li>
</ol>
<h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>view对象提供应用与用户主要的交互方式，必须执行相应的职责：</p>
<ol>
<li>布局与子视图管理：（a）视图定义自己的resizing行为关联到其父视图上。（b）一个视图能管理多个子视图。（c）视图可以根据需要动态改变子视图的位置与大小。（d）视图可以将自坐标系统里的点转换到对应的视图或者window坐标系统上。</li>
<li>绘制图象和动画呈现：（a）在视图的矩形区域内绘制图象内容。（b）改变视图属性，以动画形势给用户反馈，属性值改变。</li>
<li>事件处理：（a）视图可以接收事件。（b）事件是事件响应链的一部分。</li>
</ol>
<h4 id="Adjusting-the-Size-and-Position-of-Views-at-Runtime"><a href="#Adjusting-the-Size-and-Position-of-Views-at-Runtime" class="headerlink" title="Adjusting the Size and Position of Views at Runtime"></a>Adjusting the Size and Position of Views at Runtime</h4><p>当视图的size发生变化，其子视图的位置与大小必须依据情况作出改变。视图支持自动和手动改变布局。在自动布局情况下，子视图依据父视图设置的规则进行变化；在手动情况下，在应用来创建代码根据需要来控制子视图的大小和位置。</p>
<h6 id="Layout-change-触发事件"><a href="#Layout-change-触发事件" class="headerlink" title="Layout change 触发事件"></a>Layout change 触发事件</h6><p>Layout发生改变，当有以下事件发生时：</p>
<ol>
<li>视图的bounds的size发生改变。</li>
<li>当设备方向发生变化，通常根据是应用触发的根视图的bounds矩形发生变化。</li>
<li>当一组子图层关联的父图层发生变化并需要重新布局时。</li>
<li>当应用调用setNeedsLayout或者layoutIfNeeded方法强制更新视图时。</li>
<li>当应用在关联的视图图层调用setNeedsLayout方法强制布局更新。</li>
</ol>
<h5 id="使用Autoresizing-Rules处理自动布局"><a href="#使用Autoresizing-Rules处理自动布局" class="headerlink" title="使用Autoresizing Rules处理自动布局"></a>使用Autoresizing Rules处理自动布局</h5><p>父视图的autoresizesSubviews属性决定子视图是否支持resize。如果该属性设置成YES，则在父视图发生改变要求子视图需要重新布局时，子视图用autoresizingMask属性来决定如何改变位置和大小。</p>
<p>下表列出autoresizingMask可用的取值：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/view_PG_T3_2.jpg" alt="view_PG_T3_2"></p>
<p>当视图在同一轴上有超过一个灵活配置属性，UIKit框架分配等比例在相应的空间上。</p>
<h5 id="通过代码直接控制View布局"><a href="#通过代码直接控制View布局" class="headerlink" title="通过代码直接控制View布局"></a>通过代码直接控制View布局</h5><p>当视图的size发生变化，UIKit框架应用autoresizing行为在子视图上，然后再调用视图layoutSubviews方法使应用可以再次通过代码控制视图布局。我们可以在应用内实现layoutSubviews方法，当autoresizing行为不能满足要求时，再通过code改变。</p>
<p>在layoutSubviews方法内，可以实现如下功能：</p>
<ol>
<li>适配任何内存子视图的位置和大小。</li>
<li>添加或者移出子视图或者图层。</li>
<li>调用setNeedsDisplay或者setNeedsDisplayInRect:方法强制子视图进行重绘。</li>
</ol>
<h4 id="运行时修改视图"><a href="#运行时修改视图" class="headerlink" title="运行时修改视图"></a>运行时修改视图</h4><p>当应用程序接收到输入事件，应用需要适配界面来响应相应的输入。此时，应用会修改视图或者重排子视图，改变大小或者位置等。在iOS应用内，有多个地方和方法执行相应动作：</p>
<ol>
<li>在VC内：（a）一个VC在显示视图内容前必须创建它们，不管是能纯代码还是通过nib加载。最后在不使用它们时销毁。（b）当设备方向发生改变时，VC需要适配视图的大小和位置。或者会增加、移出部分视图。（c）当VC管理可编辑的内容时，VC会改变或者移动视图的层级关系。</li>
<li>在动画块内：（a）当过渡多组不同的视图展现用户界面时，需要在动画块内显示或者隐藏部分视图。（b）当需要实现特殊的效果里，则需要在动画块内改变视图指定的属性。</li>
<li>其它方式：（a）当发生touch事件或者手势时，界面需要响应视图加载或者改变等。（b）当用户与scroll view交互时，一个大的滑动区域需要动态显示和隐藏子视图。（c）当键盘出现或者隐藏时，需要重新设计视图的位置。</li>
</ol>
<h4 id="图层对象相互关联"><a href="#图层对象相互关联" class="headerlink" title="图层对象相互关联"></a>图层对象相互关联</h4><p>每个视图对象都有一个专用的图层管理内容的呈现和视图内容在屏幕上的动画。应用可以与视图对象交互，也可以直接与图层对象进行交互。视图可以嵌入其它的layer对象。</p>
<p>通过实现类方法layerClass指定view关联的layer对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    return [CATiledLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义视图注意点"><a href="#自定义视图注意点" class="headerlink" title="自定义视图注意点"></a>自定义视图注意点</h4><p>当系统框架提供的视图组件不能满足业务需求时，应用可以自定义控件，以下是自定义控件要注意的地方：</p>
<ol>
<li>需要为视图指定适当的初始化方法：（a）如果采用纯代码的方式实现自定义，则需要实现initWithFrame:方法或者自定义一个初始化方法。（b）如果采用nib的方式实现，则需要实现initWithCoder:方法，并使用该方法设置视图到初始化的状态。</li>
<li>根据情况实现dealloc方法清理数据。</li>
<li>对于采用代码绘制图像内容，则需要复写drawRect:方法并在此方法内实现内容的绘制。</li>
<li>设置自定义视图的autoresizingMask属性定义autoresizing行为。</li>
<li>如果视图类管理多个子视图：（a）在视图初始化的节点上创建子视图。（b）在子视图创建时设置对应的autoresizingMask属性。（c）如果视图需要对子视图采用定制的布局，则需要复写layoutSubviews方法并实现定制的布局代码。</li>
<li>处理touch事件相关的事件：（a）使用addGestureRecognizer:方法添加适当的手势识别器到view上。（b）当手势不能满足需要时，可以复写 touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent:, 和 touchesCancelled:withEvent: 方法对事件进行定制处理。</li>
<li>如果想为视图实现打印且打印板式与屏幕上不同，需要实现drawRect:forViewPrintFormatter:方法。具体情况需要参照Drawing and Printing PG。</li>
</ol>
<p>对于视图事件响应处理，要参考Event Handling PG。</p>
<p>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/View-PG/" data-id="cin6wvsbi0011khzlknjva297" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Concurrency-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/Concurrency-PG/" class="article-date">
  <time datetime="2016-04-12T03:58:31.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/Concurrency-PG/">Concurrency-PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>并发</strong>概念：是指多种事件任务在同一时间执行。</p>
<p>直接线程交互：应用程序必须依据操作系统的情况动态的创建和适配线程工作情况。除此之外，应用程序需要花费大量精力负责创建和维护使用的线程。</p>
<p>针对多线程管理，Apple提出采取一个异步的方式解决并发问题。异步功能函数在另外一个线程执行耗时的任务，当任务完成后，发送一个通知（调用回调函数）至原工作线程。</p>
<p>为简化异步功能的实现和使用，Apple实现了几种解决方案：Dispatch Queues、Dispatch Sources、Operation Queues。</p>
<h6 id="并发注意事项"><a href="#并发注意事项" class="headerlink" title="并发注意事项"></a>并发注意事项</h6><ol>
<li>考虑是否必须采用并发实现。</li>
<li>并发可以提升性能，但是会增加程序复杂度，同时也会增加程序调试难度。</li>
<li>并发不应该作为一个功能特征看待，不能为了并发而加入并发。</li>
<li>清楚定义程序需要完成的功能任务。分离出需要执行的任务单元。标示需要的执行队列，正确将任务单元放入队列中执行。</li>
<li>并发技术只是提供更方便的执行并发任务的操作，不能保证性能的提升，所以在编程时要注意考虑性能问题。</li>
</ol>
<p>性能考虑：</p>
<ol>
<li>如果内存是影响性能的关键，则考虑直接执行任务。</li>
<li>标示线性执行任务，调整任务结构，尽量采用并发执行。</li>
<li>避免使用lock操作。</li>
<li>尽量使用框架提供的高层API。</li>
</ol>
<h2 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>operations是一种面向对象的方式实现异步执行任务功能。operations结合operation queue使用或者单独使用。</p>
<p>operation对象是NSOperation类型的一个实例对象，用于封装在应用内需要执行的任务。以下列出关于官方定义的几个Operation类：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_T2_1.jpg" alt="Concurrency_T2_1"></p>
<p>全部operation对象都支持如下：</p>
<ol>
<li>可以建立operation对象间的依赖关系。</li>
<li>支持设定completion block回调通知。</li>
<li>支持运用KVO技术监控对象的执行状态。</li>
<li>支持通过设定优先级，影响operation对象的执行顺序。</li>
<li>支持取消任务。</li>
</ol>
<p>关于Operation相关类Apple开源代码：<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSOperation.swift" target="_blank" rel="external">https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSOperation.swift</a></p>
<h6 id="对比并发与非并发"><a href="#对比并发与非并发" class="headerlink" title="对比并发与非并发"></a>对比并发与非并发</h6><p>operation对象通常的使用方式是将其加入到operation queue中。但也可以直接调用operation的start方法执行，此时operation的运行并不不一定会保证是并发执行。可以通过NSOperration的isConcurrent方法查询当前是同步或者异步执行状态。</p>
<p>如果想要通过直接调用start方式运行在异步方式上，则必须增加附加的代码控制，实现在另外一个线程调用start方法。</p>
<p><strong>通常情况下，我们都应该直接使用Operation Queue进行操作</strong></p>
<h5 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h5><p>NSInvocationOperation是通过调用对象的selector实现，Swift不支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyCustomClass</span><br><span class="line">- (NSOperation*)taskWithData:(id)data &#123;</span><br><span class="line">    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self</span><br><span class="line">                    selector:@selector(myTaskMethod:) object:data];</span><br><span class="line"> </span><br><span class="line">   return theOp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// This is the method that does the actual work of the task.</span><br><span class="line">- (void)myTaskMethod:(id)data &#123;</span><br><span class="line">    // Perform the task.</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let operation = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;Begin operation.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Custom-Operation-Object"><a href="#Custom-Operation-Object" class="headerlink" title="Custom Operation Object"></a>Custom Operation Object</h5><p>定义一个非并发操作，只需要实现main任务，及响应取消操作，其它部分NSOpertion已经实现。</p>
<p>定义一个并发操作，则必须重写NSOperation内已经实现的部分。</p>
<h6 id="Main-Task"><a href="#Main-Task" class="headerlink" title="Main Task"></a>Main Task</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyNoConcurrentOperation: NSOperation &#123;</span><br><span class="line">    </span><br><span class="line">    var data : AnyObject</span><br><span class="line">    </span><br><span class="line">    init(d  : AnyObject) &#123;</span><br><span class="line">        data = d</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        print(&quot;Do something.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Respond-Cancel"><a href="#Respond-Cancel" class="headerlink" title="Respond Cancel"></a>Respond Cancel</h6><p>当一个任务开始执行，则任务会一直执行，直至完成或者明确取消操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override func main() &#123;</span><br><span class="line">       print(&quot;Do something.&quot;)</span><br><span class="line">       var isDone = false</span><br><span class="line">       </span><br><span class="line">       while !cancelled &amp;&amp; !isDone &#123;</span><br><span class="line">           // Do some work and set isDone to YES when finished</span><br><span class="line">           isDone = true</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="configuring-operation-concurrent"><a href="#configuring-operation-concurrent" class="headerlink" title="configuring operation concurrent"></a>configuring operation concurrent</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class MyOperation: NSOperation &#123;</span><br><span class="line">    </span><br><span class="line">    override var concurrent : Bool &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var finish : Bool = false</span><br><span class="line">    override var finished : Bool &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return finish</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var execute : Bool = false</span><br><span class="line">    override var executing : Bool &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return execute</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        execute = false</span><br><span class="line">        finish = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func start() &#123;</span><br><span class="line">        guard !cancelled else &#123;</span><br><span class="line">            self.willChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">            finish = true</span><br><span class="line">            self.didChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.willChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">        NSThread.detachNewThreadSelector(&quot;main&quot;, toTarget: self, withObject: nil)</span><br><span class="line">        execute = true</span><br><span class="line">        self.didChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        // Do main task of operation.</span><br><span class="line">        print(NSThread.currentThread())  // &quot;&lt;NSThread: 0x7fd8bb423dd0&gt;&#123;number = 3, name = (null)&#125;\n&quot;</span><br><span class="line">        completeOperation()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func completeOperation() &#123;</span><br><span class="line">        self.willChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">        self.willChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">        </span><br><span class="line">        execute = false</span><br><span class="line">        finish = true</span><br><span class="line">        </span><br><span class="line">        self.didChangeValueForKey(&quot;executing&quot;)</span><br><span class="line">        self.didChangeValueForKey(&quot;finished&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o = MyOperation()</span><br><span class="line">NSThread.currentThread()   // &lt;NSThread: 0x7fd8bb506f30&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">o.start()</span><br></pre></td></tr></table></figure>
<h4 id="Execution-Behavior-of-Operation"><a href="#Execution-Behavior-of-Operation" class="headerlink" title="Execution Behavior of Operation"></a>Execution Behavior of Operation</h4><ol>
<li>用 addDependency(op: NSOperation) 、 removeDependency(op: NSOperation) 控制依赖关系。</li>
<li>用 queuePriority: NSOperationQueuePriority 设置执行优先级。</li>
<li>用 threadPriority: Double 改变底层线程优先级，value在0 到 1之间。</li>
<li>用 completionBlock: (() -&gt; Void)? 设置完成时回调。</li>
</ol>
<h2 id="Executing-Operations"><a href="#Executing-Operations" class="headerlink" title="Executing Operations"></a>Executing Operations</h2><h4 id="Operation-Queue"><a href="#Operation-Queue" class="headerlink" title="Operation Queue"></a>Operation Queue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let aQueue = NSOperationQueue()</span><br><span class="line">aQueue.addOperation(anOp)</span><br><span class="line"></span><br><span class="line">aQueue.addOperations([anOOp], waitUntilFinished: false)</span><br></pre></td></tr></table></figure>
<p>public func addOperations(ops: [NSOperation], waitUntilFinished wait: Bool) 开源实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    public func addOperations(_ ops: [NSOperation], waitUntilFinished wait: Bool) &#123;</span><br><span class="line">#if DEPLOYMENT_ENABLE_LIBDISPATCH</span><br><span class="line">        var waitGroup: dispatch_group_t?</span><br><span class="line">        if wait &#123;</span><br><span class="line">            waitGroup = dispatch_group_create()</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        /*</span><br><span class="line">         If OperationQueuePriority was not supported this could be much faster</span><br><span class="line">         since it would not need to have the extra book-keeping for managing a priority</span><br><span class="line">         queue. However this implementation attempts to be similar to the specification.</span><br><span class="line">         As a concequence this means that the dequeue may NOT nessicarly be the same as</span><br><span class="line">         the enqueued operation in this callout. So once the dispatch_block is created</span><br><span class="line">         the operation must NOT be touched; since it has nothing to do with the actual</span><br><span class="line">         execution. The only differential is that the block enqueued to dispatch_async</span><br><span class="line">         is balanced with the number of Operations enqueued to the NSOperationQueue.</span><br><span class="line">         */</span><br><span class="line">        ops.forEach &#123; (operation: NSOperation) -&gt; Void in</span><br><span class="line">            lock.lock()</span><br><span class="line">            operation._queue = self</span><br><span class="line">            _operations.insert(operation)</span><br><span class="line">            lock.unlock()</span><br><span class="line">#if DEPLOYMENT_ENABLE_LIBDISPATCH</span><br><span class="line">            if let group = waitGroup &#123;</span><br><span class="line">                dispatch_group_enter(group)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            let block = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS) &#123; () -&gt; Void in</span><br><span class="line">                if let sema = self._concurrencyGate &#123;</span><br><span class="line">                    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)</span><br><span class="line">                    self._runOperation()</span><br><span class="line">                    dispatch_semaphore_signal(sema)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    self._runOperation()</span><br><span class="line">                &#125;</span><br><span class="line">                if let group = waitGroup &#123;</span><br><span class="line">                    dispatch_group_leave(group)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_group_async(queueGroup, _underlyingQueue, block)</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">#if DEPLOYMENT_ENABLE_LIBDISPATCH</span><br><span class="line">        if let group = waitGroup &#123;</span><br><span class="line">            dispatch_group_wait(group, DISPATCH_TIME_FOREVER)</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Manually"><a href="#Manually" class="headerlink" title="Manually"></a>Manually</h4><p>手动执行需要判定是否就绪、已经取消等条件。</p>
<h4 id="Cancel-Operation"><a href="#Cancel-Operation" class="headerlink" title="Cancel Operation"></a>Cancel Operation</h4><p>直接调用 cancel 方法，对于Queue中 调用 func cancelAllOperations()。</p>
<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>GCD分发队列是非常强大的工具允许构造任意的Block任务同步 或者 异步执行。</p>
<p>系统内定义的队列类型：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_T3_1.jpg" alt="Dispatch_Queues_Type"></p>
<p><strong>注意点：</strong></p>
<ol>
<li>队列执行任务的并发情况依赖当前系统其它队列的执行情况。线性队列全部任务都限制在同一队列内执行。</li>
<li>同一时间队列内执行任务的数量由系统决定。</li>
<li>系统根据任务优先级动态调整执行顺序。</li>
<li>一个任务被加入队列之前必须是准备就绪的。</li>
<li>私有的新建队列是引用记数的对象，需要考虑对象引用问题。</li>
</ol>
<h4 id="队列相关"><a href="#队列相关" class="headerlink" title="队列相关"></a>队列相关</h4><p><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_T3_2.jpg" alt="Queue_Related Tech"></p>
<h4 id="实现任务闭包"><a href="#实现任务闭包" class="headerlink" title="实现任务闭包"></a>实现任务闭包</h4><p>这个不用多提了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let task = &#123;</span><br><span class="line">    print(&quot;Current task.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建和管理队列"><a href="#创建和管理队列" class="headerlink" title="创建和管理队列"></a>创建和管理队列</h4><h6 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h6><p>let global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</p>
<h6 id="线性队列"><a href="#线性队列" class="headerlink" title="线性队列"></a>线性队列</h6><p>let serial = dispatch_queue_create(“com.example.MyQueue”, DISPATCH_QUEUE_SERIAL)</p>
<h6 id="获取全局队列"><a href="#获取全局队列" class="headerlink" title="获取全局队列"></a>获取全局队列</h6><p>用 dispatch_get_current_queue 、 dispatch_get_main_queue 、dispatch_get_global_queue。</p>
<h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><h6 id="简单任务"><a href="#简单任务" class="headerlink" title="简单任务"></a>简单任务</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let serial = dispatch_queue_create(&quot;com.example.MyQueue&quot;, DISPATCH_QUEUE_SERIAL)</span><br><span class="line">dispatch_async(serial) &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;current task finish.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Loop-Iterations"><a href="#Loop-Iterations" class="headerlink" title="Loop Iterations"></a>Loop Iterations</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let serial = dispatch_queue_create(&quot;com.example.MyQueue&quot;, DISPATCH_QUEUE_SERIAL)</span><br><span class="line"></span><br><span class="line">dispatch_apply(100, serial) &#123; (i) -&gt; Void in</span><br><span class="line">    print(&quot;current index: \(i)&quot;)    // 执行100次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="分发信号量"><a href="#分发信号量" class="headerlink" title="分发信号量"></a>分发信号量</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sema = dispatch_semaphore_create(100)</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)  //等待之前正在占用资源的任务</span><br><span class="line"></span><br><span class="line">//执行资源冲突的任务</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(sema)</span><br></pre></td></tr></table></figure>
<h6 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line"></span><br><span class="line">let group = dispatch_group_create()</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, global) &#123; () -&gt; Void in</span><br><span class="line">    // some asy task ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// current thread task ..</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER)</span><br><span class="line"></span><br><span class="line">//asy task 和 syn task 完成后执行。</span><br></pre></td></tr></table></figure>
<p>关于同步或者异步，及是否开启线程情况如下：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/concurrency_1_1.png" alt="Dispatch_Queue_Thread_OO"></p>
<p>参考此链接：<a href="http://www.cnblogs.com/wendingding/p/3806821.html" target="_blank" rel="external">http://www.cnblogs.com/wendingding/p/3806821.html</a></p>
<h2 id="Dispatch-Sources"><a href="#Dispatch-Sources" class="headerlink" title="Dispatch Sources"></a>Dispatch Sources</h2><p>Dispatch Sources提供了一种向内核提交请求，异步响应内核事件的机制。是一个基本的数据类型，协调进程关于底层的事件。</p>
<p>支持的事件源类型如下：</p>
<ol>
<li>时钟产生周期性的通知。</li>
<li>信号源通知应用系统产生信号。</li>
<li>文件描述符或者基于socket操作的通知：（1）数据准备好可读。（2）文件可写数据。（3）当文件被系统删除、移动、重命名。（4）当文件的原信息修改。</li>
<li>和进程相关的通知事件：（1）进程退出。（2）通过命令fork或者exec产生进程。（3）当一个信号在线程内分发。</li>
<li>基于Mach相关的事件分发。</li>
<li>自定义的事件分发源。</li>
</ol>
<p>记录一下关于信号量和进行的监控，其它的参考文档实现：</p>
<h6 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h6><p>func installSignalHandler() {<br>    // Make sure the signal does not terminate the application.<br>    signal(SIGHUP, SIG_IGN)</p>
<pre><code>let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
let source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, UInt(SIGHUP), 0, queue)

if source != nil {
    dispatch_source_set_event_handler(source, { () -&gt; Void in
        // 处理信号发生
    })

    // Start processing signals
    dispatch_resume(source)
}
</code></pre><p>}</p>
<h6 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func monitorParentProcess() &#123;</span><br><span class="line">    let parentPID = getpid()</span><br><span class="line">    </span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    let source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, UInt(parentPID), DISPATCH_PROC_EXIT, queue)</span><br><span class="line">    </span><br><span class="line">    if source != nil &#123;</span><br><span class="line">        dispatch_source_set_event_handler(source, &#123; () -&gt; Void in</span><br><span class="line">            //Handler exit ...</span><br><span class="line">            </span><br><span class="line">            dispatch_source_cancel(source)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><ol>
<li>队列减少多线程应用对系统存储的使用。</li>
<li>消除创建和管理线程的代码。</li>
<li>消除在线程上管理和计划执行的代码。</li>
<li>简化应用程序代码书写。</li>
</ol>
<p>参考官方文档：<a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/12/Concurrency-PG/" data-id="cin6wvsab0009khzlfsxby3x6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RunLoop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/11/RunLoop/" class="article-date">
  <time datetime="2016-04-11T04:18:27.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/RunLoop/">RunLoop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>线程是一种在同一应用内并行执行多任务轻量级的实现方式。在系统层面不同程序并行执行，系统依据不同程序的需要分配执行时间。在不同的应用程序内，存在一个或者多个线程，同时执行任务或者趋于同时执行。系统对实际的线程进行控制，安排线程在可用的内核上执行，依据优先级切换不同的线程执行任务。</p>
<p>从技术层面讲，线程是内核层面和应用层面的数据结构组合用于管理执行代码。在内核结构上协调事件分发、依据优先级安排线程执行在可用的内核上。在应用层面上该数据结构包括调用堆栈存储函数并且应用需要管理和操控线程的属性和状态。</p>
<ol>
<li>对于非并发的应用内，则只有一个线程执行任务。线程必须响应程序内的任何事件。</li>
<li>对于并发的应用，则有多条path同时执行任务。每个path都有自定义的入口，并独立于主线程的任务。多线程优势：可以提升程序的响应。可以提升程序的实时性能在多核系统上。</li>
</ol>
<p><strong>Run Loops是线程的基本构成的一部分。Run Loop是一个处理事件的循环，用于我们安排任务或者协调进入的Event。run loop的作用是当有任务需要处理时保持线程忙碌，在没有任务需要执行时让线程进入休眠。</strong></p>
<ol>
<li>run loop不完成完全自动进行管理，应用必须设计程序代码在响应接入的event，并在适当的时候启动。</li>
<li>应用不需要明确创建run loop对象，每个线程都有一个关联的run loop对象。</li>
<li>app框架自动设置并开启线程的run loop对象，只有新启的其它线程需要明确的开启run loop。</li>
</ol>
<h2 id="解析Run-Loop"><a href="#解析Run-Loop" class="headerlink" title="解析Run Loop"></a>解析Run Loop</h2><p>run loop接收两种不同来源类型的事件。<strong>Input Sources</strong>分发异步事件。<strong>Timer Sources</strong>分发同步事件。</p>
<p>下图描述的Run loop的概念结构和各种不同的输入源：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/runloop_3_1.jpg" alt="RunLoop_3_1"></p>
<p>除了处理输入的事件源，run loop同时会生成关于自身的行为通知。注册通知可以接收到相应的通知并且可以用这些通知进行附加的处理。</p>
<h2 id="Run-Loop-Modes"><a href="#Run-Loop-Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h2><p>一个Run loop模式是输入源、时钟和注册的观察者的集合。</p>
<p>每当应用程序启动run loop，指定一个特定模式运行。在run loop运行期间，只有关联到相应模式上的事件会被监控和分发（相似的，只有关联到指定模式的观察者才会被通知）。关联到其它模式的输入源被挂起直到run loop运行适当的模式。</p>
<p>在程序内，用字符串标示指定的模式，框架内定义的default和几种能用模式：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/runloop_T3_1.jpg" alt="RunLoop_T3_1"></p>
<p>应用使用不同的模式筛选出在特定途径下不想执行的事件任务。在应用执行的大部分时间，都应该将程序使用default模式执行。</p>
<h2 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h2><p>输入源异步的分发事件到指定线程。源事件依赖于输入源类型，被分为能用的两种：一是基于端口的输入源监控应用程序的Mach ports，另一种是自定义输入源监控事件。系统实现对于常用的两种类型输入都适用，唯一不同的地方就是它们如何触发信号。基于端口的输入源自动触发信息通过系统内核，而自定义输入源需要代码控制实现在另一个纯种。</p>
<h6 id="基于端口的输入源"><a href="#基于端口的输入源" class="headerlink" title="基于端口的输入源"></a>基于端口的输入源</h6><p>Cocoa和CoreFoundation框架提供内置的支持创建基于端口的输入源。在Cocoa框架内使用NSPort进行端口输入源的创建。在CoreFoundation用CFMachPortRef等。</p>
<h6 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h6><p>如果要创建一个自定义的输入源，则必须使用CFRunLoopSourceRef相关联的功能函数。定义一个自定义的输入源需要使用不同的回调函数。CoreFoundation框架在不同的时间点调用不同的架设函数，处理任何的接入事件、或者sources完成后移出run loop。</p>
<p>除了定义当事件到达时输入源的行为定义，同时必须定义事件的分发机制。这部分内容运行在独立的线程上，负责响应提供输入源的数据并且当数据准备完成时要触发信号。关于事件分发机制部分取决于代码实现，但不应该过于复杂。</p>
<h6 id="Cocoa-Selector-Sources"><a href="#Cocoa-Selector-Sources" class="headerlink" title="Cocoa Selector Sources"></a>Cocoa Selector Sources</h6><p>除了基于端口的输入源，Cocoa定义了定制的输入源允许应用通过调用Selector方式实现。和端口输入源一样，selector源在目标线程上也是连续的执行，从而避免在同一个线程上多个方法同时的执行的同步问题。</p>
<p><strong>如果要在另一个线程调用Selector，该线程必须有一个活动的active</strong>，且run loop处理全部入队的selector调用在插入run loop时，而不是在loop迭代循环的时候。</p>
<p>下表列出定义在NSObject上可以在另一个线程上执行selector的方法：<br><img src="http://7xsq10.com2.z0.glb.clouddn.com/runloop_T3_2.jpg" alt="RunLoop_T3_2"></p>
<h2 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h2><p>时间输入源是预定义的在将来某个时间点同步分发事件到指定线程上。时钟源是一种通知线程执行任务的方式。</p>
<h6 id="Configuring-Timer-Sources"><a href="#Configuring-Timer-Sources" class="headerlink" title="Configuring Timer Sources"></a>Configuring Timer Sources</h6><p>创建一个时钟输入源，程序需要创建一个时间对象，并且将时钟对象安排到run loop上执行。</p>
<p>在Cocoa框架里，定义了两个方法来创建并安排时钟到run loop，这两个方法创建并添加timer至run loop的default模式：</p>
<ol>
<li>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</li>
<li>scheduledTimerWithTimeInterval:invocation:repeats:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">// Create and schedule the first timer.</span><br><span class="line">NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];</span><br><span class="line">NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate</span><br><span class="line">                        interval:0.1</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer1:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">// Create and schedule the second timer.</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:0.2</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer2:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context = &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,</span><br><span class="line">                                        &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"> </span><br><span class="line">CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<h2 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h2><p>可以关联以下事件至Run Loop：</p>
<ol>
<li>进入run loop时。</li>
<li>当一个run loop处理一个timer。</li>
<li>当一个run loop处理一个输入源。</li>
<li>当一个run loop进入睡眠状态。</li>
<li>当一个输入源准备要唤醒run loop。</li>
<li>退出run loop。</li>
</ol>
<p>创建和使用Run Loop Objservers 需要使用 CFRunLoopObserverRef  相关功能函数。</p>
<h2 id="Run-Loop-事件顺序"><a href="#Run-Loop-事件顺序" class="headerlink" title="Run Loop 事件顺序"></a>Run Loop 事件顺序</h2><p>run loop事件指定顺序如下：</p>
<ol>
<li>通知观察者已经进入run loop。</li>
<li>通知观察者处于准备状态的timer将要执行。</li>
<li>通知观察者任何非基于端口的输入源将要执行。</li>
<li>非基于端口的输入源准备执行。</li>
<li>如果基于端口的输入源已经准备就绪且等待执行，则立即处理事件。跳转至步骤9</li>
<li>通知观察者线程将要进入休眠。</li>
<li>将线程变成休眠状态，直到如下事件发生：（1）一个基于端口的事件到达。（2）timer触发。（3）runloop到达设置的超时时间。（4）runloop被明确的唤醒。</li>
<li>通知观察者线程刚刚被唤醒。</li>
<li>处理等待状态的事件。（1）如果用户定义的timer触发，处理timer事件，并重新启动runloop。进入步骤2。（2）如果input源触发，则分发事件。（3）如果runloop被明确唤醒但是没有超时，则重新启动runloop。进入步骤2</li>
<li>通知观察者run loop退出。</li>
</ol>
<h2 id="什么时候用RunLoop"><a href="#什么时候用RunLoop" class="headerlink" title="什么时候用RunLoop"></a>什么时候用RunLoop</h2><p>仅仅只有在应用内创建第二个线程，有可能需要启动runloop。</p>
<p>需要启动runloop，当计划做如下任务：</p>
<ol>
<li>使用基于端口或者自定义的输入源和其它的线程进行通信。</li>
<li>在线程中使用timer。</li>
<li>需要使用selector输入源。</li>
<li>想要线程执行周期性的任务。</li>
</ol>
<h2 id="使用RunLoop"><a href="#使用RunLoop" class="headerlink" title="使用RunLoop"></a>使用RunLoop</h2><p>Cocoa框架提供NSRunLoop类。在应用更底层，是一个指针指向CFRunLoopRef类型。</p>
<h6 id="获取runloop对象"><a href="#获取runloop对象" class="headerlink" title="获取runloop对象"></a>获取runloop对象</h6><p>在当前线程获取runloop：Cocoa框架用NSRunLoop 的 currentRunLoop 类方法。CoreFoundation框架用CFRunLoopGetCurrent方法。</p>
<h6 id="启动runloop"><a href="#启动runloop" class="headerlink" title="启动runloop"></a>启动runloop</h6><p>runloop必须有一个输入源或者时钟依附其上，不然就会立即退出。</p>
<p>有以下几种方式启动runloop：</p>
<ol>
<li>无条件的启动：是最简单的方式启动，可以添加或者删除输入源和时钟源。但是只有通过杀掉才能停止runloop。并且没有办法进入自定义的模式。</li>
<li>采用超时限制：只有当被分配的时间过期或者一个事件到达，runloop会退出。当一个事件到达，事件被分发处理，然后runloop退出；但可以再添加另一个事件。这个过期时间可以重新设定。</li>
<li>采用指定模式运行。</li>
</ol>
<p>a skeleton version of a thread’s main entry routine:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)skeletonThreadMain</span><br><span class="line">&#123;</span><br><span class="line">    // Set up an autorelease pool here if not using garbage collection.</span><br><span class="line">    BOOL done = NO;</span><br><span class="line"> </span><br><span class="line">    // Add your sources or timers to the run loop and do any other setup.</span><br><span class="line"> </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        // Start the run loop but return after each source is handled.</span><br><span class="line">        SInt32    result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);</span><br><span class="line"> </span><br><span class="line">        // If a source explicitly stopped the run loop, or if there are no</span><br><span class="line">        // sources or timers, go ahead and exit.</span><br><span class="line">        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))</span><br><span class="line">            done = YES;</span><br><span class="line"> </span><br><span class="line">        // Check for any other exit conditions here and set the</span><br><span class="line">        // done variable as needed.</span><br><span class="line">    &#125;</span><br><span class="line">    while (!done);</span><br><span class="line"> </span><br><span class="line">    // Clean up code here. Be sure to release any allocated autorelease pools.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runloop可以递归的执行。即：可以在任何的RunLoop方法内启动runloop的执行入口。</p>
<h6 id="退出runloop"><a href="#退出runloop" class="headerlink" title="退出runloop"></a>退出runloop</h6><p>两个方法退出：1.使用timeout机制退出。2.明确执行退出操作。</p>
<p>关于配置自定义输入源，参考官方文档。</p>
<p>参考文档：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/11/RunLoop/" data-id="cin6wvsb9000ukhzlscbnumn1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-KVO-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/09/KVO-PG/" class="article-date">
  <time datetime="2016-04-09T08:38:06.000Z" itemprop="datePublished">2016-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/09/KVO-PG/">KVO_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVO是一种机制被用于当其它对象指定属性改变时 观察对象被及时通知。在MVC工作模式下，KVO对Model属性改变及时通知Controller是非常有利的。</p>
<p>KVO主要优势在于不用开发时去用其它机制进行实现，基础框架已经做了很好的支持。</p>
<p>关于KVO相关扩展方法定义在 ： import Foundation.NSKeyValueObserving</p>
<h2 id="Register-KVO"><a href="#Register-KVO" class="headerlink" title="Register KVO"></a>Register KVO</h2><p>要实现对特定属性采用KVO机制进行观察，必须满足以下三点：</p>
<ol>
<li>被观察的类的指定属性必须是遵守KVO规则的。</li>
<li>必须让观察对象用addObserver:forKeyPath:options:context:向被观察对象注册。</li>
<li>观察对象必须实现observeValueForKeyPath:ofObject:change:context:。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ObserveredClass : NSObject &#123;</span><br><span class="line">    dynamic var value : String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InstanceClass : NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    // Receiving Notification of a Change</span><br><span class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">        if keyPath == &quot;value&quot; &#123;</span><br><span class="line">            print(change?[NSKeyValueChangeNewKey])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observered = ObserveredClass()</span><br><span class="line">let instance = InstanceClass()</span><br><span class="line"></span><br><span class="line">// Registering as an Observer</span><br><span class="line">instance.addObserver(observered, forKeyPath: &quot;value&quot;, options: NSKeyValueObservingOptions.New, context: nil)</span><br><span class="line">observered.value = &quot;123&quot;</span><br><span class="line"></span><br><span class="line">// Removing an Object as an Observer</span><br><span class="line">instance.removeObserver(observered, forKeyPath: &quot;value&quot;, context: nil)</span><br></pre></td></tr></table></figure>
<h2 id="KVO-Compliance"><a href="#KVO-Compliance" class="headerlink" title="KVO Compliance"></a>KVO Compliance</h2><p>符合KVO规则，需要有以下三点：</p>
<ol>
<li>这个类的观察属性必须是满足 KVC 规则的，KVO支持的数据类型和KVC一致。</li>
<li>类必须能触发属性改变的通知。</li>
<li>依赖的key注册也能适合运用。</li>
</ol>
<p>有两种方法触发属性改变通知。</p>
<h4 id="Auto-Change"><a href="#Auto-Change" class="headerlink" title="Auto Change"></a>Auto Change</h4><p>自动触发：NSObject提供了默认的支持，当属性是符合KVC规则时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Call the accessor method.</span><br><span class="line">[account setName:@&quot;Savings&quot;];</span><br><span class="line"> </span><br><span class="line">// Use setValue:forKey:.</span><br><span class="line">[account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.</span><br><span class="line">[document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;];</span><br><span class="line"> </span><br><span class="line">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span><br><span class="line">Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;</span><br><span class="line">NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure>
<h4 id="Manual-Change"><a href="#Manual-Change" class="headerlink" title="Manual Change"></a>Manual Change</h4><p>手动触发： 提供了更小粒度控制，何时、如何触发通知。可以减少不必要的触发，或者集合一定数量通知同时触发。</p>
<p>Class实现手动触发必须继承NSObject并且实现 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</span><br><span class="line"> </span><br><span class="line">    BOOL automatic = NO;</span><br><span class="line">    if ([theKey isEqualToString:@&quot;openingBalance&quot;]) &#123;</span><br><span class="line">        automatic = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        automatic = [super automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    return automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现手动通知观察者，在改变值前调用 willChangeValueForKey：，并在改变值后调用 didChangeValueForKey：；可优化触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setOpeningBalance:(double)theBalance &#123;</span><br><span class="line">    if (theBalance != _openingBalance) &#123;</span><br><span class="line">        [self willChangeValueForKey:@&quot;openingBalance&quot;];</span><br><span class="line">        _openingBalance = theBalance;</span><br><span class="line">        [self didChangeValueForKey:@&quot;openingBalance&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于to-many relationship，不但要指定属性值改变，而且要通过 NSKeyValueChange 表示 改变的类型  NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, or NSKeyValueChangeReplacement。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line"> </span><br><span class="line">    // Remove the transaction objects at the specified indexes.</span><br><span class="line"> </span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Registering-Dependent-Keys"><a href="#Registering-Dependent-Keys" class="headerlink" title="Registering Dependent Keys"></a>Registering Dependent Keys</h2><h4 id="To-one"><a href="#To-one" class="headerlink" title="To-one"></a>To-one</h4><p>注册依赖keys，自动触发通知可以 重写 keyPathsForValuesAffectingValueForKey： 方法 或者  根据规则实现适当的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,firstName, lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="重写-keyPathsForValuesAffectingValueForKey：-方法："><a href="#重写-keyPathsForValuesAffectingValueForKey：-方法：" class="headerlink" title="重写 keyPathsForValuesAffectingValueForKey： 方法："></a>重写 keyPathsForValuesAffectingValueForKey： 方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line"> </span><br><span class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现-keyPathsForValuesAffecting-方法"><a href="#实现-keyPathsForValuesAffecting-方法" class="headerlink" title="实现 keyPathsForValuesAffecting 方法"></a>实现 keyPathsForValuesAffecting<key> 方法</key></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于在扩展里，由于不能override keyPathsForValuesAffectingValueForKey，所以只能通过实现 keyPathsForValuesAffecting<key> 的方式实现。</key></p>
<h4 id="To-many"><a href="#To-many" class="headerlink" title="To-many"></a>To-many</h4><p>The keyPathsForValuesAffectingValueForKey: method does not support key-paths that include a to-many relationship. For example, suppose you have a Department object with a to-many relationship (employees) to a Employee, and Employee has a salary attribute. You might want the Department object have a totalSalary attribute that is dependent upon the salaries of all the Employees in the relationship. You can not do this with, for example, keyPathsForValuesAffectingTotalSalary and returning employees.salary as a key.</p>
<p>采用过渡的技巧实现，观察：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let totalSalaryContext = UnsafeMutablePointer&lt;Void&gt;()</span><br><span class="line"></span><br><span class="line">class Employee: NSObject &#123;</span><br><span class="line">    dynamic var salary : NSNumber = 1.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Department: NSObject &#123;</span><br><span class="line">    let employees : NSArray = [Employee(), Employee()]</span><br><span class="line">    dynamic var totalSalay : CGFloat = 0.0</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        employees.forEach &#123; (object) -&gt; () in</span><br><span class="line">            object.addObserver(self, forKeyPath: &quot;salary&quot;, options: NSKeyValueObservingOptions.New, context: totalSalaryContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        employees.forEach &#123; (object) -&gt; () in</span><br><span class="line">            object.removeObserver(self, forKeyPath: &quot;salary&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">        if (context == totalSalaryContext) &#123;</span><br><span class="line">            updateTotalSalary()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func updateTotalSalary() &#123;</span><br><span class="line">        let new = self.valueForKeyPath(&quot;employees.@sum.salary&quot;) as? NSNumber ?? 0</span><br><span class="line">        totalSalay = CGFloat(new)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let department = Department()</span><br><span class="line">department.addObserver(self, forKeyPath: &quot;totalSalay&quot;, options: NSKeyValueObservingOptions.New, context: nil)</span><br><span class="line"></span><br><span class="line">override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</span><br><span class="line">    if keyPath == &quot;totalSalay&quot; &#123;</span><br><span class="line">        print(change?[NSKeyValueChangeNewKey])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(department.employees.lastObject as? Employee)?.salary = 20  //触发</span><br></pre></td></tr></table></figure>
<h2 id="Key-Value-Observing-Implementation-Details"><a href="#Key-Value-Observing-Implementation-Details" class="headerlink" title="Key-Value Observing Implementation Details"></a>Key-Value Observing Implementation Details</h2><p>自动KVO采用isa-swizzling的方法实现。</p>
<p>isa是一个指向操作分发表对象类的指针。对象类的分发表包含方法的实现和其它各种数据。</p>
<p>当一个观察对象向被观察对象注册一个属性时，被观察对象的isa指针改变，去指向一个中介的class而不再指向原来的class。所以这个isa指针不能再完全反应实例对象的实际class。</p>
<p>不能用改变后的isa指针去判定class关系。需要用类方法判定实例对象所属的类。</p>
<p>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/09/KVO-PG/" data-id="cin6wvsao000hkhzlujrjzpkq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-KVC-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/08/KVC-PG/" class="article-date">
  <time datetime="2016-04-08T10:31:50.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/08/KVC-PG/">KVC_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVC是NSKeyValueCoding协议定义的一种机制，用string标示对象属性，间接的使用对象的属性。本质上，KVC定义了相应的模式和方法进行校验从而满足应用采用valueForKey的方式接入。</p>
<p>访问器方法，提供接入应用数据模型的方式，有get访问器 和 set访问器。</p>
<p>在应用内实现KVC是一个很重要的原则，因为KVC是作为KVO、Core Data、Cocoa绑定、scriptability的重要基础。同时采用KVC也能简化应用编码。</p>
<p>key是一个字符串用于标示对象属性。key path是dot符号分隔的字符串序列，用于说明横穿对象属性路径。</p>
<p>在Foundation.NSKeyValueCoding库内，实现了对NSObject、Dictionary、Array等的扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    var value : String = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = KVCClass()</span><br><span class="line">let value = instance.valueForKey(&quot;value&quot;)  // value = &quot;123&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Accessor-Method"><a href="#Accessor-Method" class="headerlink" title="Accessor Method"></a>Accessor Method</h2><p>为了使KVC能使用像valueForKey:、setValue:forkey:等方法，则必须实现KVC的访问器方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    var temp : String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    func operate() -&gt; String &#123;</span><br><span class="line">        return temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setOperate(o : String) &#123;</span><br><span class="line">        temp = o</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tem = instance.valueForKey(&quot;operate&quot;)  // tem == &quot;&quot;</span><br><span class="line">instance.setValue(&quot;newValue&quot;, forKey: &quot;operate&quot;)  // </span><br><span class="line">tem = instance.valueForKey(&quot;operate&quot;)   // tem == &quot;newValue&quot;</span><br></pre></td></tr></table></figure>
<h5 id="常用访问器模式"><a href="#常用访问器模式" class="headerlink" title="常用访问器模式"></a>常用访问器模式</h5><p>-<key>、-is<key></key></key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)hidden &#123;</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isHidden &#123;</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set<key>:</key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setHidden: (BOOL)flag &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Collection访问器模式"><a href="#Collection访问器模式" class="headerlink" title="Collection访问器模式"></a>Collection访问器模式</h4><ol>
<li>mutableArrayValueForKey</li>
<li>mutableSetValueForKey</li>
</ol>
<h5 id="Getter-Indexed"><a href="#Getter-Indexed" class="headerlink" title="Getter Indexed"></a>Getter Indexed</h5><ol>
<li>-countOf<key></key></li>
<li>-objectIn<key>AtIndex:、-<key>AtIndexes: —- NSArray…objectAtIndex:.objectsAtIndexes:</key></key></li>
<li>-get<key>:range:</key></li>
</ol>
<h5 id="Mutable-Indexed"><a href="#Mutable-Indexed" class="headerlink" title="Mutable Indexed"></a>Mutable Indexed</h5><ol>
<li>-insertObject:in<key>AtIndex:、-insert<key>:atIndexes:</key></key></li>
<li>-removeObjectFrom<key>AtIndex:、-remove<key>AtIndexes:</key></key></li>
<li>-replaceObjectIn<key>AtIndex:withObject:、-replace<key>AtIndexes:with<key>:</key></key></key></li>
</ol>
<h4 id="无序的访问器模式"><a href="#无序的访问器模式" class="headerlink" title="无序的访问器模式"></a>无序的访问器模式</h4><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><ol>
<li>-countOf<key></key></li>
<li>-enumeratorOf<key></key></li>
<li>memberOf<key></key></li>
</ol>
<h5 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h5><ol>
<li>-add<key>Object:、-add<key>:</key></key></li>
<li>-remove<key>Object:、remove<key>:</key></key></li>
<li>-intersect<key>:</key></li>
</ol>
<h2 id="Key-Value-Validation"><a href="#Key-Value-Validation" class="headerlink" title="Key-Value Validation"></a>Key-Value Validation</h2><p>KVC提供了一个统一的API对属性的值进行确认。这套确认机制给予一个类接入属性值的机会、或者用其它的值替代，再或者抛出一个错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)validate&lt;Key&gt;:(id *)ioValue error: (NSError * __autoreleasing *)outError &#123;</span><br><span class="line">	return ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateOperate:(inout id  _Nullable __autoreleasing *)ioValue error:(out NSError * _Nullable __autoreleasing *)outError &#123;</span><br><span class="line">    </span><br><span class="line">    *ioValue = @&quot;validate&quot;;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    KVCClass * instance = [[KVCClass alloc] init];</span><br><span class="line">    NSString * o = [[NSString alloc] init];</span><br><span class="line">    [instance validateValue:&amp;o forKey:@&quot;operate&quot; error:nil];</span><br><span class="line">    NSLog(@&quot;%@&quot;, o);   // 打印出 validate</span><br></pre></td></tr></table></figure>
<p>或者<br>The default implementation of this method searches the class of the receiver for a validator method whose name matches the pattern -validate<key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, YES is returned.</key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class KVCClass : NSObject &#123;</span><br><span class="line">    override func validateValue(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String) throws &#123;</span><br><span class="line">        if inKey == &quot;operate&quot; &#123;</span><br><span class="line">            throw NSError(domain: &quot;KVC&quot;, code: 200, userInfo: nil)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try super.validateValue(ioValue, forKey: inKey)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var mu = UnsafeMutablePointer&lt;AnyObject?&gt;.alloc(1)</span><br><span class="line">var autoO = AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;(mu)</span><br><span class="line">do &#123;</span><br><span class="line">    try instance.validateValue(autoO, forKey: &quot;operate&quot;)</span><br><span class="line">    print(autoO.memory)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)             //  &quot;Error Domain=KVC Code=200 &quot;(null)&quot;\n&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if inKey == &quot;operate&quot; &#123;</span><br><span class="line">          ioValue.memory = &quot;validate&quot;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          try super.validateValue(ioValue, forKey: inKey)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      do &#123;</span><br><span class="line">  		try instance.validateValue(autoO, forKey: &quot;operate&quot;)</span><br><span class="line">  		print(autoO.memory)			//  &quot;validate\n&quot;</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  		print(error)      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出情况：</p>
<ol>
<li>object被确认，返回YES。</li>
<li>object不能被确认，并且没有一个可用的值可返回，则根据是否传Error设置错误，并返回NO。</li>
<li>一个新的值创建并返回，确认返回YES。</li>
</ol>
<h5 id="Automatic-Validation"><a href="#Automatic-Validation" class="headerlink" title="Automatic Validation"></a>Automatic Validation</h5><p>一般情况下KVC是不会自动招待validation，这是应用内应该做的校验责任。<br>但是像CoreData在执行保存的时候是自动validation的。</p>
<h2 id="Ensuring-KVC-Compliance"><a href="#Ensuring-KVC-Compliance" class="headerlink" title="Ensuring KVC Compliance"></a>Ensuring KVC Compliance</h2><p>为了让一个类的特定属性被认为是遵守KVC承诺的，则该类必须为了valueForKey:与setValue:forKey:能运行而实现对应的方法。</p>
<h4 id="To-One"><a href="#To-One" class="headerlink" title="To-One"></a>To-One</h4><ol>
<li>-<key>, -is<key> 或者 实例变量  <key>, _<key></key></key></key></key></li>
<li>可修改时要实现 -set<key>:</key></li>
<li>实现了-set<key>:则不能执行确认。</key></li>
<li>如果属性需要进行校验确认则需要实现 -validate<key>:error:。</key></li>
</ol>
<h4 id="Indexed-To-Many"><a href="#Indexed-To-Many" class="headerlink" title="Indexed To-Many"></a>Indexed To-Many</h4><ol>
<li>-<key> 或者 实例变量 <key>, _<key></key></key></key></li>
<li>-countOf<key>,  -objectIn<key>AtIndex:  或者  -<key>AtIndexes:</key></key></key></li>
<li>可选  -get<key>:range:</key></li>
</ol>
<p>对于可修改的：</p>
<ol>
<li>-insertObject:in<key>AtIndex: 或者  -insert<key>:atIndexes:</key></key></li>
<li>-removeObjectFrom<key>AtIndex 或者  -remove<key>AtIndexes:</key></key></li>
<li>-replaceObjectIn<key>AtIndex:withObject:  或者  -replace<key>AtIndexIndexes:with<key></key></key></key></li>
</ol>
<h4 id="Unordered-To-Many"><a href="#Unordered-To-Many" class="headerlink" title="Unordered To-Many"></a>Unordered To-Many</h4><ol>
<li>-<key> 或者 实例变量 <key> , _<key></key></key></key></li>
<li>-countOf<key>, -enumeratorOf<key> , -memberOf<key>:</key></key></key></li>
</ol>
<p>可修改：</p>
<ol>
<li>-add<key>Object: or -add<key>:</key></key></li>
<li>-remove<key>Object: or -remove<key>:</key></key></li>
<li>-interscet<key>: and -set<key>:</key></key></li>
</ol>
<h2 id="Scalar-and-Structure"><a href="#Scalar-and-Structure" class="headerlink" title="Scalar and Structure"></a>Scalar and Structure</h2><p>KVC提供对scalar值和数据结构的自动封包与解包成NSNumber 和 NSValue</p>
<h4 id="Handling-nil-Values"><a href="#Handling-nil-Values" class="headerlink" title="Handling nil Values"></a>Handling nil Values</h4><p>当nil被作为非对象值传入setValue:forKey:方法时，则receiver会调用setNilValueForKey:，而setNilValueForKey:默认实现是抛出一个NSInvalidArgumentException异常。可心在subclass里面重写指定的属性实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override func setNilValueForKey(key: String) &#123;</span><br><span class="line">    if key == &quot;age&quot; &#123;</span><br><span class="line">        self.setValue(0, forKey: key)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.setNilValueForKey(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collection-Operators"><a href="#Collection-Operators" class="headerlink" title="Collection Operators"></a>Collection Operators</h2><p>collection operators 允许在一个集合的元素上用keyPath标示符和action操作符表示执行操作。collection operators 表示作为参数传入valueForKeyPath的特定keyPath。 operator操作符 是一个@开头的特定字符串。</p>
<ol>
<li>在操作符左边的keyPath标示指向操作的集合。</li>
<li>在操作符右边的keyPath标示在集合对象内的属性路径。</li>
</ol>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/kvc_pg_figure1.jpg" alt="Operator key path format"></p>
<p>操作返回的对象值取决于操作符类型：</p>
<ol>
<li>简单的操作符返回 字符、数字、日期等。</li>
<li>对象操作符返回NSArray数组对象。</li>
<li>数组和Set操作符返回数组和set对象。</li>
</ol>
<p>source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class KVCObject : NSObject &#123;</span><br><span class="line">    var payee : String</span><br><span class="line">    var amount : Int</span><br><span class="line">    var date : NSDate</span><br><span class="line">    </span><br><span class="line">    init(p : String, a : Int, d : NSDate) &#123;</span><br><span class="line">        payee = p</span><br><span class="line">        amount = a</span><br><span class="line">        date = d</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let k0 = KVCObject(p: &quot;Green Power&quot;, a: 120, d: NSDate(timeIntervalSinceNow: 200))</span><br><span class="line">let k1 = KVCObject(p: &quot;Green Power&quot;, a: 150, d: NSDate(timeIntervalSinceNow: 300))</span><br><span class="line">let k2 = KVCObject(p: &quot;Green Power&quot;, a: 170, d: NSDate(timeIntervalSinceNow: 400))</span><br><span class="line"></span><br><span class="line">let k3 = KVCObject(p: &quot;Car Loan&quot;, a: 250, d: NSDate(timeIntervalSinceNow: 300))</span><br><span class="line">let k4 = KVCObject(p: &quot;Car Loan&quot;, a: 250, d: NSDate(timeIntervalSinceNow: 500))</span><br><span class="line"></span><br><span class="line">let transactions : NSArray = [k0, k1, k2, k3, k4]</span><br></pre></td></tr></table></figure>
<h4 id="Smiple"><a href="#Smiple" class="headerlink" title="Smiple"></a>Smiple</h4><p>######@avg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tranAvg = transactions.valueForKeyPath(&quot;@avg.amount&quot;)  // tranAvg : NSNumber  188</span><br></pre></td></tr></table></figure>
<p>#####@count<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tranCount = transactions.valueForKeyPath(&quot;@count&quot;)    // tranCount : NSNumber 5</span><br></pre></td></tr></table></figure></p>
<p>其它： @max @min  @sum  </p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h6 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a>@distinctUnionOfObjects</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let payees = transactions.valueForKeyPath(&quot;@distinctUnionOfObjects.payee&quot;)  // [&quot;Green Power&quot;, &quot;Car Loan&quot;]</span><br></pre></td></tr></table></figure>
<h6 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a>@unionOfObjects</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let payees = transactions.valueForKeyPath(&quot;@unionOfObjects.payee&quot;)  //[&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="Array-and-Set"><a href="#Array-and-Set" class="headerlink" title="Array and Set"></a>Array and Set</h4><p>@distinctUnionOfArrays  @unionOfArrays  @distinctUnionOfSets</p>
<h2 id="Accessor-Search"><a href="#Accessor-Search" class="headerlink" title="Accessor Search"></a>Accessor Search</h2><p>KVC是尝试用访问器get和set值。但是如何判定值是如何接入？</p>
<h5 id="Accessor-Search-Patterns-for-Simple-Attributes"><a href="#Accessor-Search-Patterns-for-Simple-Attributes" class="headerlink" title="Accessor Search Patterns for Simple Attributes"></a>Accessor Search Patterns for Simple Attributes</h5><p>####### setValue:forKey:</p>
<ol>
<li>搜索 set<key>:</key></li>
<li>如果没有访问器方法找到，并且类方法accessInstanceVariablesDirectly返回YES，则搜索实例变量类似_<key>,_is<key>,<key>,is<key></key></key></key></key></li>
<li>如果匹配上相应方法，则使用获得的值。如果有封解包操作的必要，则执行。</li>
<li>如果以上操作都失败，则调用setValue:forUndefinedKey:。</li>
</ol>
<h6 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey:"></a>valueForKey:</h6><ol>
<li>搜索get<key>,<key>,is<key>方法，如果找到则调用。如果有封解包操作的必要，则执行。</key></key></key></li>
<li>如果没有找到就搜索Array相关方法，countOf<key>,objectIn<key>AtIndex:等，详细方法看官方文档说明。</key></key></li>
<li>如果依然没有找到，则搜索Set的相关方法，enumeratorOf<key>,memberOf<key>等。</key></key></li>
<li><strong>如果以上操作都失败，并且类方法accessInstanceVariablesDirectly返回YES</strong>，则搜索实例变量类似_<key>,_is<key>,<key>,is<key>等，如果有封解包操作的必要，则执行。</key></key></key></key></li>
<li><strong>以上都失败，最后调用 valueForUndefinedKey:</strong>。</li>
</ol>
<p>对于 Accessor Search Pattern for Ordered Collections，Accessor Search Pattern for Uniquing Ordered Collections，Accessor Search Pattern for Unordered Collections<br>的搜索顺序，看官方文档，基本也Simple相似。</p>
<p>参考官方文档： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/08/KVC-PG/" data-id="cin6wvsaj000ckhzldtzi4nlk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-EventHandler-PG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/EventHandler-PG/" class="article-date">
  <time datetime="2016-04-07T06:55:15.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/EventHandler-PG/">EventHandler_PG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对事件的响应是应用的灵魂所在。</p>
<p><strong>一个事件沿着特定的路径分发到可以响应处理它的对象上</strong>，首先，UIApplication对象从事件队列顶取出一个事件分发准备处理。分发到key window对象上，window将事件赋予一个初始化对象处理。实始化对象取决于事件的类型。</p>
<ol>
<li>点击事件：对于点击事件，window先向一个发生点击事件的view分发，此view称为hit-test view。寻找view的过程称为：hit-testing。</li>
<li>Motion 和 远程 事件：window将事件发送到first responder处理。</li>
</ol>
<p>UIKit first sends the event to the object that is best suited to handle the event. For touch events, that object is the hit-test view, and for other events, that object is the first responder.</p>
<h2 id="hit-testing"><a href="#hit-testing" class="headerlink" title="hit-testing"></a>hit-testing</h2><p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_1.jpg" alt="Figure2_1"></p>
<p>如图，假设用户点击2-1上的E视图。iOS查找hit-test view检查顺序：</p>
<ol>
<li>touch事件在视图A内发生，所以检查视图B、C。</li>
<li>touch事件没有在视图B内，在而视图C内，所以检查视图D、E。</li>
<li>touch事件没有在视图D内，但在视图E内。</li>
<li>在视力层次结构里，视图E是最底层的，所以视图变成hist-test view。</li>
</ol>
<p>hitTest:withEvent:方法返回hit-test view通过 CGPoint point 和 UIEvent。hitTest:withEvent:方法首先调用自己的pointInside:withEvent:方法。如果传入hitTest:withEvent:方法的point在视图之内，则pointInside:withEvent:返回YES。然后hitTest方法在子视图上递归调用hitTest方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CustomHitTestView: UIView &#123;</span><br><span class="line">    </span><br><span class="line">    override func hitTest(point: CGPoint, withEvent event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line">        return self</span><br><span class="line">//        return super.hitTest(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func pointInside(point: CGPoint, withEvent event: UIEvent?) -&gt; Bool &#123;</span><br><span class="line">        return super.pointInside(point, withEvent: event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Regulating-the-Delivery-of-Touches-to-Views"><a href="#Regulating-the-Delivery-of-Touches-to-Views" class="headerlink" title="Regulating the Delivery of Touches to Views"></a>Regulating the Delivery of Touches to Views</h2><p>window首先将touch事件发送到任何依附于hit-test view（或者其父视图吗？）的Gesture。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/1_5.jpg" alt="Figure1_5"></p>
<p><strong>Gesture Recognizers Get the First Opportunity to Recognize a Touch</strong></p>
<p>window延迟向view分发事件，让手势识别器有机会先分析touch。在延迟期间，如果手势识别器识别到touch手势，则window不会分发touch事件到view，并且会取消之前已经分发到view上和这个识别序列有关的touch object。</p>
<h2 id="Creating-a-Custom-Gesture-Recognizer"><a href="#Creating-a-Custom-Gesture-Recognizer" class="headerlink" title="Creating a Custom Gesture Recognizer"></a>Creating a Custom Gesture Recognizer</h2><p>在自定义手势，则需要实现 UIGestureRecognizerSubclass 下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public func reset()</span><br><span class="line">public func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br><span class="line">public func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent)</span><br></pre></td></tr></table></figure>
<p>Guide内的例子如下，不过官网上的代码有点Bug：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import UIKit.UIGestureRecognizerSubclass</span><br><span class="line"></span><br><span class="line">class CustomGestureRecognizer: UIGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    private var midPoint = CGPointZero</span><br><span class="line">    var strokeUp = false</span><br><span class="line">    </span><br><span class="line">    override func reset() &#123;</span><br><span class="line">        super.reset()</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesBegan(touches, withEvent:event)</span><br><span class="line">        </span><br><span class="line">        if touches.count != 1 &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesMoved(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state != .Failed else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let win = self.view?.window</span><br><span class="line">        let nowPoint = touches.first?.locationInView(win)</span><br><span class="line">        let prevPoint = touches.first?.previousLocationInView(win)</span><br><span class="line">        </span><br><span class="line">        guard let now = nowPoint, let prev = prevPoint where !strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if now.x &gt;= prev.x &amp;&amp; now.y &gt;= prev.y &#123;</span><br><span class="line">            midPoint = now</span><br><span class="line">        &#125; else if now.x &gt;= midPoint.x &amp;&amp; now.y &lt;= midPoint.y &#123;</span><br><span class="line">            strokeUp = true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .Failed</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesEnded(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        guard state == .Possible &amp;&amp; strokeUp else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        state = UIGestureRecognizerState.Recognized</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesCancelled(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent) &#123;</span><br><span class="line">        super.touchesCancelled(touches, withEvent: event)</span><br><span class="line">        </span><br><span class="line">        midPoint = CGPointZero</span><br><span class="line">        strokeUp = false</span><br><span class="line">        state = .Failed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以参考这个例子 ： <a href="https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers" target="_blank" rel="external">https://www.raywenderlich.com/104744/uigesturerecognizer-tutorial-creating-custom-recognizers</a></p>
<p><strong>在完成hit-testing 且没有手势识别后，view作为responser开始响应</strong></p>
<h2 id="Responder-Object"><a href="#Responder-Object" class="headerlink" title="Responder Object"></a>Responder Object</h2><p>Responder Object是一个能够响应和处理事件的对象，UIResponder是所以Responder Object的基类。<br>一个对象成为First Responder需要做以下两个任务：</p>
<ol>
<li>Overriding the canBecomeFirstResponder method to return YES.</li>
<li>Receiving a becomeFirstResponder message. If necessary, an object can send itself this message.</li>
</ol>
<h2 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h2><p>定义：The responder chain is a series of linked responder objects. It starts with the first responder and ends with the application object.</p>
<p>作用：If the first responder cannot handle an event, it forwards the event to the next responder in the responder chain.</p>
<p>响应链用于收下事件：</p>
<ol>
<li>点击事件，事件响应开始于 hit-test view。</li>
<li>Motion：要处理shake-motion事件，第一响应者需要实现UIResponder下motionBegan:withEvent: or motionEnded:withEvent:方法。</li>
<li>Remote：要处理remote事件，第一响应者必须实现UIResponder的 remoteControlReceivedWithEvent:  方法。</li>
<li>Action Message：当操作一个Control，当添加Target并设置为nil时，这个message将沿着responder chain传递。</li>
<li>Editing-menu Message。</li>
<li>Text editing。</li>
</ol>
<h2 id="Responder-Chain-delivery-Path"><a href="#Responder-Chain-delivery-Path" class="headerlink" title="Responder Chain delivery Path"></a>Responder Chain delivery Path</h2><p>如果initial对象（hit-test view 或者 first Responder）不能处理事件，则将事件通过next Responder沿着Chain传递。每个Responder决定是否处理这个事件，或者沿着Chain继续传递下去。</p>
<p><img src="http://7xsq10.com2.z0.glb.clouddn.com/2_2.jpg" alt="Figure2_2"></p>
<p>参考官方文档链接：<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/EventHandler-PG/" data-id="cin6wvsam000ekhzls9n370iz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OC-运行时概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/OC-运行时概记/" class="article-date">
  <time datetime="2016-04-06T12:29:15.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/OC-运行时概记/">OC_运行时概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>必然时间太久还是会忘，还是记一下吧。</p>
<p>Guide中对runtime解释：The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
<p>OC将决议从编译时延迟到运行时，作为动态运行。这意味着不但需要编译器，同时还需要一个运行时系统来执行编译代码。这个运行时系统为OC充当一个操作系统，使其能够运行。</p>
<h3 id="Interact"><a href="#Interact" class="headerlink" title="Interact"></a>Interact</h3><ol>
<li>通过源码实现功能，编译后动态运行。</li>
<li>通过NSObject 提供的部分查询method，如methodForSelector: \ respondsToSelector:等。</li>
<li>通过runtime functions。</li>
</ol>
<p>OC定义Class结构，在/objc/runtime.h中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>表示一个实例对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看几个重要的定义：<br>OC版本源文件内定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">struct objc_method_description &#123;</span><br><span class="line">	SEL name;               /**&lt; The name of the method */</span><br><span class="line">	char *types;            /**&lt; The types of the method arguments */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>在Swift库中已经预留出和OC版源文件相同的头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import ObjectiveC.List</span><br><span class="line">import ObjectiveC.NSObjCRuntime</span><br><span class="line">import ObjectiveC.NSObject</span><br><span class="line">import ObjectiveC.Object</span><br><span class="line">import ObjectiveC.Protocol</span><br><span class="line">import ObjectiveC.message</span><br><span class="line">import ObjectiveC.objc</span><br><span class="line">import ObjectiveC.objc_api</span><br><span class="line">import ObjectiveC.objc_auto</span><br><span class="line">import ObjectiveC.objc_class</span><br><span class="line">import ObjectiveC.objc_exception</span><br><span class="line">import ObjectiveC.objc_load</span><br><span class="line">import ObjectiveC.objc_runtime</span><br><span class="line">import ObjectiveC.objc_sync</span><br><span class="line">import ObjectiveC.runtime</span><br></pre></td></tr></table></figure>
<p>在Apple开源的Foundation project内有如此说明：</p>
<p><strong>Runtime: The basis for interoperability.</strong></p>
<p>The classes and methods in this group provide an interface for interoperability between C code and Swift. They also provide common layers used throughout the framework such as the root class NSObject.</p>
<ol>
<li>NSObject is mostly implemented.</li>
<li>NSEnumerator is fully implemented.</li>
<li>NSSwiftRuntime (internal use only) contains Swift runtime-specific functionality.</li>
<li>NSObjCRuntime is missing some key parts such as NSClassFromString. Much of the functionality here is specific to the Objective-C runtime and is not relevant when building for Swift.</li>
</ol>
<p>Swift库ObjectiveC.runtime内定义，对runtime用Swift语法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">public typealias Method = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">public typealias Ivar = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents a category.</span><br><span class="line">public typealias Category = COpaquePointer</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">public typealias objc_property_t = COpaquePointer</span><br><span class="line"></span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br><span class="line"></span><br><span class="line">/// Defines a method</span><br><span class="line">public struct objc_method_description &#123;</span><br><span class="line">    /**&lt; The name of the method */</span><br><span class="line">    public var name: Selector</span><br><span class="line">    /**&lt; The types of the method arguments */</span><br><span class="line">    public var types: UnsafeMutablePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: Selector, types: UnsafeMutablePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">public struct objc_property_attribute_t &#123;</span><br><span class="line">    /**&lt; The name of the attribute */</span><br><span class="line">    public var name: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">    public var value: UnsafePointer&lt;Int8&gt;</span><br><span class="line">    public init()</span><br><span class="line">    public init(name: UnsafePointer&lt;Int8&gt;, value: UnsafePointer&lt;Int8&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Method 表示方法，分成Selector 和 IMP 部分。</li>
<li>Ivar 表示实例对象的变量。</li>
<li>Category 表示OC范筹。</li>
<li>objc_property_t 表示属性。</li>
</ol>
<h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h3><ol>
<li>将语法 [receiver message] 翻译成 objc_msgSend(receiver, selector)。</li>
<li>在objc_cache中查找方法。</li>
<li>如果在cache中没找到，则在 objc_method_list 里查找， 如果找到则 缓存。</li>
<li>如果在 objc_method_list 里没找到，则在指向父类查找。</li>
</ol>
<h3 id="Dynamic加载"><a href="#Dynamic加载" class="headerlink" title="Dynamic加载"></a>Dynamic加载</h3><h6 id="Dynamic-Method-Resolution"><a href="#Dynamic-Method-Resolution" class="headerlink" title="Dynamic Method Resolution"></a>Dynamic Method Resolution</h6><p>定义一个Class 未实现 objectSend方法，动态用 resolveObjectSend方法替换实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)resolveObjectSend &#123;</span><br><span class="line">    NSLog(@&quot;resolve message send ....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    if (sel == @selector(objectSend)) &#123;</span><br><span class="line">        IMP res = class_getMethodImplementation([self class], @selector(resolveObjectSend));</span><br><span class="line">        BOOL result = class_addMethod([self class], sel, res, &quot;v@:&quot;);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            NSLog(@&quot;method added ....&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否为 objectSend 消息。</li>
<li>用运行时方法取出 resolveObjectSend 方法 对应的实现。</li>
<li>增加方法，用 resolveObjectSend 的实现 作为 objectSend 的实现。</li>
</ol>
<p>对于实例方法或者类方法没有实现的，可以用 resolveInstanceMethod 或者 resolveClassMethod 动态添加实现。</p>
<h3 id="消息转发-Message-Forwarding"><a href="#消息转发-Message-Forwarding" class="headerlink" title="消息转发 Message Forwarding"></a>消息转发 Message Forwarding</h3><p>在发送一个消息对对象后，如果对象不能处理消息，则会产生运行时错误，在抛出这个错误之前runtime会用forwardInvocation再进行一次处理 — 称为消息转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void) forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([anInvocation selector] == @selector(objectSend)) &#123;</span><br><span class="line">        anInvocation.selector = @selector(resolveObjectSend);</span><br><span class="line">        [anInvocation invokeWithTarget:another];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature * signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        signature = [another methodSignatureForSelector:@selector(resolveObjectSend)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时func使用"><a href="#运行时func使用" class="headerlink" title="运行时func使用"></a>运行时func使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">    var pro : NSArray = [1, 2]</span><br><span class="line">    var pro1 : NSString = &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObject = MyClass()</span><br><span class="line">myObject.pro = [2, 3]</span><br><span class="line"></span><br><span class="line">let proName : String = &quot;pro&quot;</span><br><span class="line">let iii : [CChar]? = proName.cStringUsingEncoding(NSUTF8StringEncoding)</span><br><span class="line">let iva : Ivar = class_getInstanceVariable(MyClass.self, iii!)</span><br><span class="line">let valueForIva = object_getIvar(myObject, iva)  // [2, 3]</span><br><span class="line"></span><br><span class="line">var count : UInt32 = 0</span><br><span class="line">let list = class_copyIvarList(MyClass.self, &amp;count)</span><br><span class="line"></span><br><span class="line">for i in 0..&lt;Int(count) &#123;</span><br><span class="line">    let name = ivar_getName(list[i])</span><br><span class="line">    print(String(UTF8String: name))  // Optional(&quot;pro&quot;)   // Optional(&quot;pro1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let my = MyClass()</span><br><span class="line">object_getIvar(my, list[1])   // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">list.dealloc(2)</span><br></pre></td></tr></table></figure>
<p>参考官方文档地址： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/OC-运行时概记/" data-id="cin6wvsaz000mkhzll8j35z3x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-责任链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/责任链/" class="article-date">
  <time datetime="2016-04-06T07:24:25.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/责任链/">责任链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//职责链是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。<br>//将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>//对象本身要经过什么处理是通过每个链上元素通过运行态来决定的，决定的因素是取决于对象的属性或者一些其他方面的策略。<br>//用户无论是从哪一个节点作为他的请求头节点，最终用户都可以得到一个请求的反馈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">struct LeaveRequest &#123;</span><br><span class="line">    var id : Int</span><br><span class="line">    var day : Float</span><br><span class="line">    var reason : String</span><br><span class="line">    </span><br><span class="line">    func checkReason() &#123;</span><br><span class="line">        print(reason)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol LeaveHandler &#123;</span><br><span class="line">    var nextLevel : LeaveHandler? &#123;get set&#125;</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request : LeaveRequest) -&gt; Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension LeaveHandler &#123;</span><br><span class="line">    mutating func setNextLevel(next : LeaveHandler) &#123;</span><br><span class="line">        self.nextLevel = next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func nextLevelHandler(request : LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if let next = nextLevel &#123;</span><br><span class="line">            return next.handlerLeaveRequest(request)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request : LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        return nextLevelHandler(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Boss : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 4 &lt; request.day &amp;&amp; request.day &lt; 7 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;No Rule ...&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct HR : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 2 &lt; request.day &amp;&amp; request.day &lt;= 4 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            </span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PM : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if 1 &lt; request.day &amp;&amp; request.day &lt;= 2 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Leader : LeaveHandler &#123;</span><br><span class="line">    var name : String</span><br><span class="line">    internal var nextLevel : LeaveHandler?</span><br><span class="line">    </span><br><span class="line">    func handlerLeaveRequest(request: LeaveRequest) -&gt; Bool &#123;</span><br><span class="line">        if request.day &lt;= 1 &#123;</span><br><span class="line">            request.checkReason()</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nextLevelHandler(request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let boss = Boss(name: &quot;Boss&quot;, nextLevel: nil)</span><br><span class="line">let hr = HR(name: &quot;HR&quot;, nextLevel: boss)</span><br><span class="line">let pm = PM(name: &quot;PM&quot;, nextLevel: hr)</span><br><span class="line">let leader = Leader(name: &quot;leader&quot;, nextLevel: pm)</span><br><span class="line"></span><br><span class="line">let leaveRequest = LeaveRequest(id: 1, day: 3, reason: &quot;个人原因&quot;)</span><br><span class="line">leader.handlerLeaveRequest(leaveRequest)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/责任链/" data-id="cin6wvsbu001bkhzljjntbs6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pattern/">Pattern</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Unicode-UFT8-概记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/Unicode-UFT8-概记/" class="article-date">
  <time datetime="2016-04-05T11:32:24.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/Unicode-UFT8-概记/">Unicode_UFT8_概记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p>
<p>Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。</p>
<p>Unicode计划使用了17个平面，一共有17×65536=1114112个码位。在Unicode 5.0.0版本中，已定义的码位只有238605个，分布在平面0、平面1、平面2、平面14、平面15、平面16。其中平面15和平面16上只是定义了两个各占65534个码位的专用区（Private Use Area），分别是0xF0000-0xFFFFD和0x100000-0x10FFFD。所谓专用区，就是保留给大家放自定义字符的区域，可以简写为PUA。</p>
<p>平面0也有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。</p>
<p>如前所述在Unicode 5.0.0版本中，238605-65534*2-6400-2048=99089。余下的99089个已定义码位分布在平面0、平面1、平面2和平面14上，它们对应着Unicode定义的99089个字符，其中包括71226个汉字。平面0、平面1、平面2和平面14上分别定义了52080、3419、43253和337个字符。平面2的43253个字符都是汉字。平面0上定义了27973个汉字。</p>
<p>在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：UTF-8、UTF-16、UTF-32。<strong><em>UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。</em></strong><br>例如，“汉字”对应的数字是0x6c49和0x5b57，而编码的程序数据是：</p>
<p>| | | |<br>|<br>|1 | char  |    data_utf8[]={0xE6,0xB1,0x89,0xE5,0xAD,0x97};//UTF-8编码|<br>|2 | char16_t |  data_utf16[]={0x6C49,0x5B57};        //UTF-16编码|<br>|3 | char32_t |  data_utf32[]={0x00006C49,0x00005B57};//UTF-32编码|</p>
<p><strong><em>UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式</em></strong></p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：</p>
<p>|Unicode编码(十六进制)　|UTF-8 字节流(二进制)|<br>|<br>|00000000 - 0000007F | 0xxxxxxx |<br>|00000080 - 000007FF | 110xxxxx 10xxxxxx |<br>|00000800 - 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |<br>|00010000 - 001FFFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>|00200000 - 03FFFFFF |    111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>|04000000 - 7FFFFFFF |    1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |</p>
<p>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是6个字节。从上表可以看出，6字节模板有31个x，即可以容纳31位二进制数字。Unicode的最大码位0x7FFFFFFF也只有31位。</p>
<h6 id="例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx-10xxxxxx-10xxxxxx。将0x6C49写成二进制是：0110-1100-0100-1001，-用这个比特流依次代替模板中的x，得到：11100110-10110001-10001001，即E6-B1-89。"><a href="#例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx-10xxxxxx-10xxxxxx。将0x6C49写成二进制是：0110-1100-0100-1001，-用这个比特流依次代替模板中的x，得到：11100110-10110001-10001001，即E6-B1-89。" class="headerlink" title="例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。"></a>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</h6><h6 id="例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx-10xxxxxx-10xxxxxx-10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0-0010-0000-1100-0011-0000，用这个比特流依次代替模板中的x，得到：11110000-10100000-10110000-10110000，即F0-A0-B0-B0。"><a href="#例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx-10xxxxxx-10xxxxxx-10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0-0010-0000-1100-0011-0000，用这个比特流依次代替模板中的x，得到：11110000-10100000-10110000-10110000，即F0-A0-B0-B0。" class="headerlink" title="例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。"></a>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。</h6><h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16编码以16位无符号整数为单位。我们把Unicode<br>unicode<br>unicode<br>编码记作U。编码规则如下：<br>如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。<br>如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。</p>
<p>百度链接 ： <a href="http://baike.baidu.com/link?url=Knk24RC6XBNUrL6Rd6oMkiJvB5ZPut2fNasaco1BoKCwgPj254kWmXc-JizuydvO7MLJmLknsygroeOyCjOsb_" target="_blank" rel="external">http://baike.baidu.com/link?url=Knk24RC6XBNUrL6Rd6oMkiJvB5ZPut2fNasaco1BoKCwgPj254kWmXc-JizuydvO7MLJmLknsygroeOyCjOsb_</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/Unicode-UFT8-概记/" data-id="cin6wvsbf000ykhzlqbz9fexy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/">Other</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Revel-Filter-Chain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/04/Revel-Filter-Chain/" class="article-date">
  <time datetime="2016-04-04T14:09:20.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/Revel-Filter-Chain/">Revel Filter Chain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前有提到在启用服务后，在Handle回调内处理请求会调用 <code>Filters[0](c, Filters[1:])</code>。<br>关于Filter整个处理涉及到知识点过多，对于不太理解的地方待以后慢慢补充。。。。</p>
<h2 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h2><p>在filter.go文件内定义了官方标准Filter chain的11个Filter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Filters = []Filter&#123;</span><br><span class="line">	PanicFilter,             // Recover from panics and display an error page instead.</span><br><span class="line">	RouterFilter,            // Use the routing table to select the right Action.</span><br><span class="line">	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.</span><br><span class="line">	ParamsFilter,            // Parse parameters into Controller.Params.</span><br><span class="line">	SessionFilter,           // Restore and write the session cookie.</span><br><span class="line">	FlashFilter,             // Restore and write the flash cookie.</span><br><span class="line">	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.</span><br><span class="line">	I18nFilter,              // Resolve the requested language.</span><br><span class="line">	InterceptorFilter,       // Run interceptors around the action.</span><br><span class="line">	CompressFilter,          // Compress the result.</span><br><span class="line">	ActionInvoker,           // Invoke the action.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PanicFilter"><a href="#PanicFilter" class="headerlink" title="PanicFilter"></a>PanicFilter</h4><p>在panic.go内，这个Filter定义的功能相对简单，定义一个defer func等待处理 Package builtin 的 panic 调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func PanicFilter(c *Controller, fc []Filter) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err := recover(); err != nil &#123;</span><br><span class="line">			handleInvocationPanic(c, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fc[0](c, fc[1:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在整个Chain内有错误发生，则抓取错误信息作为c.Result渲染。</p>
<h4 id="RouterFilter"><a href="#RouterFilter" class="headerlink" title="RouterFilter"></a>RouterFilter</h4><p>在router.go内，从MainRouter 根据Request 找出路由信息：</p>
<ol>
<li>判定路由如果不存在，则渲染 NotFound 错误。</li>
<li>判定route 的Action 如果是404，则渲染 NotFound 错误。</li>
<li>如果给Controller 设置 Action 出现错误， 则渲染 NotFound 错误。</li>
</ol>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Add the route and fixed params to the Request Params.</span><br><span class="line">c.Params.Route = route.Params</span><br><span class="line"></span><br><span class="line">// Add the fixed parameters mapped by name.</span><br><span class="line">// TODO: Pre-calculate this mapping.</span><br><span class="line">for i, value := range route.FixedParams &#123;</span><br><span class="line">	if c.Params.Fixed == nil &#123;</span><br><span class="line">		c.Params.Fixed = make(url.Values)</span><br><span class="line">	&#125;</span><br><span class="line">	if i &lt; len(c.MethodType.Args) &#123;</span><br><span class="line">		arg := c.MethodType.Args[i]</span><br><span class="line">		c.Params.Fixed.Set(arg.Name, value)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		WARN.Println(&quot;Too many parameters to&quot;, route.Action, &quot;trying to add&quot;, value)</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fc[0](c, fc[1:])</span><br></pre></td></tr></table></figure>
<ol>
<li><code>c.Params.Route = route.Params</code>， 类似REST声明的参数赋值给 Params.Route（Route url.Values // Parameters extracted from the route,  e.g. /customers/{id}）</li>
<li>在配置Router里可以设置固定参数，现在将固定参数赋值给 Params.Fixed (Fixed url.Values // Fixed parameters from the route, e.g. App.Action(“fixed param”))</li>
</ol>
<h4 id="FilterConfiguringFilter"><a href="#FilterConfiguringFilter" class="headerlink" title="FilterConfiguringFilter"></a>FilterConfiguringFilter</h4><p>filterconfig.go是针对Controller.Action定制Filter 的地方，并声明一个 <code>var filterOverrides = make(map[string][]Filter)</code> 管理定制的Filter Chain。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Note: the last filter stage is not subject to the configurator.  In</span><br><span class="line">// particular, Add() adds a filter to the second-to-last place.</span><br><span class="line">type FilterConfigurator struct &#123;</span><br><span class="line">	key            string // e.g. &quot;App&quot;, &quot;App.Action&quot;</span><br><span class="line">	controllerName string // e.g. &quot;App&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了3个生成 FilterConfigurator 的方法：</p>
<ol>
<li><code>func newFilterConfigurator(controllerName, methodName string) FilterConfigurator</code></li>
<li><code>func FilterController(controllerInstance interface{}) FilterConfigurator</code></li>
<li><code>func FilterAction(methodRef interface{}) FilterConfigurator</code></li>
</ol>
<p>再定义如Add、Remove等操作方法。</p>
<h6 id="FilterConfiguringFilter-操作"><a href="#FilterConfiguringFilter-操作" class="headerlink" title="FilterConfiguringFilter 操作"></a>FilterConfiguringFilter 操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// FilterConfiguringFilter is a filter stage that customizes the remaining</span><br><span class="line">// filter chain for the action being invoked.</span><br><span class="line">func FilterConfiguringFilter(c *Controller, fc []Filter) &#123;</span><br><span class="line">	if newChain := getOverrideChain(c.Name, c.Action); newChain != nil &#123;</span><br><span class="line">		newChain[0](c, newChain[1:])</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	fc[0](c, fc[1:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// getOverrideChain retrieves the overrides for the action that is set</span><br><span class="line">func getOverrideChain(controllerName, action string) []Filter &#123;</span><br><span class="line">	if newChain, ok := filterOverrides[action]; ok &#123;</span><br><span class="line">		return newChain</span><br><span class="line">	&#125;</span><br><span class="line">	if newChain, ok := filterOverrides[controllerName]; ok &#123;</span><br><span class="line">		return newChain</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判定是否有定制的Filter Chain，如果有则接着定制的Filter Chain走。</li>
<li>判定如果没有 则继续 正常的Filter Chain。</li>
</ol>
<h2 id="ParamsFilter"><a href="#ParamsFilter" class="headerlink" title="ParamsFilter"></a>ParamsFilter</h2><p>这个很直接，为了解析请求参数，这个Filter内定义了三个功能步骤：<br>第一步，解析参数：</p>
<ol>
<li><code>params.Query = req.URL.Query()</code>， 设置查询参数 （Query url.Values // Parameters from the query string, e.g. /index?limit=10）</li>
<li>如果是application/x-www-form-urlencoded，解析Form参数，<code>params.Form = req.Form</code>， （Form  url.Values // Parameters from the request body.）</li>
<li>如果是multipart/form-data，解析Form信息，设置 (Form  url.Values // Parameters from the request body.)、（Files    map[string][]*multipart.FileHeader // Files uploaded in a multipart form）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params.Form = req.MultipartForm.Value</span><br><span class="line">params.Files = req.MultipartForm.File</span><br></pre></td></tr></table></figure>
<p>第二步，定义defer func，负责在最后的Filter Chain调用完成后清理 请求参数。<br>第三步，继续Filter Chain。</p>
<h2 id="SessionFilter"><a href="#SessionFilter" class="headerlink" title="SessionFilter"></a>SessionFilter</h2><p>在session.go里，主要功能是配置 和 保存 session，关于session的管理未记录。</p>
<ol>
<li><code>c.Session = restoreSession(c.Request.Request)</code>，恢复一个session（如果有则直接取出，没有则重新初始化一个session）</li>
<li><code>c.RenderArgs[&quot;session&quot;] = c.Session</code>，设置render参数session。</li>
<li>继续执行Filster Chain.</li>
<li>执行完后续Filter Chain后，判定是否存在session，设置Cookie。</li>
</ol>
<h2 id="FlashFilter"><a href="#FlashFilter" class="headerlink" title="FlashFilter"></a>FlashFilter</h2><p>在flash.go里，主要功能是配置 和 保存 flash cookie信息。<br>说来比较惭愧，关于Flash Cookie这个名字还真是第一次听说。</p>
<p>同Http Cookie一样，Flash Cookie也就是记录用户在访问Flash网页的时候保留的信息，鉴于Flash技术的普遍性，几乎所有的网站都采用，所以具有同Http Cookie一样的作用。但是相比起Http Cookie，Flash Cookie更加强大：1、容量更大，Flash Cookie可以容纳最多100千字节的数据，而一个标准的HTTP Cookie只有4千字节;2、FlashCookie没有默认的过期时间;3、FlashCookie将被存储在不同的地点，这使得它们很难被找到。而在10.3版本之前，几乎没有简单删除Flash Cookie的办法。</p>
<ol>
<li><code>c.Flash = restoreFlash(c.Request.Request)</code>，恢复一个 flash。</li>
<li><code>c.RenderArgs[&quot;flash&quot;] = c.Flash.Data</code>，设置render参数flash。</li>
<li>继续执行Filster Chain。</li>
<li>在执行完Filster Chain后，拼接flashValue值。</li>
<li>最后用flashValue生成http.Cookie，给controller设置Cookie。</li>
</ol>
<h2 id="ValidationFilter"><a href="#ValidationFilter" class="headerlink" title="ValidationFilter"></a>ValidationFilter</h2><p>在validation.go里， 这个文件定义了检验常规内容的func功能，并会保存成 ValidationError。</p>
<ol>
<li>恢复Cookie对应的Error信息。</li>
<li>为controller赋值一个Validation。</li>
<li><code>hasCookie := (err != http.ErrNoCookie)</code>，判定是否存在Error Cookie。</li>
<li>继续执行Filter Chain。</li>
<li>执行完Filter Chain后，<code>c.RenderArgs[&quot;errors&quot;] = c.Validation.ErrorMap()</code>，设置render校验错误参数errors。</li>
<li>拼接错误信息，给controller将错误信息设置成错误Cookie信息。</li>
</ol>
<h2 id="I18nFilter"><a href="#I18nFilter" class="headerlink" title="I18nFilter"></a>I18nFilter</h2><p>在i18n.go里，处理国际化相关内容，具体应用待研究。</p>
<ol>
<li><code>hasLocaleCookie(c.Request)</code>，判定是否存在Cookie设置本地化信息，如果有则以此为准。</li>
<li>cookie不成功后，<code>hasAcceptLanguageHeader(c.Request)</code>，判定是否存在接收语言设置本地化。</li>
<li>如果以上都不存在的情况下，则设置为空。</li>
<li>继续执行Filter Chain。</li>
</ol>
<h2 id="InterceptorFilter"><a href="#InterceptorFilter" class="headerlink" title="InterceptorFilter"></a>InterceptorFilter</h2><p>在intercept.go里，主要功能是采用AOP思维，插入操作功能。</p>
<p>添加方式：revel.InterceptMethod((*FoodController).Before, revel.BEFORE)</p>
<ol>
<li>针对controller查找嵌入的BEFORE功能点，并执行。</li>
<li>嵌入BEFORE后，Result是否为空，不为空就结束。</li>
<li>继续执行Filter Chain。</li>
<li>完成后，针对controller查找嵌入的AFTER的功能点，并执行。</li>
<li>采用defer 判定是否存在 panic嵌入功能点，如果存在则执行。</li>
<li>采用defer，针对controller查找嵌入的FINALLY的功能点，并执行。</li>
</ol>
<h2 id="CompressFilter"><a href="#CompressFilter" class="headerlink" title="CompressFilter"></a>CompressFilter</h2><p>在compress.go里，主要处理HTTP响应需要的格式信息。</p>
<ol>
<li>执行后续的Filter Chain。</li>
<li>后续功能完成后，执行响应数据封装—-需要研究下，这里对HTTP响应的处理工作。</li>
</ol>
<h2 id="ActionInvoker"><a href="#ActionInvoker" class="headerlink" title="ActionInvoker"></a>ActionInvoker</h2><p>在invoker.go里，完成controller的调用工作。</p>
<ol>
<li>根据reflect得到method。</li>
<li>组装获取请求参数。</li>
<li>调用得到Result。</li>
</ol>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>也可以自定义Filter，追加到合适的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var HeaderFilter = func(c *revel.Controller, fc []revel.Filter) &#123;</span><br><span class="line">	// Add some common security headers</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;)</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;)</span><br><span class="line">	c.Response.Out.Header().Add(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;)</span><br><span class="line"></span><br><span class="line">	fc[0](c, fc[1:]) // Execute the next filter stage.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/04/Revel-Filter-Chain/" data-id="cin6wvsc4001ikhzl5lev7cgg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pattern/">Pattern</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Pattern/" style="font-size: 15px;">Pattern</a> <a href="/tags/Swift/" style="font-size: 17.5px;">Swift</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/后端/" style="font-size: 17.5px;">后端</a> <a href="/tags/工具/" style="font-size: 12.5px;">工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/18/View-PG/">View-PG</a>
          </li>
        
          <li>
            <a href="/2016/04/12/Concurrency-PG/">Concurrency-PG</a>
          </li>
        
          <li>
            <a href="/2016/04/11/RunLoop/">RunLoop</a>
          </li>
        
          <li>
            <a href="/2016/04/09/KVO-PG/">KVO_PG</a>
          </li>
        
          <li>
            <a href="/2016/04/08/KVC-PG/">KVC_PG</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 天晷<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>